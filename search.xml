<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[iOS.Metal]Metal基础知识(一)</title>
    <url>/content/f9f932f7.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>Metal 是苹果 (Apple) 在2014 年推出的底层 GPU 编程框架。与 OpenGL ES 类似，均是用于与 3D 图形硬件交互的低级 API 。区别在于 Metal 不是跨平台的，而 OpenGL 是跨平台的，但是 Metal 相对 OpenGL ，在 Apple 平台上具有更高的速度和更低的开销，可以最大限度的利用 GPU 的能力。</p>
<a id="more"></a>

<p>GPU ( Graphics Processing Unit )，是专门处理图形图像的处理器，可以非常快速和高效地进行并行浮点运算，这些运算如果运行在 CPU ( Central Processing Unit ) 上的代价是非常昂贵的。</p>
<p>Metal 是支持 GPU 加速的高级3D图形渲染和数据并行计算的框架。它为图形和计算命令的组织、处理、提交以及管理这些命令的相关数据和资源提供了一个现代化的、精简的 API 。Metal 的主要目标是最大程度地减少执行 GPU 工作负载所导致的 CPU 开销。</p>
<p>很多高级 Apple 框架都建立在 Metal 之上，以利用其性能，包括 <a href="https://developer.apple.com/documentation/coreimage" target="_blank" rel="noopener">Core Image</a> ，<a href="https://developer.apple.com/documentation/spritekit" target="_blank" rel="noopener">SpriteKit</a> ，<a href="https://developer.apple.com/documentation/scenekit" target="_blank" rel="noopener">SceneKit</a> 。可以直接使用这些高级框架来避免接触 GPU 编程的细节，但是编写自定义的 Metal 代码可以获得更高的性能。</p>
<p>Metal 框架提供以下功能：</p>
<ul>
<li><strong>低开销的接口</strong>：Metal 皆在消除隐藏的性能瓶颈，比如隐式状态验证。可以控制 GPU 的异步行为，以实现用于并行创建和提交命令缓冲区的高效多线程。</li>
<li><strong>内存和资源管理</strong>：Metal 框架描述了代表 GPU 内存分配的缓冲区和纹理对象。纹理对象具有特定的像素格式，可以用于纹理图像和附件。</li>
<li><strong>对图形和计算操作的集成支持</strong>：Metal 对图形和计算操作使用相同的数据结构和资源（例如缓冲区，纹理和命令队列）。此外，Metal 着色语言支持图形和计算功能。 Metal框架使资源可以在运行时界面，图形着色器和计算功能之间共享。</li>
<li><strong>预编译的着色器</strong>：Metal 着色器可以在构建时与应用程序代码一起编译，然后在运行时加载。此工作流提供了更好的代码生成以及更容易的着色器代码调试。(金属还支持着色器代码的运行时编译)</li>
</ul>
<h4 id="二、基本实现"><a href="#二、基本实现" class="headerlink" title="二、基本实现"></a>二、基本实现</h4><p>要完成一个基本的 Metal 设置，大概需要如下几个步骤：</p>
<ol>
<li>获取 GPU 设备</li>
<li>创建渲染图层</li>
<li>设置顶点缓冲区</li>
<li>设置顶点着色器</li>
<li>设置片段着色器</li>
<li>设置渲染通道(管线)</li>
<li>提交到命令队列</li>
</ol>
<p>作为开篇的基础文章，本文首先从最基本的设置开始，完成在 Metal 中清屏为纯色的实现。上述过程在本文并不会一一实现，只做最基础的说明，后续文章会陆续详细讲解。</p>
<h5 id="1-获取-GPU-设备"><a href="#1-获取-GPU-设备" class="headerlink" title="1. 获取 GPU 设备"></a>1. 获取 GPU 设备</h5><p><code>MTLDevice</code> (定义在 Metal 框架) ：在 Metal 中，GPU 由一个符合 <code>MTLDevice</code> 的协议对象表示。<code>MTLDevice</code> 协议定义了表示单个 GPU 的接口，负责创建和管理用于处理数据并将数据呈现到屏幕的各种持久性的和瞬时的对象。也就是说，<code>MTLDevice</code> 对象表示可以执行命令的 GPU 。可以通过 <code>MTLDevice</code> 协议查询设备属性，创建其他特定于设备的对象，例如缓冲区和纹理，以及对提交给 GPU 执行的渲染和计算命令进行编码和队列操作。细化来说， <code>MTLDevice</code> 可以创建命令队列，队列中包含命令缓冲区，命令缓冲区中又包含编码器，编码器用于设置附加的 GPU 命令。通过使用 <code>MTLDevice</code> 可以发出所有 Metal 命令。</p>
<p>不要自己实现此协议，而是通过使用 <code>MTLCreateSystemDefaultDevice</code> 方法在系统运行时获取首选 GPU。如下：</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> device = <span class="type">MTLCreateSystemDefaultDevice</span>() <span class="keyword">else</span> &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">fatalError</span>( <span class="string">"Failed to get the system's default Metal device."</span> ) </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<blockquote>
<p>Note：可在需要时导入 Metal 框架</p>
</blockquote>
<p><code>MTLDevice</code> 创建的对象开销很大，但是具有持久性。它们中的许多被设计为初始化一次，并在应用程序的整个生命周期内都可以重复使用。</p>
<h5 id="2-创建渲染图层"><a href="#2-创建渲染图层" class="headerlink" title="2. 创建渲染图层"></a>2. 创建渲染图层</h5><p><code>CAMetalLayer</code>  (定义在 QuartzCore 框架) ：当使用 Metal 渲染图层内容时，需要使用 <code>CAMetalLayer</code> ，是它是 <code>CALayer</code> 的子类，是由 Core Animation 提供的，不具备与之交互的功能。苹果建议，当使用 Metal 渲染视图时，应尽量考虑使用 <code>MTKView</code> ，该类会自动包装 <code>CAMetalLayer</code> 对象并提供更高级的抽象。本文章会从最基本的方式入手，所以使用 <code>CAMetalLayer</code> ，后续文章会对 <code>MTKView</code> 做详细说明。</p>
<p>如果使用 <code>UIKit</code> ，需要创建使用 <code>CAMetalLayer</code> 图层，可以覆盖视图的 <code>layerClass</code> 方法，如下：</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">layerClass</span>: <span class="title">AnyClass</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="type">CAMetalLayer</span>.<span class="keyword">self</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当然也可以创建一个 <code>CAMetalLayer</code> 图层，并添加到当前图层，类似如下：</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> metalLayer = <span class="type">CAMetalLayer</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">view.layer.addSublayer(metalLayer)</span></pre></td></tr></table></figure>

<p>有了渲染图层后，可以为其设置一些属性来配置它的底层像素格式和其他的显示行为。如下：</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">metalLayer.device = device  				 	<span class="comment">//1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">metalLayer.pixelFormat = .bgra8Unorm  <span class="comment">//2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">metalLayer.framebufferOnly = <span class="literal">true</span>  	  <span class="comment">//3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">metalLayer.frame = view.layer.frame   <span class="comment">//4</span></span></pre></td></tr></table></figure>

<ol>
<li><code>device</code> 属性决定了 Metal 使用哪个设备对象来创建它的 <code>MTLTexture</code> 对象。当检索一个可绘制对象及其关联纹理时，必须使用相同的设备对象来渲染纹理。其默认值为 <code>nil</code> ，必须在渲染纹理之前设置其值。这里使用之前获取的 <code>MTLDevice</code> 设备对象。</li>
<li><code>pixelFormat</code> 图层纹理的像素格式，默认值为 <code>MTLPixelFormat.bgra8Unorm</code> ，表示用 BGRA 顺序的4个8位标准无符号整数分量的普通格式。通常保持不变即可。</li>
<li><code>framebufferOnly</code> 用于确定图层的纹理是否仅用于渲染。如果值为 <code>true</code> (默认值)，则 <code>CAMetalLayer</code> 类仅使用 <code>renderTarget</code> 用法标志分配其 <code>MTLTexture</code> 对象。Core Animation 可以优化纹理以达到显示的目的。但是，你不能对这些纹理进行取样、读取或写入。如果要支持采样和像素读/写操作(以性能为代价)，将这个值设置为 <code>false</code> 。对于大多数应用程序，建议设置为 <code>true</code> 。</li>
<li>设置图层的 <code>frame</code> 。</li>
</ol>
<p>此外，还有 <code>drawableSize</code> 属性，用于设置渲染图层内容的纹理的大小，以像素为单位。默认情况下，图层会创建大小适合其内容的纹理。也就是说，此属性的值是图层的边界大小乘以 <code>contentsScale</code> 因子。<code>presentsWithTransaction</code> 属性，是一个布尔值，用于确定图层是否使用 Core Animation 事务显示其内容。默认情况下，此值为 <code>false</code> 。<code>CAMetalLayer</code> 会尽快将渲染过程的输出显示到显示器上，并且与任何 Core Animation 事务异步显示。</p>
<p>以上属性，大部分保持默认值即可。更多说明，后续文章会详细介绍，也可查看官方文档：<a href="https://developer.apple.com/documentation/quartzcore/cametallayer" target="_blank" rel="noopener">https://developer.apple.com/documentation/quartzcore/cametallayer</a> 。</p>
<h5 id="3-获取可绘制对象"><a href="#3-获取可绘制对象" class="headerlink" title="3. 获取可绘制对象"></a>3. 获取可绘制对象</h5><p><code>CAMetalDrawable</code> ：Core Animation 为可显示资源对象定义了 <code>CAMetalDrawable</code> 协议 (不要自己实现此协议)。 实现此协议的对象属于 <code>CAMetalLayer</code> 对象。<code>CAMetalDrawable</code> 协议扩展了<code>MTLDrawable</code> 并提供了一个符合 <code>MTLTexture</code> 协议的对象，因此它可以用作呈现命令的目标。要渲染到<code>CAMetalLayer</code> 对象中，应该为每个渲染过程传递一个新的 <code>CAMetalDrawable</code> 对象，获得它提供的<code>MTLTexture</code> 对象，并使用该纹理创建颜色附件。与颜色附件不同，深度或模板附件的创建和销毁成本很高。如果需要深度或模板附件，请创建一次，然后在每次渲染框架时重复使用它们。</p>
<p>在 <code>CAMetalLayer</code> 内部会创建一个 Metal 的可绘制对象( <code>CAMetalDrawable</code> )池，在任何给定的时间，这些可绘制对象池中的一个( <code>CAMetalDrawable</code> 对象 )都包含该图层的内容。要在层中显示 Metal 所呈现的内容，必须从 <code>CAMetalLayer</code> 的可绘制对象池中获得一个可绘制的资源( <code>CAMetalDrawable</code> 对象 )，然后通过将该资源附加到 <code>MTLRenderPassDescriptor</code> 对象来呈现该资源中的纹理。在每次渲染新的一帧时调用其 <code>nextDrawable</code> 方法。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> drawable = metalLayer.nextDrawable() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span></pre></td></tr></table></figure>



<h5 id="4-创建渲染过程描述"><a href="#4-创建渲染过程描述" class="headerlink" title="4. 创建渲染过程描述"></a>4. 创建渲染过程描述</h5><p><code>MTLRenderPassDescriptor</code> ：渲染过程描述符， <code>class</code> 类型，可以看作是一组附件的集合，用于配制渲染过程要达到的效果。也可以为渲染过程生成的可见性信息设置目标缓冲区。</p>
<p>在 GPU 编程中，基本上是将要发送到 GPU 的数据与任何解释该数据的设置进行捆绑发送，而这些解释数据的设置就被封装在 <code>MTLRenderPassDescriptor</code> 中。该设置可以有一个或多个，但是大多数情况下，该设置被限制为仅有一个。</p>
<p><code>MTLRenderPassDescriptor</code> 的属性可以设置颜色 ( Color )、深度 ( Depth )和模版 ( Stencil )像素数据。</p>
<p>这里使用到了颜色附件，所以仅对颜色附件做说明。首先看一下设置方式，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> renderPassDescriptor = <span class="type">MTLRenderPassDescriptor</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">renderPassDescriptor.colorAttachments[<span class="number">0</span>].texture    = drawable.texture</span></pre></td></tr><tr><td class="code"><pre><span class="line">renderPassDescriptor.colorAttachments[<span class="number">0</span>].loadAction = .clear</span></pre></td></tr><tr><td class="code"><pre><span class="line">renderPassDescriptor.colorAttachments[<span class="number">0</span>].clearColor = <span class="type">MTLClearColor</span>(red: <span class="number">1.0</span>, green: <span class="number">1.0</span>, blue: <span class="number">0.0</span>, alpha: <span class="number">1.0</span>)</span></pre></td></tr></table></figure>

<p><code>colorAttachments</code> 的类型是 <code>MTLRenderPassColorAttachmentDescriptorArray</code> ，它是 <code>MTLRenderPassColorAttachmentDescriptor</code> 对象的数组。<code>MTLRenderPassColorAttachmentDescriptor</code> 主要用来配制要渲染的纹理、清屏的颜色和一些其他配置。该类本身只提供了 <code>clearColor</code> 属性，用来设置清屏颜色，其他方法和属性均继承自父类 <code>MTLRenderPassAttachmentDescriptor</code> 。通常，并不会直接创建 <code>MTLRenderPassAttachmentDescriptor</code> 对象使用，而是使用上述提供的 <code>MTLRenderPassDescriptor</code> 对象附件设置即可。</p>
<p><code>texture</code> 用于设置关联的纹理对象，是 <code>MTLTexture</code> 类型。这是一个必须设置的属性，为纹理设置合适的像素格式。这里我们设置步骤3获取的 <code>drawable</code> 的纹理对象即可。</p>
<p><code>loadAction</code> 用来设置在渲染命令编码器 ( <code>MTLRenderCommandEncoder</code> ) 的渲染过程开始时执行的操作，它是 <code>MTLLoadAction</code> 类型，是一个枚举类型，定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">MTLLoadAction</span> : <span class="title">UInt</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//GPU有权在渲染过程开始时丢弃附件的现有内容，将其替换为任意数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> dontCare = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//GPU会在渲染过程开始时保留附件的现有内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> load = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//GPU在渲染过程开始时向附件中的每个像素写入一个值		</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> clear = <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果您的应用为给定帧设置了渲染目标的所有像素，应使用 <code>dontCare</code> ，该操作使 GPU 可以避免加载纹理的现有内容。<code>load</code> 用来保留附件的现有内容。<code>clear</code> 用来清除先前的内容。使用 <code>clear</code> 操作可以避免加载现有纹理内容的成本，但是其本身的设置也需要成本。对于彩色渲染目标，默认值为 <code>MTLLoadAction.dontCare</code> 。对于深度或模具渲染目标，默认值为 <code>MTLLoadAction.clear</code> 。</p>
<p><code>clearColor</code> 是 <code>MTLClearColor</code> 类型，用来设置颜色的 RGBA 值。如果设置 <code>loadAction</code> 属性设置为 <code>MTLLoadAction.clear</code> ，则在渲染过程开始时， GPU 将用 <code>clearColor</code> 中存储的值填充纹理，否则，GPU 将忽略 <code>clearColor</code> 的设置。<code>clearColor</code> 的默认值为 <code>MTLClearColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 1.0)</code> 。</p>
<h5 id="5-创建命令队列"><a href="#5-创建命令队列" class="headerlink" title="5. 创建命令队列"></a>5. 创建命令队列</h5><p><code>MTLCommandQueue</code> (定义在 Metal 框架) ：用于组织提供给 GPU 执行的命令缓冲区的队列，是一个协议，不要主动定义实现此协议。<code>MTLCommandQueue</code> 对象将命令缓冲区的有序列表排队等待 <code>MTLDevice</code> 执行。命令队列是线程安全的，并允许同时编码多个未完成的命令缓冲区。</p>
<p>要创建命令队列，调用 <code>MTLDevice</code> 对象的 <code>makeCommandQueue()</code> 或<code>makeCommandQueue(maxCommandBufferCount:)</code> 方法。由 <code>makeCommandQueue(maxCommandBufferCount:)</code> 方法返回的队列限制未完成命令缓冲区的数量。通常，您会在应用程序启动时创建一个或多个命令队列，然后在应用程序的整个生命周期中保留这些队列。</p>
<p>创建方式如下：</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> commandQueue: <span class="type">MTLCommandQueue!</span> = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">commandQueue = device.makeCommandQueue()</span></pre></td></tr></table></figure>



<h5 id="6-获取命令缓冲区"><a href="#6-获取命令缓冲区" class="headerlink" title="6. 获取命令缓冲区"></a>6. 获取命令缓冲区</h5><p><code>MTLCommandBuffer</code> ：是一个容器，用于存储编码的命令以供 GPU 执行，是一个协议，不要自己实现此协议。要呈现图像或执行计算操作，应通过命令队列 ( <code>MTLCommandQueue</code> ) 创建一个或多个命令缓冲区对象，然后将命令编码到这些对象中，并将它们提交到队列中。有两种方法可以创建 <code>MTLCommandBuffer</code> 对象，通过<code>MTLCommandQueue</code> 的 <code>makeCommandBuffer()</code> 和 <code>makeCommandBufferWithUnretainedReferences()</code> 。在大多数情况下，应使用 <code>makeCommandBuffer()</code> 方法，因为它创建的命令缓冲区，保存了 Metal 在完成命令缓冲区中编码的命令所需的任何对象的强引用。在极少数的情况下，可以使用 <code>makeCommandBufferWithUnretainedReferences()</code> 方法创建一个命令缓冲区，该缓冲区不保留对这些对象的强引用。在这种情况下，您要负责使这些对象保持活动状态，直到命令缓冲区中编码的命令执行完毕。</p>
<p>在使用相应的 <code>MTLCommandQueue</code> 创建命令缓冲区对象后，只能将该命令缓冲区提交到创建它的 <code>MTLCommandQueue</code> 上执行。所有发送到单个命令队列的命令缓冲区都保证按照命令缓冲区入队的顺序执行。</p>
<p>创建方式如下：</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> commandBuffer = commandQueue.makeCommandBuffer()</span></pre></td></tr></table></figure>

<p>在创建完命令缓冲区后，需要创建命令编码器对象 (<code>MTLRenderCommandEncoder</code> ) ，来对缓冲区对象进行填充。<code>MTLCommandBuffer</code> 协议具有创建特定类型的命令编码器的方法，可以创建如下四种类型的编码器：<code>MTLRenderCommandEncoder</code> ， <code>MTLComputeCommandEncoder</code> ，<code>MTLBlitCommandEncoder</code> 和 <code>MTLParallelRenderCommandEncoder</code> 。在任何给定时间，对于特定的命令缓冲区，只有一个编码器可以处于活动状态。可以创建多个命令编码器来向缓冲区添加任务，但是在创建另一个编码器之前，需要结束当前编码器的编码过程。也就是说，创建一个编码器，使用它向缓冲区添加命令，然后结束编码过程。在完成一个编码器之后，才可以创建另一个编码器，并继续向相同的缓冲区添加命令。当准备好执行这组已编码的命令时，可以调用命令缓冲区的 <code>commit()</code> 方法来调度缓冲区以便执行。</p>
<p>在调用 <code>commit()</code> 方法之前，需要调用 <code>present(drawable:)</code> 方法， <code>present(drawable:)</code> 方法用来注册一个可尽快绘制的对象，是一个便利方法。该方法会在命令队列调用命令缓冲区执行完毕之后调用 <code>MTLDrawable</code> 的 <code>present()</code> 方法。 <code>MTLDrawable</code> 的 <code>present()</code> 方法会跟踪命令缓冲区中的命令或可绘制对象。当缓冲区中的命令或可绘制对象请求完成时尽快显示其内容。</p>
<h5 id="7-获取渲染命令编码器"><a href="#7-获取渲染命令编码器" class="headerlink" title="7. 获取渲染命令编码器"></a>7. 获取渲染命令编码器</h5><p><code>MTLRenderCommandEncoder</code> ：用于对渲染过程的命令进行编码的对象，是一个协议。不要使用标准分配和初始化技术来创建 <code>MTLRenderCommandEncoder</code> 对象。应通过调用要在其中进行编码渲染命令的 <code>MTLCommandBuffer</code> 对象的 <code>makeRenderCommandEncoder(descriptor:)</code> 方法创建，如下：</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> renderCommandEncoder = commandBuffer!.makeRenderCommandEncoder(descriptor:renderPassDescriptor)</span></pre></td></tr></table></figure>

<p>然后要调用 <code>endEncoding()</code> 方法结束编码，用于声明编码器的所有命令都已生成完成。当调用 <code>endEncoding()</code> 方法后，渲染命令编码器将不能使用，不能使用此编码器对任何其他命令进行编码。</p>
<blockquote>
<p>Note：因为本文为基础的设置清屏的例子，所以很多设置并未使用到，后续文章会详细说明。</p>
</blockquote>
<p>至此，基本的步骤已经完成。完整设置代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//声明设备</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> device : <span class="type">MTLDevice!</span>             = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//声明渲染图层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> metalLayer : <span class="type">CAMetalLayer!</span>      = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//声明命令队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> commandQueue: <span class="type">MTLCommandQueue!</span>  = <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//获取设备</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        device = <span class="type">MTLCreateSystemDefaultDevice</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//创建渲染图层并进行属性设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        metalLayer                   = <span class="type">CAMetalLayer</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        metalLayer.device            = device</span></pre></td></tr><tr><td class="code"><pre><span class="line">        metalLayer.pixelFormat       = .bgra8Unorm</span></pre></td></tr><tr><td class="code"><pre><span class="line">        metalLayer.framebufferOnly   = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        metalLayer.frame             = view.layer.frame</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//添加到当前图层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        view.layer.addSublayer(metalLayer)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//获取可绘制对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> drawable           = metalLayer.nextDrawable() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//创建渲染过程描述</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> renderPassDescriptor                            = <span class="type">MTLRenderPassDescriptor</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        renderPassDescriptor.colorAttachments[<span class="number">0</span>].texture    = drawable.texture</span></pre></td></tr><tr><td class="code"><pre><span class="line">        renderPassDescriptor.colorAttachments[<span class="number">0</span>].loadAction = .clear</span></pre></td></tr><tr><td class="code"><pre><span class="line">        renderPassDescriptor.colorAttachments[<span class="number">0</span>].clearColor = <span class="type">MTLClearColor</span>(red: <span class="number">1.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.0</span>, alpha: <span class="number">1.0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//创建命令队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        commandQueue                 = device.makeCommandQueue()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//获取命令缓冲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> commandBuffer           = commandQueue.makeCommandBuffer()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//获取编码器进行编码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> renderCommandEncoder    = commandBuffer!.makeRenderCommandEncoder(descriptor:renderPassDescriptor)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//结束编码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        renderCommandEncoder!.endEncoding()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//呈现可绘制内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        commandBuffer!.present(drawable)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//提交缓冲区到队列执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        commandBuffer!.commit()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/f9f932f7/2020-10-27.png" alt="2020-10-27" style="zoom:50%;">



<p>至此，Metal 的基本设置完成。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>ios</tag>
        <tag>Metal</tag>
        <tag>MTLDevice</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十九)</title>
    <url>/content/c316e808.html</url>
    <content><![CDATA[<h4 id="一、AboutListTile-Widget"><a href="#一、AboutListTile-Widget" class="headerlink" title="一、AboutListTile Widget"></a>一、AboutListTile Widget</h4><p><code>AboutListTile</code> 是显示关于框的 <code>ListTile</code> ，继承自 <code>StatelessWidget</code> 。<code>AboutListTile</code> 点击时显示一个带有 <code>showAboutDialog</code> 的关于对话框。此 Widget 常用在 <code>Drawer</code> 中，<code>Drawer</code> 在前述文章介绍过。如果不是在 <code>Drawer</code> 中使用，则应选择调用 <code>showAboutDialog</code> 或 <code>showLicensePage</code> 。</p>
<a id="more"></a>

<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AboutListTile(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，显示的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，应用程序名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationName,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此应用程序版本的版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationVersion,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在AboutDialog中显示在应用程序名称旁边的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，在AboutDialog中以小字体显示的字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationLegalese,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，在名称，版本和legalese之后添加到AboutDialog的小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.aboutBoxChildren,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列表图块是否是垂直密集列表的一部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dense,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ListView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AboutListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              icon: Icon(Icons.home),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"关于"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              applicationName: <span class="string">"标题"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              applicationVersion: <span class="string">"2.1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              applicationIcon: Icon(Icons.map),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              applicationLegalese: <span class="string">"说明文本"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              aboutBoxChildren: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Text(<span class="string">"about"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/2020421454.jpg" alt="2020421454" style="zoom:50%;">



<h4 id="二、AnimatedIcon-Widget"><a href="#二、AnimatedIcon-Widget" class="headerlink" title="二、AnimatedIcon Widget"></a>二、AnimatedIcon Widget</h4><p><code>AnimatedIcon</code> 是显示动画图标的 Widget ，继承自 <code>StatelessWidget</code> 。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AnimatedIcon(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AnimatedIconData类型必传参数，显示的图标，可用图标在AnimatedIcons中列出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Animation&lt;double&gt;类型必传参数，动画图标的动画进度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.progress,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，绘制图标使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，图标的大小（以逻辑像素为单位）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，图标的语义标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，用于呈现图标的文本方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Animation</code> 是动画的基类，在后续文章的动画部分会做详细介绍。</p>
<p><code>AnimatedIcons</code> 中提供了很多可用的 <code>AnimatedIconData</code> 类型图标，查看地址：<a href="https://api.flutter.dev/flutter/material/AnimatedIcons-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/material/AnimatedIcons-class.html</a> 。</p>
<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  AnimationController _controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _controller = AnimationController(vsync: <span class="keyword">this</span>, duration: <span class="built_in">Duration</span>(seconds: <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ..addListener(()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ..forward();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:AnimatedIcon(   					<span class="comment">//AnimatedIcon</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        icon: AnimatedIcons.arrow_menu,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        progress: _controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        size: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/20202421753.gif" alt="20202421753" style="zoom:50%;">



<h4 id="三、BackButton-Widget"><a href="#三、BackButton-Widget" class="headerlink" title="三、BackButton Widget"></a>三、BackButton Widget</h4><p><code>BackButton</code> 是 Material 设计风格的回退按钮，继承自 <code>StatelessWidget</code> 。<code>BackButton</code> 是一个图标按钮，内部基于 <code>IconButton</code> 实现。其内部的 <code>BackButtonIcon</code> 会根据不同的平台环境显示适合特定平台的回退图标。默认情况下，在不设置 <code>onPressed</code> 回调的情况，回退按钮调用 <code>Navigator.maybePop</code> 返回上一条路线。</p>
<p>决定显示 <code>BackButton</code> 时，请考虑使用 <code>ModalRoute.of(context)?.canPop</code> 检查是否可以弹出当前路由。如果该值为假（例如，因为当前路径是初始路径），则按下 <code>BackButton</code> 不会有任何效果。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BackButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，使用的图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，要执行的替代回调，而不是弹出导航器的默认行为</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onPressed </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>onPressed</code> 是 <code>VoidCallback</code> 类型，是一个无返回值的方法，定义为：<code>void Function();</code> 。</p>
<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: BackButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span>(ModalRoute.of(context).canPop)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">print</span>(<span class="string">"回退"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">print</span>(<span class="string">"不可回退"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/20204221043.jpg" alt="20204221043" style="zoom:50%;">



<h4 id="四、Banner-Widget"><a href="#四、Banner-Widget" class="headerlink" title="四、Banner Widget"></a>四、Banner Widget</h4><p><code>Banner</code> 是在另一个 Widget 的角上方显示一条对角线消息的 Widget ，继承自 <code>StatelessWidget</code> 。此 Widget 对于显示应用程序的执行模式很有用。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Banner(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，显示在横幅后面的小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型必传参数，显示在横幅中的消息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.message,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，文本方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BannerLocation类型必传参数，显示横幅的位置（例如，右上角）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.location,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，布局方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.layoutDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，Banner的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = _kColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，标语上显示的文字样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textStyle = _kTextStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中 <code>location</code> 是 <code>BannerLocation</code> 类型，是一个枚举类型值，定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> BannerLocation &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality（或Banner.layoutDirection）为TextDirection.rtl时，在右上角显示横幅；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality为TextDirection.ltr时，在左上角显示横幅</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  topStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality（或Banner.layoutDirection）为TextDirection.rtl时，在左上角显示横幅；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality为TextDirection.ltr时，在右上角显示横幅</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  topEnd,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality（或Banner.layoutDirection）为TextDirection.rtl时，在右下角显示横幅；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality为TextDirection.ltr时，在左下角显示横幅</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  bottomStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality（或Banner.layoutDirection）为TextDirection.rtl时，在左下角显示横幅；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//当环境Directionality为TextDirection.ltr时，在右下角显示横幅</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  bottomEnd,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Banner</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Banner(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"子Widget"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          layoutDirection: TextDirection.rtl,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          message: <span class="string">"Banner"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          location: BannerLocation.topStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/20204221124.jpg" alt="20204221124" style="zoom:50%;">



<h4 id="五、CheckedModeBanner-Widget"><a href="#五、CheckedModeBanner-Widget" class="headerlink" title="五、CheckedModeBanner Widget"></a>五、CheckedModeBanner Widget</h4><p><code>CheckedModeBanner</code> 是在检查模式下运行时显示 “DEBUG” 的横幅，继承自 <code>StatelessWidget</code> 。<code>MaterialApp</code> 默认会构建其中一个。在发布模式中什么都不做。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CheckedModeBanner(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，显示在横幅后面的小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: CheckedModeBanner(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"子Widget"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果与 <code>Banner</code> 类似，不同的只是不能设置特定的属性。</p>
<h4 id="六、ButtonBar-Widget"><a href="#六、ButtonBar-Widget" class="headerlink" title="六、ButtonBar Widget"></a>六、ButtonBar Widget</h4><p><code>ButtonBar</code> 是一个可以包含多个子 Widget 并在水平方向末端对齐的 Widget ，继承自 <code>StatelessWidget</code> 。其子 Widget 通常为按钮，可以通过其属性的设置来调整按钮的宽高等，其他非按钮类 Widget 则不受属性约束。其默认为水平布局，当水平布局无法容纳所有子 Widget 的宽度时，则会变为纵向布局。</p>
<p>可以使用 <code>ButtonBarTheme</code> 配置 <code>ButtonBar</code> 。对于 <code>ButtonBar</code> 上的任何 <code>null</code> 属性，将改用周围的 <code>ButtonBarTheme</code> 属性。如果 <code>ButtonBarTheme</code> 的属性也为 <code>null</code> ，则该属性将默认为以下字段文档中描述的值。</p>
<p><code>children</code> 中的子 Widget 可以包装在 <code>ButtonTheme</code> 中，对特定的子 Widget 进行属性设置。</p>
<p><code>ButtonBar</code> 构造方法如下： </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ButtonBar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisAlignment类型可选命名参数，如何沿水平轴放置孩子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisSize类型可选命名参数，有多少水平空间可用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.mainAxisSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ButtonTextTheme类型可选命名参数，重写周围的ButtonTheme.textTheme，以定义按钮的基本颜色，大小，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//内部填充和形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.buttonTextTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，按钮的最小宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.buttonMinWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，按钮的最小高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.buttonHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，覆盖周围的ButtonThemeData.padding，以定义按钮子级的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//（通常是按钮的标签）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.buttonPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，重写周围的ButtonThemeData.alignedDropdown来定义DropdownButton菜单的宽</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//度是否与按钮的宽度匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.buttonAlignedDropdown,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ButtonBarLayoutBehavior类型可选命名参数，定义ButtonBar应该使用最小尺寸限制还是填充来调整自身大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.layoutBehavior,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，水平排列的按钮</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中，<code>buttonTextTheme</code> 是 <code>ButtonTextTheme</code> 类型，是一个枚举类型值，定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ButtonTextTheme &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮文本是黑色还是白色，具体取决于ThemeData.brightness</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  normal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮文本为ThemeData.accentColor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  accent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮文本基于ThemeData.primaryColor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  primary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>layoutBehavior</code> 是 <code>ButtonBarLayoutBehavior</code> 类型，用于与 <code>ButtonTheme</code> 和 <code>ButtonThemeData</code> 一起使用以定义按钮栏应如何使用约束或内部填充来调整自身大小。是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ButtonBarLayoutBehavior &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮栏将被限制为最小高度52。需要进行此设置才能创建符合材料规格的按钮条。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  constrained,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮栏将从按钮主题填充中计算其填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  padded,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>ButtonBar</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      theme: ThemeData(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        accentColor: Colors.red,    <span class="comment">//配合ButtonTextTheme.accent设置按钮文本颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        buttonTheme: ButtonThemeData(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          disabledColor: Colors.red,   <span class="comment">//按钮不可用状态颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          buttonColor: Colors.greenAccent,  <span class="comment">//按钮启用状态颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        buttonBarTheme: ButtonBarThemeData(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mainAxisSize: MainAxisSize.min,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ButtonBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          buttonTextTheme: ButtonTextTheme.accent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          buttonMinWidth: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          buttonHeight: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"按钮1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()&#123;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"按钮2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ButtonTheme(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              disabledColor: Colors.green,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">150</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child:  RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"按钮3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/2020422346.jpg" alt="2020422346" style="zoom:50%;">



<h4 id="七、DataTable-Widget"><a href="#七、DataTable-Widget" class="headerlink" title="七、DataTable Widget"></a>七、DataTable Widget</h4><p><code>DataTable</code> 是一个 Material 设计风格的数据表，继承自 <code>StatelessWidget</code> 。在表中显示数据非常昂贵，因为要对表进行布局，必须对所有数据进行两次测量，一次要协商用于每一列的维，一次要根据协商的结果实际对表进行布局。因此，如果您有很多数据(比如，超过12行，有12列，但是精确的限制取决于目标设备)，建议您使用 <code>PaginatedDataTable</code> ，它会自动将数据分割成多个页面。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DataTable(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;DataColumn&gt;类型必传参数，表中各列的配置和标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.columns,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，当前主排序键的列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.sortColumnIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，sortColumnIndex中提到的列（如果有）是否按升序排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.sortAscending = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueSetter&lt;bool&gt;类型可选命名参数，当用户使用标题行中的复选框选择或取消选择每一行时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectAll,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每行的高度（不包括包含列标题的行）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dataRowHeight = kMinInteractiveDimension,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，标题行的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.headingRowHeight = <span class="number">56.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，表格边缘与每行第一个和最后一个单元格中的内容之间的水平边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.horizontalMargin = <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个数据列内容之间的水平边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.columnSpacing = <span class="number">56.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;DataRow&gt;类型必传参数，每行要显示的数据（不包括包含列标题的行）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.rows,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中，<code>DataColumn</code> 用于配置数据表列数据。必须为每一列提供一个列配置。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DataColumn(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，列标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，列标题的工具提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列是否代表数字数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.numeric = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DataColumnSortCallback类型可选命名参数，当用户要求使用此列对表格进行排序时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSort,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>DataRow</code> 用于配置行数据，一个 <code>DataRow</code> 代表一行。必须为每一行提供一个行配置。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为数据表的一行创建配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DataRow(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否选择该行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型可选命名参数，当用户选择或取消选择可选行时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;DataCell&gt;类型必传参数，该行的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.cells,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//从行索引派生键，为数据表的行创建配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DataRow.byIndex(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，索引值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> index,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否选择该行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型可选命名参数，当用户选择或取消选择可选行时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;DataCell&gt;类型必传参数，该行的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.cells,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>DataCell</code> 用于配置每个单元格数据。必须在新的 <code>DataRow</code> 构造函数的 <code>cells</code> 参数中为 <code>DataTable</code> 中的每个 <code>DataRow</code> 提供一个 <code>DataCell</code> 对象列表。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DataCell(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，该行的数据  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，孩子实际上是否是占位符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.placeholder = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在单元格末尾显示编辑图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showEditIcon = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，如果单元格被点击则调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onTap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr></table></figure>

<p><code>DataTable</code> 的基本使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> _glAscending = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;UserInfo&gt; students = [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">1</span>, stuName: <span class="string">"张三"</span>, stuAge: <span class="number">20</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">2</span>, stuName: <span class="string">"李四"</span>, stuSex: <span class="string">"男"</span>, isSelected: <span class="keyword">true</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">3</span>, stuName: <span class="string">"王五"</span>, stuAge: <span class="number">15</span>, stuSex: <span class="string">"女"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">4</span>, stuName: <span class="string">"赵六"</span>, stuAge: <span class="number">18</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: DataTable(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          sortColumnIndex: <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          sortAscending: _glAscending,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onSelectAll: (<span class="built_in">bool</span> select)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span>(UserInfo info <span class="keyword">in</span> students)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                info.isSelected = select;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          columns: &lt;DataColumn&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"编号"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              numeric: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onSort: (<span class="built_in">int</span> columnIndex, <span class="built_in">bool</span> ascending)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  _glAscending = ascending;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">if</span>(ascending)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    students.sort((a, b)=&gt; a.stuNum.compareTo(b.stuNum));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    students.sort((a, b)=&gt; b.stuNum.compareTo(a.stuNum));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"姓名"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"年龄"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"性别"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          rows: students.map((UserInfo userInfo)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> DataRow(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              selected: userInfo.isSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onSelectChanged: (<span class="built_in">bool</span> selected)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  userInfo.isSelected = selected;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              cells: &lt;DataCell&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                DataCell(Text(<span class="string">"<span class="subst">$&#123;userInfo.stuNum&#125;</span>"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                DataCell(Text(<span class="string">"<span class="subst">$&#123;userInfo.stuName&#125;</span>"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                DataCell(Text(<span class="string">"<span class="subst">$&#123;userInfo.stuAge&#125;</span>"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                DataCell(Text(<span class="string">"<span class="subst">$&#123;userInfo.stuSex&#125;</span>"</span>), onTap: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(userInfo.stuSex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;).toList(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  UserInfo(&#123;<span class="keyword">this</span>.stuNum, <span class="keyword">this</span>.stuName, <span class="keyword">this</span>.stuAge = <span class="number">0</span>, <span class="keyword">this</span>.stuSex, <span class="keyword">this</span>.isSelected = <span class="keyword">false</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> stuNum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> stuName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> stuAge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> stuSex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isSelected;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/2020423321.gif" alt="2020423321" style="zoom:50%;">



<p><code>DataTable</code> 本身是不提供滚动功能的，如果数据在横向或纵向超出可视范围，需要移动，可将 <code>DataTable</code> 封装在 <code>SingleChildScrollView</code> 等可滚动 Widget 中即可。</p>
<h4 id="八、PaginatedDataTable-Widget"><a href="#八、PaginatedDataTable-Widget" class="headerlink" title="八、PaginatedDataTable Widget"></a>八、PaginatedDataTable Widget</h4><p><code>PaginatedDataTable</code> 是一个 Material 设计风格的数据表，其使用多个页面显示数据，继承自 <code>StatefulWidget</code> 。它惰性的读取数据。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">PaginatedDataTable(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，头部Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.header,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，图标按钮显示在表格的右上方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.actions,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;DataColumn&gt;类型必传参数，表中各列的配置和标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.columns,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，当前主排序键的列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.sortColumnIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，sortColumnIndex中提到的列（如果有）是否按升序排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.sortAscending = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueSetter&lt;bool&gt;类型可选命名参数，当用户使用标题行中的复选框选择或取消选择每一行时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectAll,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每行的高度（不包括包含列标题的行）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dataRowHeight = kMinInteractiveDimension,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，标题行的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.headingRowHeight = <span class="number">56.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，表的边缘与每行的第一个和最后一个单元格中的内容之间的水平边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.horizontalMargin = <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个数据列内容之间的水平边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.columnSpacing = <span class="number">56.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，第一次创建窗口小部件时要显示的第一行的索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialFirstRowIndex = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;int&gt;类型可选命名参数，当用户切换到另一个页面时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onPageChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，每页上显示的行数，默认为10行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.rowsPerPage = defaultRowsPerPage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;int&gt;类型可选命名参数，为rowsPerPage提供的选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.availableRowsPerPage = <span class="keyword">const</span> &lt;<span class="built_in">int</span>&gt;[defaultRowsPerPage, defaultRowsPerPage * <span class="number">2</span>, defaultRowsPerPage * <span class="number">5</span>, defaultRowsPerPage * <span class="number">10</span>],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;int&gt;类型可选命名参数，当用户选择每页不同的行数时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onRowsPerPageChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DataTableSource类型必传参数，提供数据以显示在每一行中的数据源。必须为非null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.source,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中 <code>DataTableSource</code> 用于提供每一行的数据源，继承自 <code>ChangeNotifier</code> ，是一个抽象类。数据源提供两个主要信息：数据表中的行数( <code>rowCount</code> ) 和每行的数据。因为其为一个抽象类，且没有提供任何的可用子类，所以需要自定义类并继承 <code>DataTableSource</code> ，必须重写 <code>DataRow getRow(int index)</code> 方法和 <code>isRowCountApproximate</code> 、<code>rowCount</code>  、<code>selectedRowCount</code> 属性。</p>
<p>实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;UserInfo&gt; students = [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">1</span>, stuName: <span class="string">"张三"</span>, stuAge: <span class="number">20</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">2</span>, stuName: <span class="string">"李四"</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">3</span>, stuName: <span class="string">"王五"</span>, stuAge: <span class="number">15</span>, stuSex: <span class="string">"女"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">4</span>, stuName: <span class="string">"赵六"</span>, stuAge: <span class="number">18</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">5</span>, stuName: <span class="string">"张三"</span>, stuAge: <span class="number">20</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">6</span>, stuName: <span class="string">"李四"</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">7</span>, stuName: <span class="string">"王五"</span>, stuAge: <span class="number">15</span>, stuSex: <span class="string">"女"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">4</span>, stuName: <span class="string">"赵六"</span>, stuAge: <span class="number">18</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">5</span>, stuName: <span class="string">"张三"</span>, stuAge: <span class="number">20</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">6</span>, stuName: <span class="string">"李四"</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">7</span>, stuName: <span class="string">"王五"</span>, stuAge: <span class="number">15</span>, stuSex: <span class="string">"女"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserInfo(stuNum: <span class="number">8</span>, stuName: <span class="string">"赵六"</span>, stuAge: <span class="number">18</span>, stuSex: <span class="string">"男"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MyDataTableSource tableSource;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> perPageValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> _glAscending = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> valueIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tableSource = MyDataTableSource(students);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//每页显示多少条数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    perPageValue = <span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> sort(<span class="built_in">int</span> columnIndex, <span class="built_in">bool</span> ascending) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tableSource._sort(columnIndex, ascending);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(columnIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      valueIndex = columnIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _glAscending = ascending;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: PaginatedDataTable(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          header: Text(<span class="string">"学生信息记录表"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//每页显示行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          rowsPerPage: perPageValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//全选时的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          onSelectAll: tableSource._selectAll,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//升序或降序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          sortAscending: _glAscending,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//排序的主键列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          sortColumnIndex: valueIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//点击翻页时的回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          onPageChanged: (<span class="built_in">int</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//改变每页显示的行数时的回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          onRowsPerPageChanged: (<span class="built_in">int</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              perPageValue = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//每页可以选择的显示行数选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          availableRowsPerPage: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">6</span>, <span class="number">12</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          columns: &lt;DataColumn&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"编号"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              numeric: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onSort: sort,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"姓名"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"年龄"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DataColumn(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              label: Text(<span class="string">"性别"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          source: tableSource,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataTableSource</span> <span class="keyword">extends</span> <span class="title">DataTableSource</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  MyDataTableSource(<span class="keyword">this</span>.stuList);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;UserInfo&gt; stuList;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> _selectRowCount = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DataRow getRow(<span class="built_in">int</span> index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(index &gt; stuList.length || index &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> UserInfo info = stuList[index];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> DataRow.byIndex(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      index: index,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      selected: info.isSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      onSelectChanged: (<span class="built_in">bool</span> selected)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        info.isSelected = selected;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _selectRowCount += selected ? <span class="number">1</span> : <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        notifyListeners();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      cells: &lt;DataCell&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DataCell(Text(<span class="string">"<span class="subst">$&#123;info.stuNum&#125;</span>"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DataCell(Text(<span class="string">"<span class="subst">$&#123;info.stuName&#125;</span>"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DataCell(Text(<span class="string">"<span class="subst">$&#123;info.stuAge&#125;</span>"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DataCell(Text(<span class="string">"<span class="subst">$&#123;info.stuSex&#125;</span>"</span>), onTap: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">print</span>(info.stuSex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//行数书否不确定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isRowCountApproximate =&gt; <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//总行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> rowCount =&gt; stuList.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//已经选择的行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> selectedRowCount =&gt; _selectRowCount;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> _sort(<span class="built_in">int</span> columnIndex, <span class="built_in">bool</span> ascending) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(ascending)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      stuList.sort((a, b)=&gt; a.stuNum.compareTo(b.stuNum));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      stuList.sort((a, b)=&gt; b.stuNum.compareTo(a.stuNum));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    notifyListeners();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//选择所有</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> _selectAll(<span class="built_in">bool</span> isSelected)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(UserInfo uInfo <span class="keyword">in</span> stuList) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      uInfo.isSelected = isSelected;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _selectRowCount = isSelected ? stuList.length : <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    notifyListeners();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  UserInfo(&#123;<span class="keyword">this</span>.stuNum, <span class="keyword">this</span>.stuName, <span class="keyword">this</span>.stuAge = <span class="number">0</span>, <span class="keyword">this</span>.stuSex, <span class="keyword">this</span>.isSelected = <span class="keyword">false</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> stuNum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> stuName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> stuAge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> stuSex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isSelected;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>显示效果如下：</p>
<img src="/content/c316e808/2020427709.gif" alt="2020427709" style="zoom:50%;">

<p>上述代码中，在自定义继承 <code>DataTableSource</code> 的类中使用了 <code>notifyListeners();</code> 方法。<code>notifyListeners();</code> 是 <code>DataTableSource</code> 的父类 <code>ChangeNotifier</code> 提供的方法，当数据更改时，调用此方法可以发送通知。</p>
<h4 id="九、Divider-Widget"><a href="#九、Divider-Widget" class="headerlink" title="九、Divider Widget"></a>九、Divider Widget</h4><p><code>Divider</code> 是一条细的水平线，两侧可设置填充宽度，继承自 <code>StatelessWidget</code> 。其可用于列表、抽屉和其他位置以分割内容。要在 <code>ListTile</code> 项之间创建分隔线，考虑使用针对该情况进行了优化的 <code>ListTile.divideTiles</code> 。 构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Divider(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，分割线的高度范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，分隔线内绘制的线的粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.thickness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，分割线前的空白空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.indent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，分隔线后缘的空白空间量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.endIndent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，分割线的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Divider(    <span class="comment">//Divider</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          thickness: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          indent: <span class="number">40</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          endIndent: <span class="number">40</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/2020427833.jpg" alt="2020427833" style="zoom:50%;">



<h4 id="十、DraggableScrollableSheet-Widget"><a href="#十、DraggableScrollableSheet-Widget" class="headerlink" title="十、DraggableScrollableSheet Widget"></a>十、DraggableScrollableSheet Widget</h4><p><code>DraggableScrollableSheet</code> 是一个可滚动的容器 Widget ，通过调整可滚动的大小直到达到限制，然后滚动来响应拖动手势，继承自 <code>StatefulWidget</code> 。此 Widget 最初显示为 <code>initialChildSize</code> 设置的比例，如果在 <code>builder</code> 中构建的 Widget 使用了提供的 <code>ScrollController</code> 滚动控制器，则其显示范围为 <code>minChildSize</code> 到 <code>maxChildSize</code> ，如果未使用 <code>ScrollController</code> ，则显示范围始终为 <code>initialChildSize</code> ，不可滚动。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DraggableScrollableSheet(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，显示窗口小部件时要使用的父容器高度的初始小数值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialChildSize = <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，显示的子Widget占用父级的最小百分比，其比例不能大于initialChildSize</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minChildSize = <span class="number">0.25</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，显示的子Widget占用父级的最大百分比</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxChildSize = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，小部件是否应该扩展以填充其父级中的可用空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.expand = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollableWidgetBuilder类型必传参数，该构建器创建一个要显示在此小部件中的子项，该子项将使用提供</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//的ScrollController启用内容的拖动和滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中，<code>builder</code> 是 <code>ScrollableWidgetBuilder</code> 类型，是一个返回值为 <code>Widget</code> 的方法，定义为：<code>Widget Function(BuildContext context, ScrollController scrollController);</code> 。</p>
<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: DraggableScrollableSheet(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          initialChildSize: <span class="number">0.8</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          minChildSize: <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxChildSize: <span class="number">0.8</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          builder: (BuildContext context, ScrollController scrollController) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: ListView.builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  controller: scrollController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                itemCount: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> ListTile(title: Text(<span class="string">'Item <span class="subst">$index</span>'</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/2020428104.gif" alt="2020428104" style="zoom:50%;">



<h4 id="十一、DraggableScrollableActuator-Widget"><a href="#十一、DraggableScrollableActuator-Widget" class="headerlink" title="十一、DraggableScrollableActuator Widget"></a>十一、DraggableScrollableActuator Widget</h4><p><code>DraggableScrollableActuator</code> 是一个可以通知其后代 <code>DraggableScrollableSheet</code> 将其位置重置为初始化状态的 Widget ，继承自 <code>StatelessWidget</code> 。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DraggableScrollableActuator(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，子Widget，应为DraggableScrollableSheet</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: DraggableScrollableActuator(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: DraggableScrollableSheet(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            initialChildSize: <span class="number">0.8</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            minChildSize: <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            maxChildSize: <span class="number">0.8</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            builder: (BuildContext context, ScrollController scrollController) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: ListView.builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    controller: scrollController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  itemCount: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      title: Text(<span class="string">'Item <span class="subst">$index</span>'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      onTap: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        DraggableScrollableActuator.reset(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              );</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c316e808/2020428118.gif" alt="2020428118" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>AboutListTile</tag>
        <tag>DataTable</tag>
        <tag>PaginatedDataTable</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十八)</title>
    <url>/content/dfc702ec.html</url>
    <content><![CDATA[<h4 id="一、ProgressIndicator-Widget"><a href="#一、ProgressIndicator-Widget" class="headerlink" title="一、ProgressIndicator Widget"></a>一、ProgressIndicator Widget</h4><p><code>ProgressIndicator</code> 是进度指示器的抽象基类，不能直接被实例化。构造方法如下：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ProgressIndicator(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，如果不为空，则此进度指示器的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，进度指示器的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Animation&lt;Color&gt;类型可选命名参数，使用动画值作为进度指示器的进度颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.valueColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticsLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticsValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>自身其有两个实现类，分别为：<code>LinearProgressIndicator</code> 、<code>CircularProgressIndicator</code> ，当然也可以自定义。</p>
<h5 id="1-LinearProgressIndicator-Widget"><a href="#1-LinearProgressIndicator-Widget" class="headerlink" title="1. LinearProgressIndicator Widget"></a>1. LinearProgressIndicator Widget</h5><p><code>LinearProgressIndicator</code> 是一个线性进度指示器 Widget ，也就是一个进度条。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LinearProgressIndicator(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，如果不为空，则此进度指示器的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，进度指示器的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Animation&lt;Color&gt;类型可选命名参数，进度指示器的颜色作为动画值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Animation&lt;Color&gt; valueColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> semanticsLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> semanticsValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>LinearProgressIndicator</code> 可以由两种表现形式。当 <code>value</code> 为 <code>null</code> 时，进度条是一个线性的循环模式，表示正在加载，但是不能确定已完成和未完成的比例。当 <code>value</code> 不为空时，可设置 0.0 到 1.0 之间的非空值，不能值表示不同的加载进度。</p>
<p><code>valueColor</code> 是 <code>Animation&lt;Color&gt;</code> 类型，是一个动画类，当不需要使用动画，将进度值设置为固定颜色时，可以使用 <code>AlwaysStoppedAnimation&lt;Color&gt;(color)</code> ，<code>AlwaysStoppedAnimation</code> 也是动画的一个实现类，表示一个固定的值。后续文章的动画部分会做详细讲解。</p>
<p><code>LinearProgressIndicator</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> currentValue = <span class="number">0.3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            height: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: LinearProgressIndicator(     <span class="comment">//LinearProgressIndicator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: currentValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              backgroundColor: Colors.grey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              valueColor: AlwaysStoppedAnimation(Colors.red),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下(左侧为 <code>value</code> 为 <code>null</code> 效果，右侧为非 <code>null</code> 效果)：</p>
<p><img src="/content/dfc702ec/2020411629.gif" alt="2020411629" style="zoom:50%;"><img src="/content/dfc702ec/2020411630.jpg" alt="2020411630" style="zoom:50%;"></p>
<h5 id="2-CircularProgressIndicator-Widget"><a href="#2-CircularProgressIndicator-Widget" class="headerlink" title="2. CircularProgressIndicator Widget"></a>2. CircularProgressIndicator Widget</h5><p><code>CircularProgressIndicator</code> 是循环进度指示器，是使用圆圈显示进度的 Widget 。使用方法与上述的线性进度指示器相同，其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CircularProgressIndicator(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，如果不为空，则此进度指示器的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，进度指示器的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Animation&lt;Color&gt;类型可选命名参数，使用动画值作为进度指示器的进度颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Animation&lt;Color&gt; valueColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，用于画圆的线的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.strokeWidth = <span class="number">4.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> semanticsLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> semanticsValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> currentValue = <span class="number">0.3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            height: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: CircularProgressIndicator(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: currentValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              strokeWidth: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              backgroundColor: Colors.grey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              valueColor: AlwaysStoppedAnimation(Colors.red),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/dfc702ec/2020411638.jpg" alt="2020411638" style="zoom:50%;">



<h4 id="二、RefreshIndicator-Widget"><a href="#二、RefreshIndicator-Widget" class="headerlink" title="二、RefreshIndicator Widget"></a>二、RefreshIndicator Widget</h4><p><code>RefreshIndicator</code> 是 Material 风格的滑动刷新 Widget ，效果是下拉刷新。当滑动距离超过设置的滑动距离后，一个动态循环指示器会淡入视图。当 <code>Scrollable</code> 没有足够的内容来进行滚动操作时，可将其 <code>physics</code> 属性设置为 <code>AlwaysScrollableScrollPhysics</code> 。使用 <code>AlwaysScrollableScrollPhysics</code> 将确保滚动视图始终可滚动，因此可以触发 <code>RefreshIndicator</code> 。<code>RefreshIndicator</code> 只能与垂直滚动视图一起使用。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RefreshIndicator(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，要显示的Widget，通常为ListView或CustomScrollView</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，从子Widget的顶部或底部边缘到刷新指示符所在位置的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在公开刷新指示器的拖动过程中，其实际位移可能会大大超过此值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.displacement = <span class="number">40.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//RefreshCallback类型必传参数，当用户将刷新指示器拖到足够远以表明他们希望应用刷新时调用的函数。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//刷新操作完成后，返回的Future必须完成</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onRefresh,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，进度指示器前景色。默认情况下，当前主题ThemeData.accent颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，进度指示器背景色。默认情况下，当前主题ThemeData.canvas颜色。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollNotificationPredicate类型可选命名参数，一个检查，指定此窗口小部件是否应</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//处理ScrollNotification</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.notificationPredicate = defaultScrollNotificationPredicate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticsLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticsValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>onRefresh</code> 是 <code>RefreshCallback</code> 类型，是一个返回值为 <code>Future&lt;void&gt;</code> 类型的方法，定义为：<code>Future&lt;void&gt; Function();</code> 。这个方法当用户拖动一个刷新指示器足够远以显示他们希望应用程序刷新时调用。</p>
<p>下拉刷新使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: RefreshIndicator(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: ListView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                scrollDirection: Axis.vertical,  </span></pre></td></tr><tr><td class="code"><pre><span class="line">                padding: EdgeInsets.all(<span class="number">10</span>),    </span></pre></td></tr><tr><td class="code"><pre><span class="line">                itemExtent: <span class="number">200</span>,        </span></pre></td></tr><tr><td class="code"><pre><span class="line">                children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    color: Colors.lightBlueAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 1"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 2"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 3"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onRefresh: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/dfc702ec/2020417533.gif" alt="2020417533" style="zoom:50%;">



<p>在实例开发中，下拉刷新经常与上拉加载更多一起使用。实现加载更多，可以通过使用 <code>ScrollController</code> 监听视图滚动来实现。<code>ScrollController</code> 在后续文章会详细说明。</p>
<p>实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ScrollController _scrollController;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _dataList = <span class="built_in">List</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> _pageIndex = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> _isLoadingFinished = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _getInitData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _scrollController = ScrollController()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ..addListener(()&#123;   <span class="comment">//添加监听</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(_scrollController.position.pixels == _scrollController.position.maxScrollExtent) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          _getMoreData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//初始化第一页数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Future _getInitData() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _pageIndex = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _dataList.removeRange(<span class="number">0</span>, _dataList.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>),()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _dataList = <span class="built_in">List</span>.generate(<span class="number">10</span>, (<span class="built_in">int</span> i)&#123;<span class="keyword">return</span> <span class="string">"获取的数据列表数据 <span class="subst">$i</span>"</span>;&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//获取更多数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Future _getMoreData() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(_isLoadingFinished) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _isLoadingFinished = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          _dataList.addAll(<span class="built_in">List</span>.generate(<span class="number">5</span>, (<span class="built_in">int</span> i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="string">"这是新的数据 <span class="subst">$i</span>"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">          _isLoadingFinished = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: RefreshIndicator(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: ListView.builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              controller: _scrollController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              scrollDirection: Axis.vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              padding: EdgeInsets.all(<span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              itemExtent: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              itemBuilder: _renderListRow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              itemCount: _dataList.length == <span class="number">0</span> ? _dataList.length : _dataList.length+<span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            onRefresh: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">return</span> _getInitData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//渲染加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget _renderListRow(BuildContext context, <span class="built_in">int</span> index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(index &lt; _dataList.length)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(_dataList[index] ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      child: Row(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"加载更多"</span>, style: TextStyle(fontSize: <span class="number">20</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">15</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            height: <span class="number">15</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            margin: EdgeInsets.only(left: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: CircularProgressIndicator(strokeWidth: <span class="number">2</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/dfc702ec/2020419330.gif" alt="2020419330" style="zoom:50%;">



<h4 id="三、RefreshProgressIndicator-Widget"><a href="#三、RefreshProgressIndicator-Widget" class="headerlink" title="三、RefreshProgressIndicator Widget"></a>三、RefreshProgressIndicator Widget</h4><p><code>RefreshProgressIndicator</code> 是用于显示刷新小部件内容的进度指示器，其继承自 <code>CircularProgressIndicator</code> 。通常用于与刷新相关的进度显示。其默认样式与 <code>RefreshIndicator</code> 下拉后显示的圆形指示器相同。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RefreshProgressIndicator(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，进度指示器的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Animation&lt;Color&gt;类型可选命名参数，使用动画值作为进度指示器的进度颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Animation&lt;Color&gt; valueColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，用于画圆的线的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> strokeWidth = <span class="number">2.0</span>, <span class="comment">// Different default than CircularProgressIndicator.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> semanticsLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此进度指示器的Semantics.value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> semanticsValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          width: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: RefreshProgressIndicator(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value: <span class="number">0.3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            strokeWidth: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            backgroundColor: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            valueColor: AlwaysStoppedAnimation&lt;Color&gt;(Colors.red),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/dfc702ec/20204171024.jpg" alt="20204171024" style="zoom:50%;">



<h4 id="四、ListWheelScrollView-Widget"><a href="#四、ListWheelScrollView-Widget" class="headerlink" title="四、ListWheelScrollView Widget"></a>四、ListWheelScrollView Widget</h4><p><code>ListWheelScrollView</code> 是一个可滚动的轮子式的 Widget ，子级的渲染就像在轮子上旋转而不是在平面上滚动一样。与 <code>ListView</code> 类似，但其所有子 Widget 在滚动轴上必须具有相同的大小。当列表的滚动偏移量为 0 时，第一个子 Widget 与视口中间对齐。 当列表位于最终滚动偏移处时，最后一个子 Widget 与视口的中间对齐。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个ListWheelScrollView，它的子级被传递给委托人，并在布局期间延迟构建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ListWheelScrollView(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，控制器，通常使用FixedExtentScrollController来控制当前项目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，圆柱体直径与主轴上视口大小之间的比率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.diameterRatio = RenderListWheelViewport.defaultDiameterRatio,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，圆柱投影的透视图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.perspective = RenderListWheelViewport.defaultPerspective,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，轮子水平偏离中心的程度，即为其宽度的一小部分。这一属性创造了一种视觉效果，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//从它的侧面看一个垂直的轮子，它的消失点在边缘曲线的一边，而不是正面看轮子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.offAxisFraction = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将放大镜用于轮子的中心项目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.useMagnifier = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果使用了放大镜，则放大率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.magnification = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，主轴上每个子项的大小。不能为null，并且必须为正</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.itemExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，轮子上子Widget的角度紧凑度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.squeeze = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;int&gt;类型可选命名参数，在中心项更改时调用的可选侦听器上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectedItemChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将绘制的子项剪辑到此视口的内部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipToSize = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否仅在视口内绘制子代.如果clipToSize也为true，则不能为true，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//因为视口外部的子代将被裁剪，因此无法在视口之外呈现子代。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.renderChildrenOutsideViewport = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型必传参数，子Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">List</span>&lt;Widget&gt; children,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个ListWheelScrollView，它的子级由一名代表管理，并且在布局过程中延迟构建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ListWheelScrollView.useDelegate(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，控制器，通常使用FixedExtentScrollController来控制当前项目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，圆柱体直径与主轴上视口大小之间的比率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.diameterRatio = RenderListWheelViewport.defaultDiameterRatio,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，圆柱投影的透视图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.perspective = RenderListWheelViewport.defaultPerspective,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，轮子水平偏离中心的程度，即为其宽度的一小部分。这一属性创造了一种视觉效果，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//从它的侧面看一个垂直的轮子，它的消失点在边缘曲线的一边，而不是正面看轮子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.offAxisFraction = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将放大镜用于轮子的中心项目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.useMagnifier = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果使用了放大镜，则放大率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.magnification = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，主轴上每个子项的大小。不能为null，并且必须为正</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.itemExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，轮子上子Widget的角度紧凑度，每个item的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.squeeze = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;int&gt;类型可选命名参数，在中心项更改时调用的可选侦听器上，是一个回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectedItemChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将绘制的子项剪辑到此视口的内部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipToSize = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否仅在视口内绘制子代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.renderChildrenOutsideViewport = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ListWheelChildDelegate类型必传参数，惰性代理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.childDelegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中 <code>onSelectedItemChanged</code> 是 <code>ValueChanged&lt;int&gt;</code> 类型，是一个无返回值的方法，定义为：<code>void Function(T value);</code> </p>
<p><code>childDelegate</code> 是 <code>ListWheelChildDelegate</code> 类型，为 <code>ListWheelScrollView</code> 提供子级的委托。 <code>ListWheelScrollView</code> 在布局期间懒惰地构造其子级，以避免创建比通过视口可见的子级更多的子级。该委托负责在此阶段为 <code>ListWheelScrollView</code> 提供子级。<code>ListWheelChildDelegate</code> 是一个抽象类，提供了两个子类可以使用：<code>ListWheelChildBuilderDelegate</code> 和 <code>ListWheelChildLoopingListDelegate</code> 。</p>
<p><code>ListWheelChildBuilderDelegate</code> 使用构建器回调为 <code>ListWheelScrollView</code> 提供子级的委托。其惰性地构造其子级，以避免创建的子级超过通过视口可见的子级。 该委托使用 <code>IndexedWidgetBuilder</code> 回调提供子项，因此不必在显示子项之前对其进行构建。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListWheelChildBuilderDelegate(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IndexedWidgetBuilder类型必传参数，惰性创建子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，如果非null，则childCount是可提供的最大子代数，并且子代的可用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//范围是0到childCount-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.childCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>builder</code> 是 <code>IndexedWidgetBuilder</code> 类型，是一个返回值为 <code>Widget</code> 的方法，定义为：<code>Widget Function(BuildContext context, int index);</code> 。</p>
<p><code>ListWheelChildLoopingListDelegate</code> 是通过循环显示列表的 <code>ListWheelScrollView</code> 委托。此类适用于子项列表已知的情况。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListWheelChildLoopingListDelegate(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型必传参数，该列表包含可以提供的所有子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.children</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<p><code>ListWheelScrollView</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: ListWheelScrollView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            itemExtent: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            onSelectedItemChanged: (<span class="built_in">int</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 1"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 2"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 3"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 4"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/dfc702ec/20204181111.gif" alt="20204181111" style="zoom:50%;">



<p><code>ListWheelScrollView.useDelegate</code> 使用 <code>ListWheelChildBuilderDelegate</code> 如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> _itemList = [<span class="string">"Text 1"</span>, <span class="string">"Text2"</span>, <span class="string">"Text3"</span>, <span class="string">"Text4"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ListWheelScrollView.useDelegate (</span></pre></td></tr><tr><td class="code"><pre><span class="line">          itemExtent: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onSelectedItemChanged: (<span class="built_in">int</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          childDelegate: ListWheelChildBuilderDelegate(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            builder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  child: Center(child: Text(<span class="string">"<span class="subst">$&#123;_itemList[index]&#125;</span>"</span>, style: TextStyle(fontSize: <span class="number">30</span>),)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              );</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            childCount: _itemList.length,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/dfc702ec/20204181251.gif" alt="20204181251" style="zoom:50%;">



<p><code>ListWheelScrollView.useDelegate</code> 使用 <code>ListWheelChildBuilderDelegate</code> 如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ListWheelScrollView.useDelegate (</span></pre></td></tr><tr><td class="code"><pre><span class="line">          itemExtent: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onSelectedItemChanged: (<span class="built_in">int</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          childDelegate: ListWheelChildLoopingListDelegate(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Center(child: Text(<span class="string">"Text1"</span>, style: TextStyle(fontSize: <span class="number">30</span>),)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Center(child: Text(<span class="string">"Text2"</span>, style: TextStyle(fontSize: <span class="number">30</span>),)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/dfc702ec/20204181256.gif" alt="20204181256" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>ProgressIndicator</tag>
        <tag>RefreshIndicator</tag>
        <tag>ListWheelScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十七)</title>
    <url>/content/1695bde0.html</url>
    <content><![CDATA[<h4 id="一、FormField-Widget"><a href="#一、FormField-Widget" class="headerlink" title="一、FormField Widget"></a>一、FormField Widget</h4><p><code>FormField</code> 是单个表单 Widget ，用于维护表单字段的当前状态，以便在 UI 中直观的反应更新和验证错误。主要就是为内部的 Widget 提供保存、重置、验证事件处理。</p>
<p>在 <code>Form</code> 内部使用时，可以使用 <code>FormState</code> 上的方法来整体查询或操作表单数据。 例如，调用 <code>FormState.save</code> 将依次调用每个 <code>FormField</code> 的 <code>onSaved</code> 回调。</p>
<a id="more"></a>

<p>如果要检索其当前状态（例如，如果您希望一个表单域依赖于另一个表单域），请将 <code>GlobalKey</code> 与 <code>FormField</code> 一起使用。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FormField(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FormFieldBuilder&lt;T&gt;类型必传参数，返回代表此表单字段的小部件的函数。它以表单字段状态作为输入传递，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//其中包含该字段的当前值和验证状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FormFieldSetter&lt;T&gt;类型可选命名参数，通过FormState.save保存表单时，使用最终值调用的可选方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSaved,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FormFieldValidator&lt;T&gt;类型可选命名参数，验证输入的可选方法。如果输入无效，则返回要显示的错误字符串，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//否则返回null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.validator,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//T泛型可选命名参数，用于将表单字段初始化为，否则为null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则此表单字段将在每次更改后立即验证并更新其错误文本。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//否则，您必须调用FormFieldState.validate进行验证。如果表单的一部分可以自动验证，则将忽略此值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autovalidate = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，表单是否能够接收用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>builder</code> 是 <code>FormFieldBuilder&lt;T&gt;</code> 类型，是一个返回 Widget 的方法，原型为：<code>Widget Function(FormFieldState&lt;T&gt; field)</code> 。该方法有一个 <code>FormFieldState&lt;T&gt;</code> 类型的参数，为 <code>FormField</code> 的当前状态，可以用来获取表单的当前值和错误信息。当前 <code>FormFieldState&lt;T&gt;</code> 的实例只能在 <code>builder</code> 内部访问。如果需要在其他地方访问，需要使用 <code>GlobalKey</code> 作为 <code>FormField</code> 的 <code>key</code> 参数，然后使用 <code>currentState</code> 属性进行状态访问。 </p>
<p>理论上 <code>builder</code> 构建的 Widget 可以是任意的 Widget ，也确实可以这么做。但是对于像 <code>Text</code> 、<code>Image</code> 等这样的非用户输入 Widget ，使用 <code>builder</code> 来构建意义不是很大。因为其 ``FormFieldState<T><code>参数是用来获取状态的，其可以进行内容的重置、保存等操作，所以一般</code>builder` 应该与可与用户交互的输入性 Widget 一起使用。</T></p>
<p><code>GlobalKey</code> 用于定义全局唯一的键，全局键唯一标识元素。全局键提供了对与这些元素相关联的其他对象的访问，如构建上下文。对于状态窗口小部件，全局键还提供对状态的访问。当具有全局键的小部件从树中的一个位置移动到树中的另一个位置时，它们的子树将成为其父树。为了重设其子树，小部件必须在与从树中的旧位置删除的同一动画帧中到达树中的新位置。全局键相对昂贵。如果不需要上面列出的任何功能，请考虑改用 <code>Key</code> ，<code>ValueKey</code> ，<code>ObjectKey</code> 或 <code>UniqueKey</code> 。</p>
<p><code>onSaved</code> 是 <code>FormFieldSetter&lt;T&gt;</code> 类型，是一个无返回值的方法，原型为：<code>void Function(T newValue)</code> 。</p>
<p><code>validator</code> 是 <code>FormFieldValidator&lt;T&gt;</code> 类型，是一个返回值为 <code>String</code> 类型的方法，其原型为：<code>String Function(T value)</code> 。用来在验证失败的情况下返回错误信息。</p>
<p>使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> GlobalKey&lt;FormFieldState&gt; _formFieldKey = GlobalKey();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.only(left: <span class="number">50</span>, top: <span class="number">20</span>, right: <span class="number">50</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            FormField&lt;<span class="built_in">String</span>&gt;(       		<span class="comment">//FormField</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              key:  _formFieldKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              builder: (FormFieldState&lt;<span class="built_in">String</span>&gt; state) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> TextField(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  decoration: InputDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    errorText: state.errorText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  onChanged: (<span class="built_in">String</span> newValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    state.didChange(newValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onSaved: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(value.length &lt;= <span class="number">10</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(<span class="string">"保存数据:<span class="subst">$value</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              validator: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(value.length &gt; <span class="number">10</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> <span class="string">"输入字符不能超过10个"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              initialValue: <span class="string">""</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              autovalidate: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SizedBox(height: <span class="number">30</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"验证"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _formFieldKey.currentState.save();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _formFieldKey.currentState.validate();</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1695bde0/2020441013.jpg" alt="2020441013" style="zoom:50%;">



<h4 id="二、TextFormField-Widget"><a href="#二、TextFormField-Widget" class="headerlink" title="二、TextFormField Widget"></a>二、TextFormField Widget</h4><p><code>TextFormField</code> 是 <code>FormField</code> 的子类，是单个表单文本 Widget 。它是一个 <code>FormFiled</code> 包含了一个 <code>TextField</code> ，也就是本文上述内容和前一篇文章介绍内容的组合形式。它提供了非常方便的功能将 <code>FormField</code> 和 <code>TextField</code> 组合使用，免去开发者手动组合二者的繁杂过程。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextFormField(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextEditingController类型可选命名参数，控制正在编辑的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于设置初始值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> initialValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，定义此小部件的键盘焦点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  FocusNode focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputDecoration类型可选命名参数，在文本字段周围显示的装饰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  InputDecoration decoration = <span class="keyword">const</span> InputDecoration(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextInputType类型可选命名参数，用于编辑文本的键盘类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextInputType keyboardType,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextCapitalization类型可选命名参数，配置平台键盘如何选择大写或小写键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextCapitalization textCapitalization = TextCapitalization.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextInputAction类型可选命名参数，键盘使用的操作按钮的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextInputAction textInputAction,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于正在编辑的文本的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextStyle style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//StrutStyle类型可选命名参数，用于垂直布局的支杆样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  StrutStyle strutStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，设置文字的方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextDirection textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextAlign类型可选命名参数，文本应如何水平对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextAlign textAlign = TextAlign.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextAlignVertical类型可选命名参数，设置文本垂直对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextAlignVertical textAlignVertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果没有其他焦点，则此文本字段是否应该焦点自己</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，文本是否可以更改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> readOnly = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ToolbarOptions类型可选命名参数，工具栏选项的配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ToolbarOptions toolbarOptions,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示光标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> showCursor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否隐藏正在编辑的文本（例如，用于密码)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> obscureText = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否启用自动校正</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> autocorrect = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在用户键入时显示输入建议</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> enableSuggestions = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则此表单字段将在每次更改后立即验证并更新其错误文本。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//否则，您必须调用FormFieldState.validate进行验证。如果表单的一部分可以自动验证，则将忽略此值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> autovalidate = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则阻止字段允许超过maxLength个字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> maxLengthEnforced = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，文本可跨越的最大行数，必要时可换行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> maxLines = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，当内容跨越更少的行时要占用的最小行数。同时设置maxLines时，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//高度将在指定的线范围之间增长。当maxLines为null时，它将从minLines开始根据需要增长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> minLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此小部件的高度是否将调整大小以填充其父级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> expands = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，文本字段中允许的最大字符数（Unicode标量值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> maxLength,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;String&gt;类型可选命名参数，当用户发起对TextField值的更改时调用：当他们插入或删除文本时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ValueChanged&lt;<span class="built_in">String</span>&gt; onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//GestureTapCallback类型可选命名参数，要无条件处理轻敲，而又不干扰文本字段的内部手势检测器，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//请提供此回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  GestureTapCallback onTap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，当用户提交可编辑内容时调用(例如，用户按键盘上的“完成”按钮)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  VoidCallback onEditingComplete,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;String&gt;类型可选命名参数，当用户指示他们已完成字段中文本的编辑时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ValueChanged&lt;<span class="built_in">String</span>&gt; onFieldSubmitted,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FormFieldSetter&lt;T&gt;类型可选命名参数，通过FormState.save保存表单时，使用最终值调用的可选方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  FormFieldSetter&lt;<span class="built_in">String</span>&gt; onSaved,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FormFieldValidator&lt;T&gt;类型可选命名参数，验证输入的可选方法。如果输入无效，则返回要显示的错误字符串，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//否则返回null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  FormFieldValidator&lt;<span class="built_in">String</span>&gt; validator,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;TextInputFormatter&gt;类型可选命名参数，可选的输入验证和格式替代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;TextInputFormatter&gt; inputFormatters,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为false，则文本字段“禁用”，它忽略点击，其装饰呈现为灰色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> enabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，光标的粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> cursorWidth = <span class="number">2.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，游标的角应多圆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Radius cursorRadius,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，绘制光标时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color cursorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，键盘外观</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Brightness keyboardAppearance,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsets类型可选命名参数，当文本字段滚动到视图中时，将填充配置为围绕可滚动对象的边缘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  EdgeInsets scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则长按此TextField将选择文本并显示剪切/复制/粘贴菜单，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//而点击将移动文本插入符号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> enableInteractiveSelection = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputCounterWidgetBuilder类型可选命名参数，生成自定义InputDecorator.counter小部件的回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  InputCounterWidgetBuilder buildCounter,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>上面的所有属性都在本文和上一篇文章介绍过，这里不多做说明，使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextEditingController _controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> GlobalKey&lt;FormFieldState&gt; _formFieldKey = GlobalKey();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.only(left: <span class="number">50</span>, top: <span class="number">20</span>, right: <span class="number">50</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TextFormField(					<span class="comment">//TextFormField</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              key: _formFieldKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              decoration: InputDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                icon: Icon(Icons.person),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onSaved: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              validator: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(value == <span class="keyword">null</span> || value.isEmpty) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> <span class="string">"请输入用户名"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> value.contains(<span class="string">"@"</span>) ?  <span class="keyword">null</span>: <span class="string">"用户名不合法，必须包含@"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SizedBox(height: <span class="number">30</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"验证"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _formFieldKey.currentState.save();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _formFieldKey.currentState.validate();</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1695bde0/2020451242.jpg" alt="2020451242" style="zoom:50%;">



<h4 id="三、Form-Widget"><a href="#三、Form-Widget" class="headerlink" title="三、Form Widget"></a>三、Form Widget</h4><p><code>Form</code> 是用于将多个表单 Widget (如：<code>TextField</code> )组合在一起的容器。</p>
<p>每个单独的表单字段都应包装在 <code>FormField</code> 小部件中，并且 <code>Form</code> 小部件应作为所有这些的共同祖先。 在 <code>FormState</code> 上调用方法以保存，重置或验证作为此 <code>Form</code> 的后代的每个 <code>FormField</code> 。 若要获取 <code>FormState</code> ，可以将 <code>Form.of</code> 与祖先是 <code>Form</code> 的上下文一起使用，或将 <code>GlobalKey</code> 传递给 <code>Form</code> 构造函数并调用 <code>GlobalKey.currentState</code> 。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Form(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，要使用的子级Widget，可以使用 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则每次更改后，表单字段都会立即验证并更新其错误文本。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//否则，必须调用FormState.validate进行验证</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autovalidate = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//WillPopCallback类型可选命名参数，使表单能够否决用户尝试关闭包含该表单的ModalRoute的尝试</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onWillPop,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，表单字段之一更改时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>onWillPop</code> 是 <code>WillPopCallback</code> 类型，其为一个返回值为 <code>Future&lt;bool&gt;</code> 的方法，原型为：<code>Future&lt;bool&gt; Function()</code> 。如果回调返回一个解析为 <code>false</code> 的 <code>Future</code> ，则不会弹出表单的路由。</p>
<p><code>onChanged</code> 是 <code>VoidCallback</code> 类型，是一个无返回值的方法，原型为：<code>void Function()</code> 。</p>
<p><code>FormState</code> 是与 <code>Form</code> 关联的状态类。<code>FormState</code> 对象可用于保存，重置和验证作为关联 <code>Form</code> 的后代的每个 <code>FormField</code> 。可以通过 <code>Form.of</code> 获取。</p>
<p><code>Form</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> GlobalKey&lt;FormState&gt; _formKey = GlobalKey();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextEditingController _aController;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextEditingController _pController;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _aController = TextEditingController();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _pController = TextEditingController();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.all(<span class="number">40</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Form(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          key: _formKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              TextFormField(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                controller: _aController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                decoration: InputDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  icon: Icon(Icons.person),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onSaved: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                validator: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">if</span>(value == <span class="keyword">null</span> || value.isEmpty) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="string">"请输入用户名"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> value.contains(<span class="string">"@"</span>) ?  <span class="keyword">null</span>: <span class="string">"用户名不合法，必须包含@"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              SizedBox(height: <span class="number">30</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              TextFormField(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                controller: _pController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                obscureText: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                decoration: InputDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  icon: Icon(Icons.vpn_key),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onSaved: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                validator: (<span class="built_in">String</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">if</span>(value == <span class="keyword">null</span> || value.isEmpty) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="string">"请输入密码"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value.length &lt; <span class="number">5</span> || value.length &gt; <span class="number">10</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="string">"密码长度错误"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              SizedBox(height: <span class="number">30</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Row(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: Text(<span class="string">"重置"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      _formKey.currentState.reset();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  SizedBox(width: <span class="number">20</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: Text(<span class="string">"登录"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      <span class="keyword">if</span>(_formKey.currentState.validate())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="built_in">print</span>(<span class="string">"登录操作。 <span class="subst">$&#123;_aController.text&#125;</span>  <span class="subst">$&#123;_pController.text&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1695bde0/202045145.jpg" alt="202045145" style="zoom:50%;">



<h4 id="四、DropdownButtonFormField-Widget"><a href="#四、DropdownButtonFormField-Widget" class="headerlink" title="四、DropdownButtonFormField Widget"></a>四、DropdownButtonFormField Widget</h4><p><code>DropdownButtonFormField</code> 是将 <code>DropdownButton</code> 包装在 <code>FormField</code> 中的 Widget 。关于 <code>DropdownButton</code> 在前文介绍过，地址为：<a href="http://www.mwpush.com/content/aa8d162.html">http://www.mwpush.com/content/aa8d162.html</a> 。</p>
<p><code>DropdownButtonFormField</code> 构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DropdownButtonFormField(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//T泛型类型，用于设置初始值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  T value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;DropdownMenuItem&lt;T&gt;&gt;类型必传参数，设置的菜单项列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">List</span>&lt;DropdownMenuItem&lt;T&gt;&gt; items,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DropdownButtonBuilder类型可选命名参数，用于定制与项目中的下拉菜单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//项(DropdownMenuItem)相对应的按钮</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DropdownButtonBuilder selectedItemBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，下拉按钮显示的占位符Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget hint,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;T&gt;类型必传参数，选择一个菜单项时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputDecoration类型可选命名参数，在文本字段周围显示的装饰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FormFieldSetter&lt;T&gt;类型可选命名参数，通过FormState.save保存表单时，使用最终值调用的可选方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  FormFieldSetter&lt;T&gt; onSaved,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FormFieldValidator&lt;T&gt;类型可选命名参数，验证输入的可选方法。如果输入无效，则返回要显示的错误字符串，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//否则返回null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  FormFieldValidator&lt;T&gt; validator,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则此表单字段将在每次更改后立即验证并更新其错误文本。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//否则，您必须调用FormFieldState.validate进行验证。如果表单的一部分可以自动验证，则将忽略此值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> autovalidate = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，当下拉菜单被禁用时显示的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget disabledHint,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，打开时放置菜单的z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> elevation = <span class="number">8</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于设置下拉菜单中文本的文本的样式，以及点击按钮时出现的下拉菜单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextStyle style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，下拉按钮图标的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮禁用状态的内部图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color iconDisabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮启用状态的内部图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color iconEnabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，下拉按钮的向下箭头图标按钮的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> iconSize = <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否降低按钮的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isDense = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将下拉列表的内部内容设置为水平填充其父项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isExpanded = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，如果为null，则菜单项高度将根据每个菜单项的固有高度而变化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> itemHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> GlobalKey&lt;FormState&gt; _formKey = GlobalKey();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> currentSelectedIndex = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.all(<span class="number">40</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Form(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          key: _formKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              DropdownButtonFormField(       <span class="comment">//DropdownButtonFormField</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                items: &lt;DropdownMenuItem&lt;<span class="built_in">int</span>&gt;&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: Text(<span class="string">"Item 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    value: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: Text(<span class="string">"Item 2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    value: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: Text(<span class="string">"Item 3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    value: <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">                value: currentSelectedIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onChanged: (value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    currentSelectedIndex = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                validator: (<span class="built_in">int</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="string">"error"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value != <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> <span class="string">"选择错误"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              SizedBox(height: <span class="number">20</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"验证"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  _formKey.currentState.validate();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1695bde0/202045305.jpg" alt="202045305" style="zoom:50%;">



<h4 id="五、EditableText-Widget"><a href="#五、EditableText-Widget" class="headerlink" title="五、EditableText Widget"></a>五、EditableText Widget</h4><p><code>EditableText</code> 是基础文本输入 Widget 。它与 <code>TextInput</code> 服务交互，以使用户编辑其包含的文本。它还提供滚动，选择和光标移动。此小部件不提供任何焦点管理(例如，点击聚焦)。它是输入 Widget 的基础组件，<code>TextField</code> 是对 <code>EditableText</code> 的包装。如果有输入需要，应选择使用 <code>TextField</code> 。</p>
<p>当 <code>rendererIgnoresPointer</code> 为 <code>false</code> (默认情况下为 <code>false</code> )时，此小部件为用户操作提供基本的，与平台无关的手势处理，例如轻击，长按和滚动。 要在文本字段中针对输入手势严格遵循平台行为，请使用 <code>TextField</code> 或 <code>CupertinoTextField</code> 。 对于自定义选择行为，以编程方式调用诸如 <code>RenderEditable.selectPosition</code> ， <code>RenderEditable.selectWord</code> 等方法。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">EditableText(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextEditingController类型必传参数，控制正在编辑的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型必传参数，定义此小部件的键盘焦点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，文字是否可以更改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.readOnly = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否隐藏正在编辑的文本（例如，用于密码）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否启用自动校正</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在用户输入时显示输入建议</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enableSuggestions = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型必传参数，用于可编辑文本的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//StrutStyle类型可选命名参数，用于垂直布局的支杆样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  StrutStyle strutStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型必传参数，绘制光标时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.cursorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型必传参数，渲染浮动光标时，绘制与文本对齐的背景光标时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.backgroundCursorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextAlign类型可选命名参数，文本应如何水平对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textAlign = TextAlign.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，文字的方向性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Locale类型可选命名参数，当可以根据区域设置以不同方式呈现相同的Unicode字符时，用于选择字体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.locale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个逻辑像素的字体像素数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textScaleFactor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，文本可跨越的最大行数，必要时可换行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxLines = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，当内容跨越更少的行时要占用的最小行数。同时设置maxLines时，高度将在指定的线范</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//围之间增长。当maxLines为null时，它将从minLines开始根据需要增长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此小部件的高度是否将调整大小以填充其父级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.expands = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，无论文本宽度如何，文本是否都将采用全宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.forceLine = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextWidthBasis类型可选命名参数，测量一行或多行文本宽度的不同方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textWidthBasis = TextWidthBasis.parent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果没有其他焦点，则此文本字段是否应该焦点自己</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示光标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> showCursor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示选择手柄</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showSelectionHandles = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，绘制选区时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectionColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextSelectionControls类型可选命名参数，用于构建文本选择手柄和工具栏的可选委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectionControls,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextInputType类型可选命名参数，用于编辑文本的键盘类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextInputType keyboardType,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextInputAction类型可选命名参数，与软键盘一起使用的操作按钮的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textInputAction,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextCapitalization类型可选命名参数，配置平台键盘如何选择大写或小写键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textCapitalization = TextCapitalization.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;String&gt;类型可选命名参数，当用户发起对TextField值的更改时调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，当用户提交可编辑的内容时调用（例如，用户按下键盘上的“完成”按钮）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onEditingComplete,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;String&gt;类型可选命名参数，当用户指示他们已完成字段中文本的编辑时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSubmitted,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SelectionChangedCallback类型可选命名参数，当用户更改文本选择（包括光标位置）时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectionChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，点击选择句柄时调用的回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelectionHandleTapped,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;TextInputFormatter&gt;类型可选命名参数，可选的输入验证和格式替代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;TextInputFormatter&gt; inputFormatters,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则此小部件创建的RenderEditable将不会处理指针事件，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//请参见renderEditable和RenderEditable.ignorePointer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.rendererIgnoresPointer = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，光标的粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，游标的角应多圆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cursorRadius,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，在每个光标闪烁期间，光标是否将从完全透明变为完全不透明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cursorOpacityAnimates = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型可选命名参数，在屏幕上绘制光标时使用的偏移量（以像素为单位）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cursorOffset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是将光标绘制在文本的上方还是下方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.paintCursorAboveText = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsets类型可选命名参数，当Textfield滚动到视图中时，将填充配置为围绕Scrollable的边缘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，键盘外观</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.keyboardAppearance = Brightness.light,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则长按此TextField将选择文本并显示剪切/复制/粘贴菜单，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//而点击将移动文本插入符号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enableInteractiveSelection = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，垂直滚动输入时使用的ScrollController</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，垂直滚动输入时使用的ScrollPhysics</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollPhysics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ToolbarOptions类型可选命名参数，工具栏选项的配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.toolbarOptions = <span class="keyword">const</span> ToolbarOptions(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    copy: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cut: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    paste: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    selectAll: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>基本使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextEditingController _controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _controller = TextEditingController();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> dispose() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _controller.dispose();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.dispose();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: EditableText(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          controller: _controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          focusNode: FocusNode(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          cursorColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundCursorColor: Colors.lightBlue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          style: TextStyle(fontSize: <span class="number">20</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          textScaleFactor: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          expands: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxLines: <span class="keyword">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          minLines: <span class="keyword">null</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          selectionColor: Colors.orange,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>FormField</tag>
        <tag>TextFormField</tag>
        <tag>Form</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十六)</title>
    <url>/content/899da56a.html</url>
    <content><![CDATA[<h4 id="一、TextField-Widget"><a href="#一、TextField-Widget" class="headerlink" title="一、TextField Widget"></a>一、TextField Widget</h4><p><code>TextField</code>  是一个可以输入文本的 Widget 。每当用户更改字段中的文本时，文本字段就会调用 <code>onChanged</code> 回调。 如果用户指示已完成在该字段中的键入(例如，通过按软键盘上的按钮)，则文本字段将调用 <code>onSubmitted</code> 回调。</p>
<a id="more"></a>

<p>要控制在文本字段中显示的文本，请使用控制器。 例如，要设置文本字段的初始值，请使用已经包含一些文本的控制器。 控制器还可以控制选择和组成区域（并观察文本，选择和组成区域的变化）。</p>
<p>要将 <code>TextField</code> 与其他 <code>FormField</code> 小部件集成到 <code>Form</code> 中，请考虑使用 <code>TextFormField</code> 。</p>
<p>当不再需要 <code>TextEditingController</code> 时，请进行处理。 这将确保我们丢弃该对象使用的所有资源。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextField(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextEditingController类型可选命名参数，控制正在编辑的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，定义此小部件的键盘焦点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputDecoration类型可选命名参数，在文本字段周围显示的装饰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextInputType类型可选命名参数，用于编辑文本的键盘类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextInputType keyboardType,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextInputAction类型可选命名参数，键盘使用的操作按钮的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textInputAction,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextCapitalization类型可选命名参数，配置平台键盘如何选择大写或小写键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textCapitalization = TextCapitalization.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于正在编辑的文本的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//StrutStyle类型可选命名参数，用于垂直布局的支杆样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.strutStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextAlign类型可选命名参数，文本应如何水平对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textAlign = TextAlign.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextAlignVertical类型可选命名参数，设置文本垂直对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textAlignVertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，设置文字的方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，文本是否可以更改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.readOnly = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ToolbarOptions类型可选命名参数，工具栏选项的配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ToolbarOptions toolbarOptions,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示光标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showCursor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果没有其他焦点，则此文本字段是否应该焦点自己</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否隐藏正在编辑的文本（例如，用于密码）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否启用自动校正</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在用户键入时显示输入建议</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enableSuggestions = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，文本可跨越的最大行数，必要时可换行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxLines = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，当内容跨越更少的行时要占用的最小行数。同时设置maxLines时，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//高度将在指定的线范围之间增长。当maxLines为null时，它将从minLines开始根据需要增长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此小部件的高度是否将调整大小以填充其父级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.expands = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，文本字段中允许的最大字符数（Unicode标量值）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxLength,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则阻止字段允许超过maxLength个字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxLengthEnforced = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;String&gt;类型可选命名参数，当用户发起对TextField值的更改时调用：当他们插入或删除文本时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，当用户提交可编辑内容时调用(例如，用户按键盘上的“完成”按钮)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onEditingComplete,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;String&gt;类型可选命名参数，当用户指示他们已完成字段中文本的编辑时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSubmitted,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;TextInputFormatter&gt;类型可选命名参数，可选的输入验证和格式替代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inputFormatters,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为false，则文本字段“禁用”，它忽略点击，其装饰呈现为灰色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enabled,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，光标的粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，游标的角应多圆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cursorRadius,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，绘制光标时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cursorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，键盘外观</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.keyboardAppearance,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsets类型可选命名参数，当文本字段滚动到视图中时，将填充配置为围绕可滚动对象的边缘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则长按此TextField将选择文本并显示剪切/复制/粘贴菜单，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//而点击将移动文本插入符号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enableInteractiveSelection = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//GestureTapCallback类型可选命名参数，要无条件处理轻敲，而又不干扰文本字段的内部手势检测器，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//请提供此回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onTap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputCounterWidgetBuilder类型可选命名参数，生成自定义InputDecorator.counter小部件的回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.buildCounter,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，垂直滚动输入时要使用的ScrollController控制器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollPhysics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>TextEditingController</code> 是文本编辑控制器。每当用户使用关联的 <code>TextEditingController</code> 修改文本字段时，该文本字段都会更新值，并且控制器会通知其侦听器。然后，侦听器可以读取文本和选择属性，以了解用户键入了什么或如何更新了选择。</p>
<p>同样，如果您修改文本或选择属性，则将通知文本字段并适当更新自身。</p>
<p><code>TextEditingController</code> 也可以用于为文本字段提供初始值。 如果使用已经具有文本的控制器来构建文本字段，则该文本字段将使用该文本作为其初始值。</p>
<p>可以从添加到此控制器的侦听器中设置文本或选择属性。 如果两个属性都需要更改，则应该设置控制器的值。</p>
<p>请记住，当不再需要 <code>TextEditingController</code> 时，在 <code>dispose</code> 内调用其 <code>dispose()</code>。 这将确保我们丢弃该对象使用的所有资源。</p>
<p><code>InputDecoration</code> 用于设置 <code>TextField</code> 的边框、标签、图标和样式。<code>TextField</code> 和 <code>InputDecorator</code> 类使用 <code>InputDecoration</code> 对象来描述其装饰。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建用于装饰文本字段的边框，标签，图标和样式的束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InputDecoration(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，显示在输入字段之前和装饰容器外部的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，描述输入字段的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，标签在输入字段上方（即垂直相邻）时用于labelText的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，提供有关输入子项值的上下文的文本，例如如何使用该值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.helperText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于helperText的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.helperStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，helperText可以占用的最大行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.helperMaxLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，建议字段接受哪种输入的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hintText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，hintText的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hintStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，hintText可以占用的最大行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hintMaxLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，显示在输入子项和边框下方的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.errorText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于errorText的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.errorStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，errorText可以占用的最大行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.errorMaxLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，labelText是否浮动在焦点上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hasFloatingPlaceholder = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，输入子项是否为密集形式的一部分（即使用较少的垂直空间）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isDense,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，输入装饰的容器的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.contentPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在装饰容器中，出现在prefix或prefixText之前以及文本字段的可编辑部分之前的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.prefixIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，用于放置在输入之前的行上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.prefix,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，文本前缀，用于放置在输入之前的行上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.prefixText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于prefixText的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.prefixStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，装饰容器中的文本字段的可编辑部分之后，后缀或suffixText之后出现的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.suffixIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，用于放置在输入之后的行上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.suffix,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，输入后在行上放置的可选文本后缀</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.suffixText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于suffixText的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.suffixStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，自定义计数器窗口小部件，以放置在否则被counterText占用的位置。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//如果此属性为非null，则将忽略counterText</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.counter,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//String类型可选命名参数，文本放置在该行下方作为字符计数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.counterText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，counterText使用的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.counterStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则装饰的容器将填充fillColor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.filled,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，装饰的容器颜色的基础填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fillColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，与fillColor混合的颜色，并用该颜色填充装饰的容器，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//如果filled为true并且容器具有输入焦点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，如果用鼠标悬停了容器，则显示的装饰的焦点突出显示的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputBorder类型可选命名参数，InputDecorator没有焦点并显示错误时显示的边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.errorBorder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputBorder类型可选命名参数，InputDecorator具有焦点且未显示错误时显示的边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusedBorder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputBorder类型可选命名参数，InputDecorator具有焦点并显示错误时显示的边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusedErrorBorder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputBorder类型可选命名参数，禁用InputDecorator且未显示错误时显示的边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledBorder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputBorder类型可选命名参数，启用InputDecorator时显示的边框，但未显示错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enabledBorder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputBorder类型可选命名参数，在装饰容器周围绘制的边框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.border,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果未显示错误的helperText，errorText和counterText，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则减少了其余可视元素的不透明度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，counterText的语义标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticCounterText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，通常在InputDecorator包含多行TextField（TextField.maxLines为null或&gt; 1）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//时设置为true，以覆盖将标签与TextField的中心对齐的默认行为</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignLabelWithHint,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个与输入字段大小相同的输入编辑器  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InputDecoration.collapsed(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型必传参数，建议字段接受哪种输入的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.hintText,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，标签是否浮动在焦点上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hasFloatingPlaceholder = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，hintText的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hintStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，则装饰的容器将填充fillColor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.filled = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，装饰的容器颜色的基础填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fillColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，与fillColor混合的颜色，并用该颜色填充装饰的容器，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//如果filled为true并且容器具有输入焦点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，如果用鼠标悬停了容器，则显示的装饰的焦点突出显示的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputBorder类型可选命名参数，在装饰容器周围绘制的边框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.border = InputBorder.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果未显示错误的helperText，errorText和counterText，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则减少了其余可视元素的不透明度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中 <code>InputBorder</code> 用于定义输入编辑器边框的外观，是一个抽象基类，可以使用其子类 <code>OutlineInputBorder</code> 或 <code>UnderlineInputBorder</code> 。</p>
<p><code>OutlineInputBorder</code> 在容易周围绘制一个圆角矩形。当输入装饰器的标签处于浮动状态时（例如，由于其输入子级具有焦点），标签将显示在边框轮廓的间隙中。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OutlineInputBorder(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，定义边界线的颜色和粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BorderSide borderSide = <span class="keyword">const</span> BorderSide(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderRadius类型可选命名参数，边界的圆角矩形的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.borderRadius = <span class="keyword">const</span> BorderRadius.all(Radius.circular(<span class="number">4.0</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，此边框的边的宽度表示为EdgeInsets</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.gapPadding = <span class="number">4.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>UnderlineInputBorder</code> 在 <code>InputDecorator</code> 容器的底部绘制一条水平线，并定义容器的形状。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UnderlineInputBorder(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，定义边界线的颜色和粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BorderSide borderSide = <span class="keyword">const</span> BorderSide(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderRadius类型可选命名参数，边界的圆角矩形的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.borderRadius = <span class="keyword">const</span> BorderRadius.only(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    topLeft: Radius.circular(<span class="number">4.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    topRight: Radius.circular(<span class="number">4.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>BorderSide</code> 在 <a href="http://www.mwpush.com/content/a22ef47b.html">http://www.mwpush.com/content/a22ef47b.html</a> 这里有过说明。</p>
<p><code>BorderRadius</code> 用于定义矩形每个角的不可变半径集。<code>BorderRadius</code> 类根据视觉角指定偏移量，例如左上方。这些值不受 <code>TextDirection</code> 的影响。为了同时支持从左到右和从右到左的布局，请考虑使用 <code>BorderRadiusDirectional</code> ，它以相对于 <code>TextDirection</code>的术语表示（通常从环境 <code>Directionality</code>获得）。</p>
<p><code>BorderRadius</code> 的几个构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建所有半径均为Radius的边界半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BorderRadius.all(Radius radius)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建所有半径均为Radius.circular(radius)的边界半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">BorderRadius.circular(<span class="built_in">double</span> radius)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建垂直对称的边框半径，其中矩形的顶部和底部的半径相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BorderRadius.vertical(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，顶部的左右两个半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Radius top = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，底部的左右两个半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Radius bottom = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建水平对称的边框半径，其中矩形的左侧和右侧具有相同的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BorderRadius.horizontal(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，左侧的上下两个半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Radius left = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，右侧的上下两个半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Radius right = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//仅使用给定的非零值创建边界半径。其他角将是直角</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BorderRadius.only(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，左上方的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.topLeft = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，右上方的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.topRight = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，左下方的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottomLeft = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Radius类型可选命名参数，右下方的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottomRight = Radius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>Radius</code> 用于定义圆形或椭圆形的半径。两个构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个圆半径。x和y将具有相同的半径值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Radius.circular(<span class="built_in">double</span> radius)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//构造具有给定半径的椭圆半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Radius.elliptical(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span></pre></td></tr></table></figure>

<p><code>InputDecorator</code> 用于定义“材料设计”文本字段的外观。<code>InputDecorator</code> 在其输入子项周围显示“材料设计”文本字段的可视元素。 可视元素本身由 <code>InputDecoration</code> 对象定义，其布局和外观取决于 <code>baseStyle</code> ，<code>textAlign</code> ，<code>isFocused</code> 和 <code>isEmpty</code> 参数。<code>TextField</code> 使用此小部件来装饰其 <code>EditableText</code> 子级。<code>InputDecorator</code> 可用于创建外观和行为类似于 <code>TextField</code> 的小部件，但支持其他类型的输入。</p>
<p><code>TextField</code> ，它使用 <code>InputDecorator</code> 在其 <code>EditableText</code> 子项周围显示边框，标签和图标。</p>
<p><code>keyboardType</code> 是 <code>TextInputType</code> 类型，用于定义键盘类型。如果设置为 <code>null</code> 或不设置，则为正常的英文键盘，如果设置，其提供了一个方法用于设置带有数字的键盘样式，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextInputType.numberWithOptions(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，带符号的数字键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.signed = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型，是否允许小数点提供小数，仅用于数字输入类型，否则为null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decimal = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>此外，还提供了静态属性用于设置键盘，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的文本键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType text = TextInputType._(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//默认的平台键盘，但在按Enter键时接受换行符。这是用于所有多行文本字段的输入类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType multiline = TextInputType._(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//默认的数字键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType number = TextInputType.numberWithOptions();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//电话号码拨号键盘，带*和#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType phone = TextInputType._(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在ios上使用默认键盘，在Android上带有数字键“:”和“-”的键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType datetime = TextInputType._(<span class="number">4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//带有@和.的电子邮件键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType emailAddress = TextInputType._(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//带有/和.com的url键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType url = TextInputType._(<span class="number">6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//一个可以同时访问字母和数字的键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextInputType visiblePassword = TextInputType._(<span class="number">7</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//所有的类型的列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">List</span>&lt;TextInputType&gt; values = &lt;TextInputType&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">  text, multiline, number, phone, datetime, emailAddress, url, visiblePassword,</span></pre></td></tr><tr><td class="code"><pre><span class="line">];</span></pre></td></tr></table></figure>



<p><code>TextInputAction</code> 用于定义键盘右下角按钮要执行的动作。每个动作代表一个逻辑含义，还配置软键盘以显示某种动作按钮。 在同一操作系统的版本之间，操作按钮的外观可能有所不同。尽管每个动作都有逻辑含义，但选择特定的 <code>TextInputAction</code> 不一定会导致发生任何特定的行为。 开发人员有责任确保按下操作按钮时发生的行为适合所选的操作按钮。例如：如果用户在读取“紧急呼叫”时按下 iOS 上的键盘操作按钮，则结果不应是将焦点更改为下一个 <code>TextField</code> 。 此行为在逻辑上不适用于显示“紧急呼叫”的按钮。有关自定义动作按钮行为的更多信息，请参见 <code>EditableText</code> 。</p>
<p>Android 和 iOS 均平等地支持大多数 <code>TextInputAction</code> 。 但是，Android 的 IME 输入类型和 iOS 的键盘返回类型之间没有完整，直接的映射。 因此，某些 <code>TextInputActions</code> 不适合其中一种平台。 如果开发人员在调试模式下运行时选择了不合适的 <code>TextInputAction</code> ，则将引发错误。 如果在发布模式下执行相同操作，则 Android 不会在平台端使用“ unspecified”，而不会发送不适当的值，而iOS会在平台端使用“ default”。<br>其为一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> TextInputAction &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：当前输入源（例如TextField）没有相关的输入操作。Android：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//对应于Android的“ IME_ACTION_NONE”。 键盘设置由操作系统决定。 键盘可能会显示一个返回键。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//iOS：iOS没有键盘返回类型“ none”。 在iOS上运行时，选择此TextInputAction是不合适的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  none,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：让操作系统决定最合适的操作。Android：与Android的“ IME_ACTION_UNSPECIFIED”相对应。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//操作系统选择要显示的键盘操作。 该决定可能是完成按钮或返回键。iOS：对应于iOS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//的“ UIReturnKeyDefault”。 动作按钮中显示的标题为“返回”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  unspecified,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：用户完成向一组输入（如表单）提供输入的操作。 现在应该发生某种终结行为。Android：与</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Android的“ IME_ACTION_DONE”相对应。 操作系统显示代表完成的按钮，例如复选标记按钮。iOS：对应</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//于iOS的“ UIReturnKeyDone”。 操作按钮中显示的标题为“完成”</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  done,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：用户输入了一些代表目的地的文本，例如餐馆名称。 “开始”按钮旨在将用户带到与该目的地相对应的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//应用程序部分。Android：对应于Android的“ IME_ACTION_GO”。 操作系统显示一个按钮，该按钮表示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//将“用户带到他们输入的文本的目标”，例如，向右的箭头按钮。iOS：对应于iOS的“ UIReturnKeyGo”。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//动作按钮中显示的标题为“开始”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  go,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：执行搜索查询。Android：与Android的“ IME_ACTION_SEARCH”相对应。 操作系统显示代表搜索的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮，例如放大镜按钮。iOS：对应于iOS的“ UIReturnKeySearch”。 操作按钮中显示的标题为“搜索”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  search,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：发送用户撰写的内容，例如电子邮件或短信。Android：与Android的“ IME_ACTION_SEND”相对应。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//操作系统会显示一个代表发送内容的按钮，例如纸飞机按钮。iOS：对应于iOS的“ UIReturnKeySend”。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//动作按钮中显示的标题为“发送”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  send,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：用户已完成当前输入源的操作，并希望移至下一个输入源。Android：与Android</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//的“ IME_ACTION_NEXT”相对应。 操作系统显示代表前进的按钮，例如，向右的箭头按钮。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//iOS：与iOS的“ UIReturnKeyNext”相对应。 动作按钮中显示的标题为“下一步”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  next,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：用户希望返回到组中的上一个输入源，例如，具有多个TextField的表单。Android：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//与Android的“ IME_ACTION_PREVIOUS”相对应。 操作系统显示代表向后移动的按钮，例如，向左的箭头按钮。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//iOS：iOS没有键盘返回类型为“ previous”。 在iOS上运行时，选择此TextInputAction是不合适的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  previous,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：在iOS应用中，通常会在屏幕顶部显示“返回”按钮和“继续”按钮。 但是，当键盘打开时，这些按钮通</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//常在屏幕外隐藏。 因此，iOS上“继续”返回键的目的是在用户输入文本时使“继续”按钮可用。除了历史上下文，可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//以在术语“继续”似乎最适合给定操作的任何时间使用TextInputAction.continueAction。Android：Android</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//没有IME输入类型为“ continue”。 在Android上运行时，选择此TextInputAction是不合适的。iOS：与iOS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//的“ UIReturnKeyContinue”相对应。 动作按钮中显示的标题为“继续”。 此操作仅在iOS 9.0+上可用。此值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//后缀为“ Action”的原因是因为“ continue”是Dart以及许多其他语言中的保留字。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  continueAction,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：用户想加入某些东西，例如无线网络。Android：Android没有IME输入类型“ join”。 在</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Android上运行时，选择此TextInputAction是不合适的。iOS：与iOS的“ UIReturnKeyJoin”相对应。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//动作按钮中显示的标题为“加入”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  join,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：用户想要路线选择，例如，驾驶路线。Android：Android没有IME输入类型“ route”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在Android上运行时，选择此TextInputAction是不合适的。iOS：对应于iOS的“UIReturnKeyRoute”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//动作按钮中显示的标题为“ Route”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  route,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：启动对紧急服务的呼叫。Android：Android没有IME输入类型“ emergencyCall”。 在Android</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//上运行时，选择此TextInputAction是不合适的。iOS：与iOS的“ UIReturnKeyEmergencyCall”相对应。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//动作按钮中显示的标题为“紧急呼叫”。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  emergencyCall,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//逻辑含义：在重点文本输入中插入换行符，例如TextField。Android：对应于Android的“IME_ACTION_NONE”。       	 //操作系统显示代表新行的按钮，例如回车按钮。iOS：对应于iOS的“ UIReturnKeyDefault”。 动作按钮</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//中显示的标题为“返回”。术语TextInputAction.newline在Flutter中存在，但在Android或iOS中不存在。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//引入该术语的原因是，使开发人员可以实现插入新行的常见结果，而无需了解Android上的各种IME操作和iOS上的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//返回键。 因此，TextInputAction.newline是一个方便的术语，它减轻了理解底层平台来实现此常见行为的需要。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  newline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><code>TextCapitalization</code> 配置平台键盘如何选择大写或小写键盘。仅支持文本键盘，其他键盘类型将忽略此配置。 大写字母可识别区域设置。是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> TextCapitalization &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//默认为每个单词的第一个字母的大写键盘。对应于Android上的InputType.TYPE_TEXT_FLAG_CAP_WORDS和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//iOS上的UITextAutocapitalizationTypeWords</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  words,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//每个句子的首字母默认为大写键盘。对应于Android上的InputType.TYPE_TEXT_FLAG_CAP_SENTENCES，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//以及iOS上的UITextAutocapitalizationTypeSentences。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  sentences,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//每个字符默认为大写键盘。对应于Android上的InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//以及iOS上的UITextAutocapitalizationTypeAllCharacters。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  characters,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//默认为小写键盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><code>StrutStyle</code> </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> StrutStyle(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> fontFamily,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; fontFamilyFallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.leading,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontWeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.forceStrutHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.debugLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> package,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<p><code>TextAlignVertical</code> 用于设置文本的垂直对齐方式。是一个 y 值，范围从 -1.0 到 1.0 。 -1.0 对齐输入框的顶部，以使第一行文本的顶部适合该框及其填充。 0.0 对齐框的中心。 1.0 对齐，以使文本的最后一行的底部与输入框的底部内部边缘对齐。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextAlignVertical(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，设置y值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.y,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>也可以直接使用其类属性，定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextAlignVertical top = TextAlignVertical(y: <span class="number">-1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextAlignVertical center = TextAlignVertical(y: <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TextAlignVertical bottom = TextAlignVertical(y: <span class="number">1.0</span>);</span></pre></td></tr></table></figure>



<p><code>ToolbarOptions</code> 用于 <code>EditableText</code> 的工具栏配置。工具栏是上下文菜单，当用户右键单击或长按 <code>EditableText</code> 时将显示该菜单。它包括几个选项：剪切，复制，粘贴和全选。<code>EditableText</code> 及其派生的窗口小部件具有其自己的默认 <code>ToolbarOptions</code> 。如果要显式控制工具栏选项，请创建一个自定义 <code>ToolbarOptions</code> 。</p>
<p>其提供的构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ToolbarOptions(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在工具栏中显示复制选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.copy = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在工具栏中显示剪切选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.cut = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在工具栏中显示粘贴选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.paste = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示选择工具栏中的全选选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectAll = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<p><code>TextInputFormatter</code> 用于设置输入验证和正在编辑的文本的格式。文本修改仅应在IME提交文本时应用，而不能应用于组合文本(即，仅当 <code>TextEditingValue.composed</code> 折叠时)。<code>TextInputFormatter</code> 是一个抽象类，提供了三个子类可以直接使用：<code>BlacklistingTextInputFormatter</code> 、<code>WhitelistingTextInputFormatter</code> 和 <code>LengthLimitingTextInputFormatter</code> 。也可以自定义自己的格式器类，需继承 <code>TextInputFormatter</code> 并实现 <code>formatEditUpdate</code> 方法即可。</p>
<p><code>BlacklistingTextInputFormatter</code> 格式器提供了一个黑名单的功能，作用是防止插入黑名单设置的字符。在新<code>TextEditingValues</code> 中发现的列入黑名单的字符实例将替换为 <code>replaceString</code> ，该字符串默认为空字符串。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">BlacklistingTextInputFormatter(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Pattern类型必传参数，匹配和替换传入文本的值的模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.blacklistedPattern, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于替换找到的模式的字符串。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.replacementString = <span class="string">''</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>BlacklistingTextInputFormatter</code> 还提供了一个静态属性，定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> BlacklistingTextInputFormatter singleLineFormatter</span></pre></td></tr><tr><td class="code"><pre><span class="line">      = BlacklistingTextInputFormatter(<span class="built_in">RegExp</span>(<span class="string">r'\n'</span>));</span></pre></td></tr></table></figure>

<p>此属性只能输入单行。</p>
<p><code>WhitelistingTextInputFormatter</code> 格式器提供了一个白名单的功能，作用是只允许插入百白名单设置的字符。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">WhitelistingTextInputFormatter(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Pattern类型必传参数，用于提取允许的字符的所有实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.whitelistedPattern</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>

<p><code>WhitelistingTextInputFormatter</code> 还提供了一个静态的属性，定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> WhitelistingTextInputFormatter digitsOnly</span></pre></td></tr><tr><td class="code"><pre><span class="line">      = WhitelistingTextInputFormatter(<span class="built_in">RegExp</span>(<span class="string">r'\d+'</span>));</span></pre></td></tr></table></figure>

<p>此属性限制只接受数字 0 到 9 。</p>
<p><code>LengthLimitingTextInputFormatter</code> 格式器提供了一个防止插入超过限定字符的功能(当前定义为 Unicode 标量值)。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">LengthLimitingTextInputFormatter(</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//int类型必传参数，最大字符长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxLength</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>

<p><code>Pattern</code> 是一个抽象类，实现了在字符串中进行基本搜索的接口。其直接实现类有 <code>Glob</code> 、<code>Parser</code> 、 <code>RegExp</code> 、<code>String</code> 。</p>
<p>关于更多 <code>TextInputFormatter</code> 会在后续文章中详细介绍。</p>
<p><code>TextForm</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/services.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextEditingController _controllerUser;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextEditingController _controllerPwd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _controllerUser = TextEditingController();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _controllerPwd = TextEditingController();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> dispose() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _controllerUser.dispose();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _controllerPwd.dispose();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.dispose();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.only(left: <span class="number">50</span>, top: <span class="number">20</span>, right: <span class="number">50</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TextField(     <span class="comment">//账户输入框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              controller: _controllerUser,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              decoration: InputDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                labelText: <span class="string">"用户名"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                helperText: <span class="string">"请输入用户名"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                hintText: <span class="string">"请输入数字或字母"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                prefixIcon: Icon(Icons.account_box),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                filled: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                fillColor: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                border: OutlineInputBorder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  borderRadius: BorderRadius.all(Radius.circular(<span class="number">10</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              maxLength: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              textInputAction: TextInputAction.next,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              textCapitalization: TextCapitalization.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              style: TextStyle(fontSize: <span class="number">18</span>, ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              textAlignVertical: TextAlignVertical.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              toolbarOptions: ToolbarOptions(selectAll: <span class="keyword">true</span>, copy: <span class="keyword">true</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              autocorrect: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              enableSuggestions: <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onChanged: (<span class="built_in">String</span> changeValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">print</span>(changeValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onEditingComplete: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">print</span>(<span class="string">"输入完成下一步操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onSubmitted: (<span class="built_in">String</span> resultValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">print</span>(resultValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">              inputFormatters:&lt;TextInputFormatter&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                BlacklistingTextInputFormatter.singleLineFormatter,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                WhitelistingTextInputFormatter.digitsOnly,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                LengthLimitingTextInputFormatter(<span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">              keyboardAppearance: Brightness.light,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              scrollPadding: EdgeInsets.all(<span class="number">50</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onTap: ()=&gt; <span class="built_in">print</span>(<span class="string">"tap"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              buildCounter: (BuildContext context, &#123;<span class="built_in">int</span> currentLength, <span class="built_in">int</span> maxLength, <span class="built_in">bool</span> isFocused&#125;)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> Text(<span class="string">"<span class="subst">$currentLength</span>/<span class="subst">$maxLength</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SizedBox(height: <span class="number">20</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TextField(            <span class="comment">//密码输入框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              controller: _controllerPwd,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              decoration: InputDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                labelText: <span class="string">"密  码"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                helperText: <span class="string">"请输入数字密码"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                hintText: <span class="string">"请输入数字"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                prefixIcon: Icon(Icons.account_box),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                counterText: <span class="string">"密码字数统计"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                filled: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                fillColor: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                border: OutlineInputBorder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  borderRadius: BorderRadius.all(Radius.circular(<span class="number">10</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              keyboardType: <span class="keyword">const</span> TextInputType.numberWithOptions(signed: <span class="keyword">false</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              obscureText: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SizedBox(height: <span class="number">20</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"提交"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               showDialog(context: context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 builder: (BuildContext context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> AlertDialog(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    title: Text(<span class="string">"查看结果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    content: Text(<span class="string">"<span class="subst">$&#123;_controllerUser.text&#125;</span>\n<span class="subst">$&#123;_controllerPwd.text&#125;</span>"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">               );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/899da56a/2020421030.jpg" alt="2020421030" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>TextField</tag>
        <tag>TextInputType</tag>
        <tag>TextInputFormatter</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十五)</title>
    <url>/content/1092ed18.html</url>
    <content><![CDATA[<h4 id="一、showDatePicker-Function"><a href="#一、showDatePicker-Function" class="headerlink" title="一、showDatePicker Function"></a>一、showDatePicker Function</h4><p><code>showDatePicker</code> 方法显示一个包含日期选择器的对话框 。当用户关闭对话框时，返回的 <code>Future</code> 解析为用户选择的日期。如果用户取消对话框，则返回 <code>null</code> 。</p>
<a id="more"></a>

<p>可以传入一个可选的 <code>selectableDayPredicate</code> 函数来定制天数，以启用选择。如果提供了，那么只有 <code>selectableDayPredicate</code> 返回 <code>true</code> 的天数才是可选择的。可选的 <code>initialDatePickerMode</code> 参数可用于最初在年或月+日选择器模式中显示日期选择器。它默认为月+日，并且不能为空。</p>
<p>可选的语言环境参数可用于设置日期选择器的语言环境。 它默认为 <code>Localizations</code> 提供的环境语言环境。</p>
<p>可选的 <code>textDirection</code> 参数可用于设置日期选择器的文本方向(RTL或LTR)。 它默认为 <code>Directionality</code> 提供的环境文本方向。 如果 <code>locale</code> 和 <code>textDirection</code> 都不为 <code>null</code> ，则 <code>textDirection</code> 会覆盖为语言环境选择的方向。</p>
<p><code>context</code> 和 <code>useRootNavigator</code> 参数传递给 <code>showDialog</code> 。<code>useRootNavigator</code> 参数用于确定是否将对话框推到距给定上下文最远或最接近给定上下文的 <code>Navigator</code> 。 默认情况下，<code>useRootNavigator</code> 为 <code>true</code> ，并且由此方法创建的对话框路由被推送到根导航器。如果应用程序具有多个 <code>Navigator</code>对象，则可能有必要调用 <code>Navigator.of(context, rootNavigator:true).pop(result)</code>关闭对话框，而不仅仅是 <code>Navigator.pop(context, result)</code>。</p>
<p><code>builder</code> 参数可用于包装对话框窗口小部件以添加继承的窗口小部件，例如 <code>Theme</code>。</p>
<p>方法定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">DateTime</span>&gt; showDatePicker(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BuildContext类型必传参数，上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> BuildContext context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，初始化选中的时间日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">DateTime</span> initialDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，可呈现的开始日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">DateTime</span> firstDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，可呈现的结束日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">DateTime</span> lastDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SelectableDayPredicate类型可选命名参数，用于设置可选择的时间区域，是一个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  SelectableDayPredicate selectableDayPredicate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DatePickerMode类型可选命名参数，日期对话框的初始显示模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DatePickerMode initialDatePickerMode = DatePickerMode.day,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Locale类型可选命名参数，本地化设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Locale locale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，文本的显示方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextDirection textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TransitionBuilder类型可选命名参数，构建子Widget的构建器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TransitionBuilder builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，参数用于确定是否将对话框推到距给定上下文最远或最接近给定上下文的Navigator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> useRootNavigator = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>DateTime</code> 是用来设置日期时间的类。创建对象时，<code>DateTime</code> 对象将锚定在当前计算机的 UTC 时区或本地计算机的本地时区中。创建后，<code>DateTime</code> 对象的值和时区都不能更改。您可以使用属性来获取 <code>DateTime</code> 对象的各个单位。有以下构造方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造在本地时区中指定的DateTime实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">DateTime</span>(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，年</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> year,[</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选位置参数，月</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> month = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选位置参数，日</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> day = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选位置参数，小时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> hour = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选位置参数，分钟</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> minute = <span class="number">0</span>,  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选位置参数，秒数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> second = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选位置参数，毫秒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> millisecond = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选位置参数，微妙</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> microsecond = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//构造在UTC时区中指定的DateTime实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">DateTime</span>.utc(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//参数与DateTime相同，此处省略</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">])  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用本地时区中的当前日期和时间构造一个DateTime实例  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">DateTime</span>.now()  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用给定的毫秒构造一个新的DateTime实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">DateTime</span>.fromMillisecondsSinceEpoch(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，自1970-01-01T00:00:00Z (UTC)起的毫秒数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> millisecondsSinceEpoch,&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否为UTC时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isUtc = <span class="keyword">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用给定的微秒构造一个新的DateTime实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">DateTime</span>.fromMicrosecondsSinceEpoch(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，自1970-01-01T00：00：00Z（UTC）起的微秒数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> microsecondsSinceEpoch,&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否为UTC时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isUtc = <span class="keyword">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>具体可查看官方说明：<a href="https://api.flutter.dev/flutter/dart-core/DateTime-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/dart-core/DateTime-class.html</a></p>
<p><code>SelectableDayPredicate</code> 是一个返回值为 <code>bool</code> 类型的函数，定义为 <code>bool Function(DateTime day)</code> 。</p>
<p><code>DatePickerMode</code> 用于设置日期选择器对话框的初始显示模式。日期选择器UI模式，用于通过调用showDatePicker在显示的对话框中最初显示可用年份列表或月历。是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DatePickerMode &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//显示用于选择月份和日期的日期选择器用户界面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  day,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//显示用于选择年份的日期选择器用户界面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  year,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>showDatePicker</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> _selectResult = <span class="string">"time"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  callDatePicker() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">DateTime</span> resultDate = <span class="keyword">await</span> selectedDate();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _selectResult = resultDate.toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Future&lt;<span class="built_in">DateTime</span>&gt; selectedDate() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> showDatePicker(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      context: context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      initialDate: <span class="built_in">DateTime</span>.now(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      firstDate: <span class="built_in">DateTime</span>(<span class="number">1997</span>, <span class="number">1</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      lastDate: <span class="built_in">DateTime</span>(<span class="number">2100</span>, <span class="number">1</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      selectableDayPredicate: (<span class="built_in">DateTime</span> dateTime) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(dateTime.compareTo(<span class="built_in">DateTime</span>(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">3</span>)) &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      initialDatePickerMode: DatePickerMode.day,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      builder: (BuildContext context, Widget child) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Theme(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          data: ThemeData.dark(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"显示Dialog"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: callDatePicker,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Text(<span class="string">"<span class="subst">$_selectResult</span>"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/202041800.jpg" alt="截屏2020-04-01下午8" style="zoom:50%;">



<h4 id="二、showTimePicker-Function"><a href="#二、showTimePicker-Function" class="headerlink" title="二、showTimePicker Function"></a>二、showTimePicker Function</h4><p><code>showTimePicker</code> 方法显示一个包含时间选择器的对话框。返回的 <code>Future</code> 解析为用户关闭对话框时用户选择的时间。如果用户取消对话框，则返回 <code>null</code> 。</p>
<p><code>builder</code> 参数可用于包装对话框窗口小部件以添加继承的窗口小部件，例如 <code>Localizations.override</code> ， <code>Directivity</code> 或 <code>MediaQuery</code> 。</p>
<p>方法定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;TimeOfDay&gt; showTimePicker(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BuildContext类型必传参数，上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> BuildContext context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TimeOfDay类型必传参数，初始化选择的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> TimeOfDay initialTime,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TransitionBuilder类型可选命名参数，用于包装对话框窗口小部件以添加继承的窗口小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TransitionBuilder builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，参数用于确定是否将对话框推到距给定上下文最远或最接近给定上下文的Navigator</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> useRootNavigator = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>TimeOfDay</code> 是一个表示一天中时间值的类。时间以小时和分钟对表示。 创建后，两个值都无法更改。可以使用同时需要小时和分钟的构造函数或使用 <code>DateTime</code> 对象来创建 <code>TimeOfDay</code> 。 与 24 小时制一样，将小时指定在 0 到 23 之间。构造方法有如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一天中的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TimeOfDay(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，小时，取值范围0到23</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.hour, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，分钟</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.minute </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//根据给定时间创建一天中的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TimeOfDay.fromDateTime(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，用来设置日期时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">DateTime</span> time</span></pre></td></tr><tr><td class="code"><pre><span class="line">)  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//根据当前时间创建一天中的时间  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TimeOfDay.now()</span></pre></td></tr></table></figure>

<p><code>showTimePicker</code> 使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> _selectResult;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> formatCurrentTime(TimeOfDay cTime) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> TimeOfDay nowTime = cTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">String</span> nowTimeString = <span class="string">"<span class="subst">$&#123;nowTime.hour&#125;</span>:<span class="subst">$&#123;nowTime.minute&#125;</span>"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> nowTimeString;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  callDatePicker() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TimeOfDay resultTime = <span class="keyword">await</span> selectedTime();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _selectResult = formatCurrentTime(resultTime);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(_selectResult);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Future&lt;TimeOfDay&gt; selectedTime() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> showTimePicker(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      context: context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      initialTime: TimeOfDay.now(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      builder: (BuildContext context, Widget child) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Theme(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          data: ThemeData.dark(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _selectResult = formatCurrentTime(TimeOfDay.now());</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"显示Dialog"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: callDatePicker,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Text(<span class="string">"<span class="subst">$_selectResult</span>"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/202041943.jpg" alt="202041943" style="zoom:50%;">

<p>上述代码自定义了一个将 <code>TimeOfDay</code> 转换为所需字符串的方法，也可以引入 <code>DateFormat</code> 。</p>
<h4 id="三、showModalBottomSheet-Function"><a href="#三、showModalBottomSheet-Function" class="headerlink" title="三、showModalBottomSheet Function"></a>三、showModalBottomSheet Function</h4><p><code>showModalBottomSheet</code> 显示一个模态的从底部弹出的底页。模态底页是菜单或对话框的替代方案，可防止用户与应用程序的其余部分进行交互。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T&gt; showModalBottomSheet&lt;T&gt;(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BuildContext类型必传参数，上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> BuildContext context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//WidgetBuilder类型必传参数，用于构建子Widget的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> WidgetBuilder builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，Z轴坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，边框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ShapeBorder shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，如何剪裁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Clip clipBehavior,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，参数指定这是否是将使用DraggableScrollableSheet的底部工作表的路由。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//如果希望具有可滚动子级（例如ListView或GridView）的底页，并且底页是可拖动的，则应将此参数设置为true。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isScrollControlled = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，参数确保在设置为true时，根导航器用于显示BottomSheet。如果需要在所有其他</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//内容上方显示模式BottomSheet，但调用者在另一个Navigator内，则这很有用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> useRootNavigator = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，点击模态背景是否关闭底页</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isDismissible = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            onPressed: ()=&gt;showModalBottomSheet(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              isDismissible: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              context: context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              builder: (ctx)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/2020421104.jpg" alt="2020421104" style="zoom:50%;">



<h4 id="四、showButtomSheet-Function"><a href="#四、showButtomSheet-Function" class="headerlink" title="四、showButtomSheet Function"></a>四、showButtomSheet Function</h4><p><code>showButtomSheet</code> 显示最近的 <code>Scaffold</code> 祖先中的设计底页。如果希望显示持久的底部工作表，请使用<code>Scaffold.bottomSheet</code> ，关于 <code>bottomSheet</code> 前面文章介绍过，<a href="http://www.mwpush.com/content/950cce6d.html。">http://www.mwpush.com/content/950cce6d.html。</a> </p>
<p>该方法返回一个 <code>PersistentBottomSheetController</code> 类型的控制器，可用于关闭和操作底页。要重建底部工作表(例如，如果它是有状态的)，请在此方法返回的控制器上调用 <code>PersistentBottomSheetController.setState</code> 。新的底部工作表将成为封闭 <code>ModalRoute</code> 的 <code>LocalHistoryEntry</code> ，并且向后的按钮添加到了脚手架的应用程序栏中，以关闭底部工作表。要创建不是 <code>LocalHistoryEntry</code> 的持久性底页，并且不向封闭的Scaffold的应用程序栏添加后退按钮，请使用 <code>Scaffold.bottomSheet</code> 构造函数参数。</p>
<p>方法定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">PersistentBottomSheetController&lt;T&gt; showBottomSheet&lt;T&gt;(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BuildContext类型必传参数，上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> BuildContext context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//WidgetBuilder类型必传参数，用于构建子Widget的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> WidgetBuilder builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，Z轴坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，边框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ShapeBorder shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，如何剪裁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Clip clipBehavior,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Builder(builder: (context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"显示"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                PersistentBottomSheetController controller = showBottomSheet(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  context: context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  builder: (context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/202042123.jpg" alt="202042123" style="zoom:50%;">



<p>使用 <code>Scaffold.of()</code> 方法调用如下，</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Builder(builder: (context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"显示"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: () &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Scaffold.of(context).showBottomSheet((context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      child: FlatButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        child: Text(<span class="string">"关闭"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        onPressed: ()=&gt; Navigator.pop(context),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="五、DayPicker-Widget"><a href="#五、DayPicker-Widget" class="headerlink" title="五、DayPicker Widget"></a>五、DayPicker Widget</h4><p><code>DayPicker</code> 是显示给定月份的日期并允许选择一天的 Widget 。这些天以矩形网格排列，一周的每一天都有一列。此 Widget 很少直接使用。 相反，请考虑使用 <code>showDatePicker</code> ，它会创建一个日期选择器对话框。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DayPicker(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，当前选择的日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.selectedDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，显示选择器时的当前日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.currentDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;DateTime&gt;类型必传参数，当用户选择一天时调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，允许用户选择最早的日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.firstDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，允许用户选择的最晚日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.lastDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，此选择器显示其日期的月份</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.displayedMonth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SelectableDayPredicate类型可选命名参数，可选的用户提供的谓词功能可自定义可选日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectableDayPredicate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">DateTime</span> _currentDate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _currentDate = <span class="built_in">DateTime</span>(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: DayPicker(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            selectedDate: _currentDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            currentDate: <span class="built_in">DateTime</span>.now(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            onChanged: (<span class="built_in">DateTime</span> dateTime)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _currentDate = dateTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            firstDate: <span class="built_in">DateTime</span>(<span class="number">1997</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lastDate: <span class="built_in">DateTime</span>(<span class="number">2200</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            displayedMonth: <span class="built_in">DateTime</span>.now(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            selectableDayPredicate: (<span class="built_in">DateTime</span> dateTime) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">if</span>(dateTime.compareTo(<span class="built_in">DateTime</span>(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">5</span>)) &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; ,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/2020421003.jpg" alt="2020421003" style="zoom:50%;">



<h4 id="六、MonthPicker-Widget"><a href="#六、MonthPicker-Widget" class="headerlink" title="六、MonthPicker Widget"></a>六、MonthPicker Widget</h4><p><code>MonthPicker</code> 是一个可滚动的月份列表，允许选择一个月。在矩形网格中显示每月的某天，一周的每一天都有一列。<code>MonthPicker</code> 很少直接使用，可以考虑使用 <code>showDatePicker</code> ，它会创建一个日期选择器对话框。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MonthPicker(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，当前选择的日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.selectedDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;DateTime&gt;类型必传参数，当用户选择年份时调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，允许用户选择最早的日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.firstDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，允许用户选择的最晚日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.lastDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SelectableDayPredicate类型可选命名参数，可选的用户提供的谓词功能可自定义可选日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectableDayPredicate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">DateTime</span> _currentDate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _currentDate = <span class="built_in">DateTime</span>(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: MonthPicker(					<span class="comment">//MonthPicker</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            selectedDate: _currentDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            onChanged: (<span class="built_in">DateTime</span> dateTime)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _currentDate = dateTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            firstDate: <span class="built_in">DateTime</span>(<span class="number">1997</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lastDate: <span class="built_in">DateTime</span>(<span class="number">2200</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            selectableDayPredicate: (<span class="built_in">DateTime</span> dateTime) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">if</span>(dateTime.compareTo(<span class="built_in">DateTime</span>(<span class="number">2020</span>, <span class="number">4</span>, <span class="number">5</span>)) &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; ,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/202042959.jpg" alt="202042959" style="zoom:50%;">



<h4 id="七、YearPicker-Widget"><a href="#七、YearPicker-Widget" class="headerlink" title="七、YearPicker Widget"></a>七、YearPicker Widget</h4><p><code>YearPicker</code> 是一个可滚动的年份列表，允许选择年份。<code>YearPicker</code> 很少直接使用，可以考虑使用 <code>showDatePicker</code> 它会创建一个日期选择器对话框。 构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">YearPicker(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，当前选择的日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.selectedDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;DateTime&gt;类型必传参数，当用户选择年份时调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，允许用户选择最早的日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.firstDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DateTime类型必传参数，允许用户选择的最晚日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.lastDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">DateTime</span> _currentDate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _currentDate = <span class="built_in">DateTime</span>(<span class="number">2020</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: YearPicker(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            selectedDate: _currentDate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            onChanged: (<span class="built_in">DateTime</span> dateTime)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                _currentDate = dateTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            firstDate: <span class="built_in">DateTime</span>(<span class="number">1997</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            lastDate: <span class="built_in">DateTime</span>(<span class="number">2200</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/202042938.jpg" alt="202042938" style="zoom:50%;">



<h4 id="八、ExpansionPanelList-Widget"><a href="#八、ExpansionPanelList-Widget" class="headerlink" title="八、ExpansionPanelList Widget"></a>八、ExpansionPanelList Widget</h4><p><code>ExpansionPanelList</code> 是一个扩展列表，其中列出了其子级并为扩展设置了动画效果。<code>ExpansionPanelList</code> 必须包含在主轴可以无限扩展的 Widget 中。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个扩展面板列表小部件。当按下扩展面板的扩展/折叠按钮时，会触发expandingCallback</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExpansionPanelList(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;ExpansionPanel&gt;类型可选命名参数，扩展面板的子级列表。它们的布局与ListBody相似。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children = <span class="keyword">const</span> &lt;ExpansionPanel&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ExpansionPanelCallback类型可选命名参数，按下扩展/折叠按钮之一时将调用的回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//传递给回调的参数是所按面板的索引以及面板当前是否展开</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.expansionCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Duration类型可选命名参数，扩展动画的持续时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.animationDuration = kThemeAnimationDuration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Radio扩展面板列表小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExpansionPanelList.radio(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;ExpansionPanelRadio&gt;类型可选命名参数，扩展面板的子级列表。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children = <span class="keyword">const</span> &lt;ExpansionPanelRadio&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">///<span class="markdown">传递给回调的参数是所按面板的索引以及面板当前是否展开</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.expansionCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">////<span class="markdown">Duration类型可选命名参数，扩展动画的持续时间</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.animationDuration = kThemeAnimationDuration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Object类型可选命名参数，最初开始打开的面板的值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialOpenPanelValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>ExpansionPanel</code> 是扩展面板。 它具有标题和主体，可以扩展或折叠。 面板的主体只有在展开时才可见。其用于 <code>ExpansionPanelList</code> 的子 Widget 。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ExpansionPanel(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ExpansionPanelHeaderBuilder类型必传参数，构建扩展面板标题的窗口小部件构建器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.headerBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，标头下方显示的扩展面板的主体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.body,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，点击面板标题是否会展开/折叠</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isExpanded = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，面板是否展开</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.canTapOnHeader = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>ExpansionPanelHeaderBuilder</code> 是一个返回值为 <code>Widget</code> 的方法，定义为：<code>Widget Function(BuildContext context, bool isExpanded)</code> 。</p>
<p><code>ExpansionPanelRadio</code> 是一个最多只能有一项面板可以展开的扩展面板。必须为每个面板分配唯一的标识符值。 该标识符允许 <code>ExpansionPanelList</code> 确定应扩展哪个 <code>ExpansionPanelRadio</code> 实例。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ExpansionPanelRadio(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Object类型必传参数，该值唯一地标识一个Radio面板，以便可以标识当前选择的Radio面板。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ExpansionPanelHeaderBuilder类型必传参数，构建扩展面板标题的窗口小部件构建器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> ExpansionPanelHeaderBuilder headerBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，标头下方显示的扩展面板的主体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> Widget body,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，点击面板标题是否会展开/折叠</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> canTapOnHeader = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>ExpansionPanelList</code> 实现方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _itemTitles = &lt;<span class="built_in">String</span>&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"联系人"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"分组"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"黑名单"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;ExpandItem&gt; _generateItems(<span class="built_in">int</span> itemsCount) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">List</span>.generate(itemsCount, (<span class="built_in">int</span> index)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> ExpandItem(_itemTitles[index], <span class="keyword">false</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;ExpandItem&gt; _resultData;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _resultData = _generateItems(_itemTitles.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:  SingleChildScrollView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ExpansionPanelList(				<span class="comment">//ExpansionPanelList</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: _resultData.map&lt;ExpansionPanel&gt;((ExpandItem item)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ExpansionPanel(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              canTapOnHeader: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              headerBuilder: (BuildContext context, <span class="built_in">bool</span> expanded)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  padding: EdgeInsets.only(left: <span class="number">20</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  alignment: Alignment.centerLeft,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  height: <span class="number">80</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  child: Text(<span class="string">"<span class="subst">$&#123;item.title&#125;</span>"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              isExpanded: item.isExpanded,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;).toList(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          expansionCallback: (<span class="built_in">int</span> panelIndex, <span class="built_in">bool</span> isExpanded)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              _resultData[panelIndex].isExpanded = !isExpanded;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/202042353.jpg" alt="202042353" style="zoom:50%;">



<p><code>ExpansionPanelRadio</code> 使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _itemTitles = &lt;<span class="built_in">String</span>&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"联系人"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"分组"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"黑名单"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;ExpandItem&gt; _generateItems(<span class="built_in">int</span> itemsCount) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">List</span>.generate(itemsCount, (<span class="built_in">int</span> index)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> ExpandItem(_itemTitles[index], <span class="keyword">false</span>, index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;ExpandItem&gt; _resultData;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _resultData = _generateItems(_itemTitles.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body:  SingleChildScrollView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ExpansionPanelList.radio(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          initialOpenPanelValue: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: _resultData.map&lt;ExpansionPanelRadio&gt;((ExpandItem item)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ExpansionPanelRadio(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: item.id,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              canTapOnHeader: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              headerBuilder: (BuildContext context, <span class="built_in">bool</span> expanded)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  padding: EdgeInsets.only(left: <span class="number">20</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  alignment: Alignment.centerLeft,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  height: <span class="number">80</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  child: Text(<span class="string">"<span class="subst">$&#123;item.title&#125;</span>"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;).toList(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          expansionCallback: (<span class="built_in">int</span> panelIndex, <span class="built_in">bool</span> isExpanded)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              _resultData[panelIndex].isExpanded = !isExpanded;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpandItem</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ExpandItem(<span class="keyword">this</span>.title, <span class="keyword">this</span>.isExpanded, <span class="keyword">this</span>.id);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> title;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isExpanded;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1092ed18/202042354.jpg" alt="202042354" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>showDatePicker</tag>
        <tag>DayPicker</tag>
        <tag>showButtomSheet</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十四)</title>
    <url>/content/1639ba65.html</url>
    <content><![CDATA[<h4 id="一、Radio-Widget"><a href="#一、Radio-Widget" class="headerlink" title="一、Radio Widget"></a>一、Radio Widget</h4><p><code>Radio</code> 是单选按钮 Widget 。用于在多个互斥值之间进行选择。 当选择了组中的一个单选按钮时，该组中的其他单选按钮将停止被选择。<code>Radio</code> 通常与 <code>enum</code> 配合使用。单选按钮本身不保持任何状态。相反，选择单选会调用 <code>onChanged</code> 回调，并将值作为参数传递。如果 <code>groupValue</code> 和 <code>value</code> 匹配，则将选择此单选。大多数小部件将通过调用 <code>State.setState</code> 来更新单选按钮的 <code>groupValue</code> 来响应 <code>onChanged</code> 。 构造方法如下：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Radio(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//T类型(泛型)必传参数，此单选按钮表示的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//T类型(泛型)必传参数，一组单选按钮的当前选定值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.groupValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;T&gt;类型必传参数，单选按钮被选择时调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选择此单选按钮时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，具有输入焦点时的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，指针悬停在点选按钮上时的颜色。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Fruits&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Apple,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Banana,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Orange,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createState</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Fruits _fruit = Fruits.Banana;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"苹果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Radio(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                value: Fruits.Apple,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                groupValue: _fruit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onChanged: (fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    _fruit = fruitValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"香蕉"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Radio(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                value: Fruits.Banana,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                groupValue: _fruit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onChanged: (fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    _fruit = fruitValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"柑橘"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Radio(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                value: Fruits.Orange,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                groupValue: _fruit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onChanged: (fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    _fruit = fruitValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/20203311012.jpg" alt="20203311012" style="zoom:50%;">



<h4 id="二、-RadioListTile-Widget"><a href="#二、-RadioListTile-Widget" class="headerlink" title="二、 RadioListTile Widget"></a>二、 RadioListTile Widget</h4><p><code>Radio</code> 是单纯的单选按钮，如果需要显示标签，需要配合其他 Widget 来做展示操作。<code>RadioListTile</code> 是自带标签的单选按钮，相当于 <code>Radio</code> 和 <code>ListTile</code> 的组合 Widget 。要将 <code>RadioListTile</code> 显示为禁用，请将 <code>null</code> 作为 <code>onChanged</code> 回调传递。</p>
<p>由于 <code>RadioListTile</code> 的整体是交互式的，因此应将自身表示为单个交互式实体。为此，<code>RadioListTile</code> 小部件使用 <code>MergeSemantics</code> 小部件包装其子级。 <code>MergeSemantics</code> 将尝试将其后代语义节点合并到语义树中的一个节点中。 因此，如果 <code>RadioListTile</code> 的任何子级需要其自己的 <code>Semantics</code> 节点，则将引发错误。</p>
<p>例如，您不能将 <code>RichText</code> 小部件嵌套为 <code>RadioListTile</code> 的后代。 <code>RichText</code> 具有一个嵌入式手势识别器，该识别器需要其自己的“语义”节点，这与 <code>RadioListTile</code> 将其所有后代的语义节点合并为一个节点的愿望直接冲突。 因此，可能有必要创建自定义的无线电图块窗口小部件以适应类似的用例。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RadioListTile(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//T类型(泛型)必传参数，此单选按钮表示的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//T类型(泛型)必传参数，一组单选按钮的当前选定值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.groupValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;T&gt;类型必传参数，单选按钮被选择时调用的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选择此单选按钮时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widge类型可选命名参数，要展示的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widge类型可选命名参数，标题下方显示了其他内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.subtitle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列表图块是否旨在显示三行文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isThreeLine = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列表图块是否是垂直密集列表的一部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dense,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在单选按钮的图块另一侧显示的小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.secondary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在activeColor中呈现图标和文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ListTileControlAffinity类型可选命名参数，相对于文本放置控件的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controlAffinity = ListTileControlAffinity.platform,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>ListTileControlAffinity</code> 用来控制文本与单选按钮的相对位置，是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ListTileControlAffinity &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//将控件放在前边缘，将辅助小部件（如果有）放在后边缘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  leading,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//将控件放置在后边缘，将辅助小部件（如果有）放置在前边缘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  trailing,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//以当前平台的典型方式将控件相对于文本放置，然后将辅助小部件放在相对的一侧</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  platform,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>RadioListTile</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Fruits _fruit = Fruits.Banana;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RadioListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: Fruits.Apple,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              groupValue: _fruit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onChanged: (fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  _fruit = fruitValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: Text(<span class="string">"苹果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              subtitle: Text(<span class="string">"是一种水果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              secondary: Icon(Icons.arrow_forward_ios),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              activeColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RadioListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: Fruits.Banana,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              groupValue: _fruit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onChanged: (fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  _fruit = fruitValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: Text(<span class="string">"香蕉"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              subtitle: Text(<span class="string">"是一种水果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              secondary: Icon(Icons.arrow_forward_ios),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              activeColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RadioListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: Fruits.Orange,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              groupValue: _fruit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onChanged: (fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  _fruit = fruitValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: Text(<span class="string">"柑橘"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              subtitle: Text(<span class="string">"是一种水果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              secondary: Icon(Icons.arrow_forward_ios),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              activeColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            )</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>关于其他方面的说明可查看官方说明：<a href="https://api.flutter.dev/flutter/material/RadioListTile-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/material/RadioListTile-class.html</a></p>
<h4 id="三、Checkbox-Widget"><a href="#三、Checkbox-Widget" class="headerlink" title="三、Checkbox Widget"></a>三、Checkbox Widget</h4><p><code>Checkbox</code> 是复选框按钮 Widget 。复选框本身不维护任何状态。相反，当复选框的状态更改时，窗口小部件将调用 <code>onChanged</code> 回调。大多数使用复选框的窗口小部件将侦听 <code>onChanged</code> 回调，并使用新值重建该复选框以更新该复选框的外观。</p>
<p>如果 <code>tristate</code> 为 <code>true</code> ，则该复选框可以选择显示三个值：<code>true</code> ，<code>false</code> 和 <code>null</code> 。当 <code>value</code> 为 <code>null</code> 时，将显示破折号。默认情况下，为 <code>false</code> ，并且复选框的值必须为 <code>true</code> 或 <code>false</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Checkbox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型必传参数，是否选中此复选框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型命名可选参数，如果为true，则复选框的值可以为true，false或null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tristate = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型必传参数，当复选框的值应更改时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中此复选框时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中此复选框时用于选中图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.checkColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，复选框具有输入焦点时的颜色。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，指针悬停在复选框上时的颜色。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型必传参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> currentSelected = <span class="built_in">Set</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"苹果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Checkbox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                value: currentSelected.contains(Fruits.Apple),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onChanged: (<span class="built_in">bool</span> fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Fruits s = fruitValue ? Fruits.Apple : Fruits.NoResult;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">print</span>(s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(s == Fruits.NoResult &amp;&amp; currentSelected.contains(Fruits.Apple)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      currentSelected.remove(Fruits.Apple);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;<span class="keyword">else</span> currentSelected.add(Fruits.Apple);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"香蕉"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Checkbox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                value: currentSelected.contains(Fruits.Banana),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onChanged: (<span class="built_in">bool</span> fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Fruits s = fruitValue ? Fruits.Banana : Fruits.NoResult;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">print</span>(s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(s == Fruits.NoResult &amp;&amp; currentSelected.contains(Fruits.Banana)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      currentSelected.remove(Fruits.Banana);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;<span class="keyword">else</span> currentSelected.add(Fruits.Banana);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"柑橘"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Checkbox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                value: currentSelected.contains(Fruits.Orange),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onChanged: (<span class="built_in">bool</span> fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Fruits s = fruitValue ? Fruits.Orange : Fruits.NoResult;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">print</span>(s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(s == Fruits.NoResult &amp;&amp; currentSelected.contains(Fruits.Orange)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      currentSelected.remove(Fruits.Orange);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;<span class="keyword">else</span> currentSelected.add(Fruits.Orange);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/2020411133.jpg" alt="2020411133" style="zoom:50%;">



<h4 id="四、CheckboxListTile-Widget"><a href="#四、CheckboxListTile-Widget" class="headerlink" title="四、CheckboxListTile Widget"></a>四、CheckboxListTile Widget</h4><p> <code>Checkbox</code> 是单纯的复选框，如果需要显示标签，需要配合其他 Widget 来做展示操作。<code>CheckboxListTile</code> 是自带标签的复选框列表，相当于 <code>Checkbox</code> 和 <code>ListTile</code> 的组合 Widget 。要将 <code>CheckboxListTile</code> 显示为禁用，请将 <code>null</code> 作为 <code>onChanged</code> 回调传递。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CheckboxListTile(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型必传参数，是否选中此复选框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型必传参数，当复选框的值应更改时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中此复选框时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中此复选框时用于选中图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.checkColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，显示的主要部分标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，标题下方显示的其他内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.subtitle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列表图块是否旨在显示三行文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isThreeLine = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列表图块是否是垂直密集列表的一部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dense,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，显示在与复选框相对应的图块的另一侧的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.secondary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在activeColor中呈现图标和文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ListTileControlAffinity类型可选命名参数，相对于文本放置控件的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controlAffinity = ListTileControlAffinity.platform,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> currentSelected = <span class="built_in">Set</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            CheckboxListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"苹果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              subtitle: <span class="keyword">const</span> Text(<span class="string">"这是一种水果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: currentSelected.contains(Fruits.Apple),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onChanged: (<span class="built_in">bool</span> fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Fruits s = fruitValue ? Fruits.Apple : Fruits.NoResult;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">if</span>(s == Fruits.NoResult &amp;&amp; currentSelected.contains(Fruits.Apple)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    currentSelected.remove(Fruits.Apple);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;<span class="keyword">else</span> currentSelected.add(Fruits.Apple);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            CheckboxListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"香蕉"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              subtitle: <span class="keyword">const</span> Text(<span class="string">"这是一种水果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: currentSelected.contains(Fruits.Banana),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onChanged: (<span class="built_in">bool</span> fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Fruits s = fruitValue ? Fruits.Banana : Fruits.NoResult;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">if</span>(s == Fruits.NoResult &amp;&amp; currentSelected.contains(Fruits.Banana)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    currentSelected.remove(Fruits.Banana);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;<span class="keyword">else</span> currentSelected.add(Fruits.Banana);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            CheckboxListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: <span class="keyword">const</span> Text(<span class="string">"柑橘"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              subtitle: <span class="keyword">const</span> Text(<span class="string">"这是一种水果"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              value: currentSelected.contains(Fruits.Orange),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              controlAffinity: ListTileControlAffinity.leading,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onChanged: (<span class="built_in">bool</span> fruitValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Fruits s = fruitValue ? Fruits.Orange : Fruits.NoResult;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">print</span>(s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">if</span>(s == Fruits.NoResult &amp;&amp; currentSelected.contains(Fruits.Orange)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    currentSelected.remove(Fruits.Orange);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;<span class="keyword">else</span> currentSelected.add(Fruits.Orange);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/2020411148.jpg" alt="2020411148" style="zoom:50%;">



<p>前两个 <code>CheckboxListTile</code> 是默认的样式，最后一个是改变了位置参数的样式。</p>
<h4 id="五、Switch-Widget"><a href="#五、Switch-Widget" class="headerlink" title="五、Switch Widget"></a>五、Switch Widget</h4><p><code>Switch</code> 是用来设置开或关闭状态的 Widget 。<code>Switch</code> 本身不保持任何状态。 相反，当开关的状态更改时，小部件将调用 <code>onChanged</code> 回调。 大多数使用开关的小部件都会侦听 <code>onChanged</code> 回调，并使用新值重建开关以更新开关的外观。如果 <code>onChanged</code> 回调为 <code>null</code> ，则该开关将被禁用（它不会响应输入）。 默认情况下，禁用的开关的拇指和轨迹显示为灰色阴影。 禁用开关的默认外观可以用 <code>inactiveThumbColor</code> 和 <code>inactiveTrackColor</code> 覆盖。<br>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Switch(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型必传参数，此开关是打开还是关闭</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型必传参数，当用户打开或关闭开关时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，开启此开关时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，此开关打开时在赛道上使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeTrackColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，关闭此开关时在拇指上使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inactiveThumbColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，关闭此开关时在轨道上使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inactiveTrackColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageProvider类型可选命名参数，开关打开时在此开关的拇指上使用的图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeThumbImage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageProvider类型可选命名参数，开关关闭时在此开关的拇指上使用的图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inactiveThumbImage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定拖动开始行为的处理方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，具有输入焦点时按钮的颜色。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，指针悬停在按钮上时的颜色。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此窗口小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isOpen = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Switch(						<span class="comment">//Switch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: isOpen,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onChanged: (<span class="built_in">bool</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              isOpen = !value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          activeColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          activeTrackColor: Colors.lightBlue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          inactiveThumbColor: Colors.deepPurple,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          inactiveTrackColor: Colors.greenAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/2020411223.jpg" alt="2020411223" style="zoom:50%;">



<h4 id="六、SwitchListTile-Widget"><a href="#六、SwitchListTile-Widget" class="headerlink" title="六、SwitchListTile Widget"></a>六、SwitchListTile Widget</h4><p><code>SwitchListTile</code> 带标签的开关 Widget 。整个列表图块是交互式的：点击图块中的任何位置均可切换开关。 轻击并拖动 <code>Switch</code> 也会触发 <code>onChanged</code> 回调。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SwitchListTile(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型必传参数，此开关是打开还是关闭</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型必传参数，当用户打开或关闭开关时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，开启此开关时使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，此开关打开时在赛道上使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeTrackColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，关闭此开关时在拇指上使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inactiveThumbColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，关闭此开关时在轨道上使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inactiveTrackColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageProvider类型可选命名参数，开关打开时在此开关的拇指上使用的图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeThumbImage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageProvider类型可选命名参数，开关关闭时在此开关的拇指上使用的图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inactiveThumbImage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，主要显示的标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，标题下方显示的其他内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.subtitle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列表图块是否旨在显示三行文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isThreeLine = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此列表图块是否是垂直密集列表的一部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dense,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.contentPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，显示在与开关相对应的图块的另一侧的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.secondary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在activeColor中呈现图标和文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isOpen = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: SwitchListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"开关"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          subtitle: Text(<span class="string">"是否打开开关"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          contentPadding: EdgeInsets.all(<span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: isOpen,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onChanged: (<span class="built_in">bool</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              isOpen = !value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          activeColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          activeTrackColor: Colors.lightBlue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          inactiveThumbColor: Colors.deepPurple,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          inactiveTrackColor: Colors.greenAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/2020411233.jpg" alt="2020411233" style="zoom:50%;">



<p>更多可查看官方文档：<a href="https://api.flutter.dev/flutter/material/SwitchListTile-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/material/SwitchListTile-class.html</a></p>
<h4 id="七、Slider-Widget"><a href="#七、Slider-Widget" class="headerlink" title="七、Slider Widget"></a>七、Slider Widget</h4><p><code>Slider</code> 是一个滑块 Widget ，用于从一系列值中进行选择。<code>Slider</code> 可用于从一组连续值或一组离散值中进行选择。默认值是使用从最小到最大的连续值范围。要使用离散值，请使用非空值进行除法，该值指示离散间隔的数量。例如，如果 <code>min</code> 为 0.0，<code>max</code> 为 50.0，除法为 5，则滑块可以采用离散值 0.0、10.0、20.0、30.0、40.0 和50.0 。</p>
<p>如果 <code>onChanged</code> 为 <code>null</code> 或 <code>min..max</code>给定的范围为空（即，如果 <code>min</code> 等于 <code>max</code> ），则将禁用滑块。</p>
<p>滑块小部件本身不保持任何状态。 相反，当滑块的状态更改时，小部件将调用 <code>onChanged</code> 回调。 大多数使用滑块的小部件都会侦听 <code>onChanged</code> 回调，并使用新值重建滑块以更新滑块的外观。 要知道该值何时开始更改或何时完成更改，请设置可选的回调 <code>onChangeStart</code> 和/或onChangeEnd。</p>
<p>默认情况下，<code>Slider</code> 将在垂直居中的情况下尽可能宽。 当给出无限制的约束时，它将尝试使轨道宽 144 像素（每边都有空白），并将垂直收缩包装 。构造方法有如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建默认滑块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Slider(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，该滑块当前选择的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;double&gt;类型必传参数，当用户通过拖动为滑块选择新值时在拖动期间调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;double&gt;类型可选命名参数，当用户开始为滑块选择新值时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onChangeStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;double&gt;类型可选命名参数，当用户完成选择滑块的新值时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onChangeEnd,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，用户可以选择的最小值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.min = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，用户可以选择的最大值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.max = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，离散分区的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.divisions,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，当滑块处于活动状态时在滑块上方显示的标签，设置离散值时显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于滑块轨道的活动部分的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.activeColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，滑块轨道的非活动部分的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inactiveColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SemanticFormatterCallback类型可选命名参数，用于从滑块值创建语义值的回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticFormatterCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果目标平台是iOS，则创建一个CupertinoSlider，否则创建一个Material Design滑块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Slider.adaptive(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//double类型必传参数，该滑块当前选择的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//ValueChanged&lt;double&gt;类型必传参数，当用户通过拖动为滑块选择新值时在拖动期间调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">   	<span class="comment">//省略与Slider相同部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> currentValue = <span class="number">5.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Slider(					<span class="comment">//Slider</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          max: <span class="number">50.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          min: <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          label: currentValue.toString(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          activeColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: currentValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onChanged: (<span class="built_in">double</span> value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              currentValue = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onChangeStart: (<span class="built_in">double</span> startValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">print</span>(<span class="string">"StartValue:<span class="subst">$startValue</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onChangeEnd: (<span class="built_in">double</span> endValue)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">print</span>(<span class="string">"EndValue:<span class="subst">$endValue</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          divisions: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/2020411258.jpg" alt="2020411258" style="zoom:50%;">



<h4 id="八、Dialog-Widget"><a href="#八、Dialog-Widget" class="headerlink" title="八、Dialog Widget"></a>八、Dialog Widget</h4><p><code>Dialog</code> 是一个对话框 Widget 。该对话框小部件对对话框的内容没有任何意见。与其直接使用此小部件，不如考虑使用 <code>AlertDialog</code> 或 <code>SimpleDialog</code> ，它们实现特定种类的材料设计对话框。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Dialog(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，对话框背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，此对话框的Z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Duration类型可选命名参数，当系统键盘侵入对话框所在的空间时显示的动画持续时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.insetAnimationDuration = <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">100</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Curve类型可选命名参数，当系统键盘进入对话框所在的空间时，用于显示动画的曲线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.insetAnimationCurve = Curves.decelerate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，此对话框边框的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，树中此窗口小部件下方的窗口小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> currentValue = <span class="number">5.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Dialog(				<span class="comment">//Dialog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"提示信息"</span>, style: TextStyle(fontSize: <span class="number">30</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundColor: Colors.lightBlue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/202041115.jpg" alt="202041115" style="zoom:50%;">

<p>可以直接调用 Flutter 中提供的 <code>showDialog()</code> 函数显示对话框。该对话框带有模态屏障颜色和模态屏障行为(通过轻按屏障可关闭对话框)。此函数需要一个构建器，该构建器通常会构建一个 <code>Dialog</code> 小部件。 对话框下方的内容通过 <code>ModalBarrier</code> 变暗。 构建器返回的窗口小部件与最初调用 <code>showDialog</code> 的位置不共享上下文。 如果对话框需要动态更新，请使用 <code>StatefulBuilder</code> 或自定义 <code>StatefulWidget</code> 。</p>
<p><code>child</code> 参数已弃用，应将其替换为 <code>builder</code> 。</p>
<p><code>context</code> 参数用于查找对话框的“导航器”和“主题”。 仅在调用该方法时使用。 在关闭对话框之前，可以从树中安全删除其对应的小部件。</p>
<p><code>useRootNavigator</code> 参数用于确定是否将对话框推到距给定上下文最远或最接近给定上下文的 <code>Navigator</code> 。 默认情况下，<code>useRootNavigator</code> 为 <code>true</code> ，并且由此方法创建的对话框路由被推送到根导航器。</p>
<p>如果应用程序具有多个 <code>Navigator</code>对象，则可能有必要调用 <code>Navigator.of(context, rootNavigator:true).pop(result)</code>关闭对话框，而不仅仅是 <code>Navigator.pop(context, result)</code>。</p>
<p>返回一个 <code>Future</code>，它解析为关闭对话框时传递给 <code>Navigator.pop</code> 的值（如果有）。</p>
<p>该函数的定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T&gt; showDialog&lt;T&gt;(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> BuildContext context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> barrierDismissible = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@Deprecated</span>(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'Instead of using the "child" argument, return the child from a closure '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'provided to the "builder" argument. This will ensure that the BuildContext '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'is appropriate for widgets built in the dialog. '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'This feature was deprecated after v0.2.3.'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  WidgetBuilder builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> useRootNavigator = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> currentValue = <span class="number">5.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"显示Dialog"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            onPressed: ()=&gt;showDialog(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              context: context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              builder: (ctx)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    mainAxisSize: MainAxisSize.min,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        child: Text(<span class="string">"确定"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        onPressed: ()=&gt; Navigator.pop(context),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/202041304.jpg" alt="202041304" style="zoom:50%;">



<h4 id="九、AlertDialog-Widget"><a href="#九、AlertDialog-Widget" class="headerlink" title="九、AlertDialog Widget"></a>九、AlertDialog Widget</h4><p><code>AlertDialog</code> 是一个警告对话框 Widget 。警报对话框通知用户需要确认的情况。警报对话框具有可选的标题和可选的操作列表。标题显示在内容上方，动作显示在内容下方。</p>
<p>如果内容太大而无法垂直显示在屏幕上，则对话框将显示标题和操作，并让内容溢出，这是很少需要的。 考虑将滚动小部件用于内容，例如 <code>SingleChildScrollView</code> ，以避免溢出。 （但是，请注意，由于 <code>AlertDialog</code> 尝试使用其子项的固有尺寸来调整自身大小，因此使用惰性视口的 <code>ListView</code> ，<code>GridView</code> 和 <code>CustomScrollView</code> 之类的小部件将无法工作。如果出现问题，请考虑直接使用 <code>Dialog</code> 。 ）</p>
<p>对于为用户提供多个选项之间的选择的对话框，请考虑使用 <code>SimpleDialog</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AlertDialog(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，标题Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，围绕标题填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.titlePadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，此AlertDialog标题中的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.titleTextStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，对话框的（可选）内容以较浅的字体显示在对话框的中央</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.content,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，围绕内容填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.contentPadding = <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">24.0</span>, <span class="number">20.0</span>, <span class="number">24.0</span>, <span class="number">24.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，此AlertDialog内容中的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.contentTextStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，对话框底部显示的（可选）操作集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.actions,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，此对话框表面的背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，此对话框的Z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，辅助功能框架用于在对话框打开和关闭时宣布屏幕转换的对话框的语义标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，此对话框边框的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> currentValue = <span class="number">5.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: AlertDialog(					<span class="comment">//AlertDialog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"是否继续？"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          content: Text(<span class="string">"是否进行下一步操作？确定继续。"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          actions: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"确定"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"确定"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"取消"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"取消"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/2020241127.jpg" alt="2020241127" style="zoom:50%;">



<h4 id="十、SimpleDialog-Widget"><a href="#十、SimpleDialog-Widget" class="headerlink" title="十、SimpleDialog Widget"></a>十、SimpleDialog Widget</h4><p><code>SimpleDialog</code> 是一个简单的对话框 Widget ，为用户提供了多个选项之间的选择。 一个简单的对话框有一个可选标题，显示在选项上方。选项通常使用 <code>SimpleDialogOption</code> 小部件表示。 如果使用其他小部件，请参 阅<code>contentPadding</code> 以获取有关获得 Material Design 期望的间距的约定的注释。</p>
<p>对于通知用户有关情况的对话框，请考虑使用 <code>AlertDialog</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleDialog(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，对话框的（可选）标题以大字体显示在对话框顶部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，在标题周围填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.titlePadding = <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">24.0</span>, <span class="number">24.0</span>, <span class="number">24.0</span>, <span class="number">0.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，对话框的（可选）内容显示在标题下方的SingleChildScrollView中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，围绕内容填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.contentPadding = <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">0.0</span>, <span class="number">12.0</span>, <span class="number">0.0</span>, <span class="number">16.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，此对话框表面的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，此对话框的Z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，辅助功能框架用于在对话框打开和关闭时宣布屏幕转换的对话框的语义标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，此对话框边框的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>SimpleDialogOption</code> 是在 <code>SimpleDialog</code> 中使用的选项 Widget 。<code>SimpleDialog</code> 为用户提供了多个选项之间的选择。该小部件通常用于表示每个选项。如果用户选择此选项，则小部件将调用 <code>onPressed</code> 回调，该回调通常使用  <code>Navigator.pop</code> 关闭对话框。</p>
<p><code>SimpleDialogOption</code> 上的填充配置为与默认的 <code>SimpleDialog.contentPadding</code> 结合使用，以便每个选项在垂直方向上彼此之间的距离为 8 像素，对话框标题和第一个选项之间的距离为 20 像素，最后一个选项之间的距离为 24 像素选项和对话框底部。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleDialogOption(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，选择此选项时调用的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，树中此窗口小部件下方的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>SimpleDialog</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> currentValue = <span class="number">5.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: SimpleDialog(      <span class="comment">//SimpleDialog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"选项"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SimpleDialogOption(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"点击选择1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SimpleDialogOption(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"点击选择2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SimpleDialogOption(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"点击关闭"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/202041147.jpg" alt="202041147" style="zoom:50%;">

<p>当 <code>SimpleDialog</code> 的高度超过屏幕可用空间时， <code>SimpleDialog</code> 可以上下滚动操作。</p>
<h4 id="十一、AboutDialog-Widget"><a href="#十一、AboutDialog-Widget" class="headerlink" title="十一、AboutDialog Widget"></a>十一、AboutDialog Widget</h4><p><code>AboutDialog</code> 是一个关于框。 这是一个对话框，其中包含应用程序的图标，名称，版本号和版权，以及用于显示该应用程序使用的软件的许可证的按钮。要显示 <code>AboutDialog</code> ，请使用 <code>showAboutDialog</code> 。</p>
<p>如果应用程序具有抽屉，则 <code>AboutListTile</code> 小部件可使显示关于对话框的过程更简单。</p>
<p><code>showAboutDialog</code> 显示的 <code>AboutDialog</code> 包含一个调用 <code>showLicensePage</code> 的按钮。</p>
<p><code>LicensePage</code> 上显示的许可证是由 LicenseRegistry API 返回的许可证，可用于将更多许可证添加到列表中。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AboutDialog(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此应用程序的名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationName,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，此应用程序版本的版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationVersion,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在应用程序名称旁边显示的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，以小写字母显示的字符串，许可、声明等信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.applicationLegalese,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，在名称，版本和legalese之后添加到对话框的小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: AboutDialog(					<span class="comment">//AboutDialog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        applicationName: <span class="string">"名称"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        applicationIcon: Icon(Icons.<span class="built_in">print</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        applicationVersion: <span class="string">"1.0.0"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        applicationLegalese: <span class="string">"说明、许可等信息"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"其他Widget1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"其他Widget2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/1639ba65/202042414.jpg" alt="202042414" style="zoom:50%;">



<p>也可以直接调用 <code>showAboutDialog</code> 方法展示关于框。方法定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> showAboutDialog(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	<span class="comment">//BuildContext类型必传参数，上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> BuildContext context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，应用名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> applicationName,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，应用版本号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> applicationVersion,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，应用图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget applicationIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，以小写字母显示的字符串，许可、声明等信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> applicationLegalese,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，在名称，版本和legalese之后添加到对话框的小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，参数确保在设置为true时，根导航器用于显示AboutDialog。如果需要在所有其他</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//内容上方显示模式AboutDialog，但调用者在另一个Navigator内，则这很有用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> useRootNavigator = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"AboutDialog"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()=&gt; showAboutDialog(			<span class="comment">//showAboutDialog</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          context: context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          applicationName: <span class="string">"名称"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          applicationVersion: <span class="string">"1.0.0"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          applicationLegalese: <span class="string">"说明、许可等信息"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          applicationIcon: Icon(Icons.<span class="built_in">print</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"其他Widget1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"其他Widget2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>Radio</tag>
        <tag>Slider</tag>
        <tag>Switch</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十三)</title>
    <url>/content/ec7a556a.html</url>
    <content><![CDATA[<h4 id="一、InputChip-Widget"><a href="#一、InputChip-Widget" class="headerlink" title="一、InputChip Widget"></a>一、InputChip Widget</h4><p><code>InputChip</code> 与 <code>Chip</code> 类似，多了一些其他的点击、选择、标记功能。构造方法如下：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InputChip(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在InputChip的label前显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，InputChip的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，InputChip的label的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，InputChip内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否处于选中状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否为可用状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isEnabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型可选命名参数，当InputChip在选定状态和取消选定状态之间切换时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，设置onDeleted时显示的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，用户点击deleteIcon删除InputChip时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onDeleted,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，删除图标的颜色。默认值基于环境IconTheme.color</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteIconColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，该信息用于InputChip的删除按钮工具提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteButtonTooltipMessage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，点击时的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，点击时相对于其父对象应用于InputChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.pressElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，被禁用时的背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中时的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于InputChip主体区域（标签和化身所在的地方）的工具提示字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，InputChip的线框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，内容将被裁剪（或不裁剪）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于未选中的已启用InputChip背景的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，InputChip内容和外部形状之间的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父级应用于InputChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0时InputChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0且已选择时InputChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedShadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，选中时是否显示对号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showCheckmark,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，可见复选标记时InputChip的复选标记的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.checkmarkColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，当选定属性为true时，在化身上绘制的半透明高光的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatarBorder = <span class="keyword">const</span> CircleBorder(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: InputChip(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          avatar: CircleAvatar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"M"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          label: Text(<span class="string">"This is Text"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          selected: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          isEnabled: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onSelected: (<span class="built_in">bool</span> isOnSelected)=&gt;<span class="built_in">print</span>(isOnSelected)</span></pre></td></tr><tr><td class="code"><pre><span class="line">          deleteIcon: Icon(Icons.delete),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onDeleted: ()=&gt;<span class="built_in">print</span>(<span class="string">"删除"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          deleteIconColor: Colors.orange,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pressElevation: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          selectedColor: Colors.lightBlueAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          tooltip: <span class="string">"tip"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundColor: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          showCheckmark: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          checkmarkColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/ec7a556a/2020331105.jpg" alt="2020331105" style="zoom:50%;">



<h4 id="二、ChoiceChip-Widget"><a href="#二、ChoiceChip-Widget" class="headerlink" title="二、ChoiceChip Widget"></a>二、ChoiceChip Widget</h4><p><code>ChoiceChip</code> 代表集合中的单个选择，与 <code>InputChip</code> 是类似的，只介绍下构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ChoiceChip(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在ChoiceChip的label前显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，ChoiceChip的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，ChoiceChip的label的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，ChoiceChip内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型可选命名参数，当ChoiceChip在选定状态和取消选定状态之间切换时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，点击时相对于其父对象应用于ChoiceChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.pressElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型必传参数，是否处于选中状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.selected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中时的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，被禁用时的背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于ChoiceChip主体区域（标签和化身所在的地方）的工具提示字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，ChoiceChip的线框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，内容将被裁剪（或不裁剪）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于未选中的已启用ChoiceChip背景的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，ChoiceChip内容和外部形状之间的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父级应用于ChoiceChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0时ChoiceChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0且已选择时ChoiceChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedShadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，当选定属性为true时，在化身上绘制的半透明高光的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatarBorder = <span class="keyword">const</span> CircleBorder(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<h4 id="三、FilterChip-Widget"><a href="#三、FilterChip-Widget" class="headerlink" title="三、FilterChip Widget"></a>三、FilterChip Widget</h4><p><code>FilterChip</code> 使用标签或描述性单词作为筛选内容的方法。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FilterChip(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在FilterChip的label前显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，FilterChip的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，FilterChip的label的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，FilterChip内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否处于选中状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型可选命名参数，当FilterChip在选定状态和取消选定状态之间切换时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，点击时相对于其父对象应用于FilterChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.pressElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，被禁用时的背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中时的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于FilterChip主体区域（标签和化身所在的地方）的工具提示字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，FilterChip的线框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，内容将被裁剪（或不裁剪）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于未选中的已启用FilterChip背景的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，FilterChip内容和外部形状之间的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父级应用于FilterChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0时FilterChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0且已选择时FilterChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedShadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，选中时是否显示对号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showCheckmark,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，可见复选标记时FilterChip的复选标记的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.checkmarkColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，当选定属性为true时，在化身上绘制的半透明高光的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatarBorder = <span class="keyword">const</span> CircleBorder(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<h4 id="四、ActionChip-Widget"><a href="#四、ActionChip-Widget" class="headerlink" title="四、ActionChip Widget"></a>四、ActionChip Widget</h4><p><code>ActionChip</code> 是一组选项，可触发与主要内容相关的动作。 <code>ActionChip</code> 应在 UI 中动态和上下文地显示。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ActionChip(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在ActionChip的label前显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，ActionChip的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，ActionChip的label的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，ActionChip内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型必传参数，当用户点击ActionChip时调用的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，点击时相对于其父对象应用于ActionChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.pressElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于ActionChip主体区域（标签和化身所在的地方）的工具提示字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，ActionChip的线框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，内容将被裁剪（或不裁剪）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于未选中的已启用ActionChip背景的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，ActionChip内容和外部形状之间的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父级应用于ActionChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0时ActionChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<h4 id="五、RawChip-Widget"><a href="#五、RawChip-Widget" class="headerlink" title="五、RawChip Widget"></a>五、RawChip Widget</h4><p><code>RawChip</code> 是所有 <code>Chip</code> 小部件类型汇总的基础。 通常不会直接创建它，而是使用适合该用例的其他 <code>Chip</code> 类型之一：</p>
<p><code>InputChip</code> 以紧凑的形式表示一条复杂的信息，例如实体（人，地方或事物）或对话文本。</p>
<p><code>ChoiceChip</code> 允许从一组选项中进行单个选择。</p>
<p><code>FilterChip</code> 一种使用标签或描述性词作为过滤内容的芯片。</p>
<p><code>ActionChips</code> 显示一组与主要内容有关的动作。</p>
<p>通常仅在要创建自己的自定义 <code>Chip</code> 类型时才使用原始 <code>RawChip</code> 。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RawChip(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在RawChip的label前显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，RawChip的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，RawChip的label的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，RawChip内容和外部形状之间的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，RawChip内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，设置onDeleted时显示的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget deleteIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，用户点击deleteIcon删除RawChip时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onDeleted,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，删除图标的颜色。默认值基于环境IconTheme.color</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteIconColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，该信息用于RawChip的删除按钮工具提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteButtonTooltipMessage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，点击时的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;bool&gt;类型可选命名参数，当RawChip在选定状态和取消选定状态之间切换时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，点击时相对于其父对象应用于RawChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.pressElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果设置，则表明如果所有抽头回调(onSelected，onPressed)均为空，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则应禁用RawChip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tapEnabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否处于选中状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否为可用状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isEnabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，被禁用时的背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选中时的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于RawChip主体区域（标签和化身所在的地方）的工具提示字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，RawChip的线框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，内容将被裁剪（或不裁剪）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于未选中的已启用RawChip背景的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父级应用于RawChip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0时RawChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0且已选择时RawChip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedShadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，选中时是否显示对号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showCheckmark = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，可见复选标记时RawChip的复选标记的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.checkmarkColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，当选定属性为true时，在化身上绘制的半透明高光的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatarBorder = <span class="keyword">const</span> CircleBorder(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<h4 id="六、Tooltip-Widget"><a href="#六、Tooltip-Widget" class="headerlink" title="六、Tooltip Widget"></a>六、Tooltip Widget</h4><p><code>Tooltip</code> 用于显示提示性信息的 Widget 。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Tooltip(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型必传参数，显示的提示文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.message,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，提示框的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，提示框的内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，提示框的外边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.margin,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，子Widget和提示框间的垂直间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.verticalOffset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，提示框是否默认显示在子Widget下方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.preferBelow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，提示的消息是否应从语义树中排除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.excludeFromSemantics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Decoration类型可选命名参数，指定工具提示的形状和背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decoration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，提示消息的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Duration类型可选命名参数，在显示工具提示之前，指针必须悬停在工具提示的小部件上的时间长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.waitDuration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Duration类型可选命名参数，释放长按后显示工具提示的时间长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showDuration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，添加提示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Tooltip(							<span class="comment">//Tooltip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          message: <span class="string">"tip Message"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          padding: EdgeInsets.all(<span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          preferBelow: <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          decoration: BoxDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.lightBlue</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          verticalOffset: <span class="number">30</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          textStyle: TextStyle(fontSize: <span class="number">20</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">           child: Container(child: Text(<span class="string">"长按显示提示"</span>), color: Colors.red,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/ec7a556a/2020331206.jpg" alt="2020331206" style="zoom:50%;">



<h4 id="七、Opacity-Widget"><a href="#七、Opacity-Widget" class="headerlink" title="七、Opacity Widget"></a>七、Opacity Widget</h4><p><code>Opacity</code> 是控制子 Widget 透明度的 Widget 。此类将其子级绘制到中间缓冲区中，然后将子级混合回到部分透明的场景中。对于除 0.0 和 1.0 之外的不透明度值，此类相对昂贵，因为它需要将子级绘制到中间缓冲区中。 对于值 0.0 ，根本不会绘制该子项。 对于值 1.0 ，将立即绘制没有中间缓冲区的子对象。这比按需在树中添加和移除子部件更有效。对不透明度窗口小部件进行动画处理会直接导致该窗口小部件（可能还有其子树）重建每个帧，这不是很有效。考虑改用 <code>AnimatedOpacity</code> 。如果仅需要使用不透明度介于0.0到1.0之间的单个图像或颜色进行合成，则直接使用它们而不使用Opacity小部件会更快。</p>
<p>例如，<code>Container(color: Color.fromRGBO(255,0,0,0.5))</code> 比 <code>Opacity(opacity: 0.5, child: Container（color: Colors.red))</code> 快得多。</p>
<p>直接使用不透明性绘制图像或颜色要比在其上使用不透明性更快，因为不透明性可以将不透明性应用于一组小部件，因此将使用昂贵的屏幕外缓冲区。将内容绘制到屏幕外缓冲区中也可能会触发渲染目标切换，并且这种切换在较旧的 GPU中 特别慢。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Opacity(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，不透明度值，取值0.0到1.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.opacity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否始终包含孩子的语义信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alwaysIncludeSemantics = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Opacity(					<span class="comment">//Opacity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          opacity: <span class="number">0.8</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Opacity"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="八、Visibility-Widget"><a href="#八、Visibility-Widget" class="headerlink" title="八、Visibility Widget"></a>八、Visibility Widget</h4><p><code>Visibility</code> 用来控制显示还是隐藏子 Widget 。默认情况下，<code>visible</code> 属性控制子树中是否包含子项。 当它不可见时，将包括替换子项（通常为零尺寸的框）。可以使用各种标志来精确调整孩子的隐藏方式。 （不建议动态更改标志，因为这可能会导致子树重建，并且子树中的任何状态都将被丢弃。通常，仅可见标志会动态更改。）</p>
<p>隐藏该孩子不需要使用此小部件。隐藏子项的最简单方法就是不包含子项，或者如果必须给子项（例如，因为父项是 <code>StatelessWidget</code> ），则使用 <code>SizedBox.shrink</code> 代替要包含的子项。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Visibility(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，当visible为false时，使用的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.replacement = <span class="keyword">const</span> SizedBox.shrink(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.visible = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，在子子树不可见时是否维护其State对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maintainState = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，当子子树不可见时是否维护动画</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maintainAnimation = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否为小部件原本保留的空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maintainSize = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，隐藏小部件时是否维持其语义（例如，可访问性）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maintainSemantics = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，隐藏时是否允许小部件交互</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maintainInteractivity = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Visibility(					<span class="comment">//Visibility</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Visibility"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          visible: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="九、ClipOval-Widget"><a href="#九、ClipOval-Widget" class="headerlink" title="九、ClipOval Widget"></a>九、ClipOval Widget</h4><p><code>ClipOval</code> 是一个使用椭圆形裁剪其子 Widget 的 Widget 。默认情况下，将与轴对齐的椭圆形刻入其布局尺寸，并防止其子代在该椭圆形外部绘画，但是可以使用自定义的裁剪器自定义剪贴椭圆形的大小和位置。默认情况  <code>ClipOval</code> 裁剪的是一个在其容器内的内切圆，可以通过改变外层容器的宽高来改变圆的形状。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ClipOval(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CustomClipper&lt;Rect&gt;类型可选命名参数，如果非空，则使用自定义剪裁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipper,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，控制如何裁剪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.antiAlias,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>基本使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ClipOval(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/ec7a556a/2020331436.jpg" alt="2020331436" style="zoom:50%;">



<p>如果需要自定义剪裁界面，设置 <code>clipper</code> 属性即可。<code>clipper</code> 是 <code>CustomClipper&lt;Rect&gt;</code> 类型，用于设置定义剪裁界面。其为一个抽象类，其原型定义为 <code>CustomClipper&lt;T&gt;</code> 。需要剪裁的 Widget 也都使用到了此类，如  <code>ClipRect</code> 、 <code>ClipPath</code> 、 <code>ClipRRect</code> ，后面会对这些进行讲解。<code>T</code> 是泛型设置，具体使用什么需要根据每个剪裁 Widget 的具体说明来设置。在 <code>ClipOval</code> 中，委托返回一个矩形，该矩形描述椭圆形的与轴对齐的边界框。 椭圆的轴本身也将与轴对齐。如果 <code>Clipper</code> 委托为 <code>null</code> ，则椭圆将使用小部件的边界框（渲染对象的布局尺寸）代替 。由于 <code>CustomClipper&lt;T&gt;</code> 是一个抽象基类，需要自定义类并继承它来具体实现。 从 <code>CustomClipper</code> 继承的类需要重写两个方法分别为：<code>T getClip(Size size)</code> 和 <code>bool shouldReclip(CustomClipper oldClipper)</code> 。<code>getClip</code> 方法，每当需要更新自定义剪裁时会调用。<code>shouldReckip</code> 当提供类的新实例时，将调用 <code>shouldReclip</code> 方法，以检查新实例是否实际代表其他信息。</p>
<p>此例中，需要泛型为 <code>Rect</code> ，<code>Rect</code> 用于定义一个矩形，其坐标相对于给定的原点。其有以下构造方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过设置左、上、右、下边缘创建一个矩形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rect.fromLTRB(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形左边缘与x轴的偏移量，即距离容器左侧的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.left,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形的上边缘与y轴的偏移量，即距离容器顶部的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.top,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形的右边缘与x轴的偏移量，即距离容器右侧的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.right,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，该矩形底边与y轴的偏移量，即距离容器底部的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottom</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过设置左、上边缘和宽度、高度来创建一个矩形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rect.fromLTWH(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形左边缘与x轴的偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> left,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形的上边缘与y轴的偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> top,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形的左右边缘之间的距离，即宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形的上下边缘之间的距离，即高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> height</span></pre></td></tr><tr><td class="code"><pre><span class="line">) : <span class="keyword">this</span>.fromLTRB(left, top, left + width, top + height);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                                        </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个以给定圆为界的矩形                                                                                         </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Rect.fromCircle(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型可选命名参数，在此矩形的左右边缘与上边缘和下边缘之间的中间点的偏移量，即中心点的偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Offset center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，圆半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> radius </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) : <span class="keyword">this</span>.fromCenter(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  center: center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  width: radius * <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  height: radius * <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                                          </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//从其中心点，宽度和高度构造一个矩形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Rect.fromCenter(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型可选命名参数，在此矩形的左右边缘与上边缘和下边缘之间的中间点的偏移量，即中心点的偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Offset center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形的左右边缘之间的距离，即宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，此矩形的上下边缘之间的距离，即高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> height </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) : <span class="keyword">this</span>.fromLTRB(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  center.dx - width / <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  center.dy - height / <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  center.dx + width / <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  center.dy + height / <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                                                                          </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个最小的矩形，将给定的偏移量包围起来，将其作为原点的向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Rect.fromPoints(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//相对于原点(左上角)的偏移点a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Offset a,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">///<span class="markdown">相对于原点(左上角)的偏移点b</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Offset b</span></pre></td></tr><tr><td class="code"><pre><span class="line">) : <span class="keyword">this</span>.fromLTRB(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  math.min(a.dx, b.dx),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  math.min(a.dy, b.dy),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  math.max(a.dx, b.dx),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  math.max(a.dy, b.dy),</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure>

<p><code>ClipOval</code> 自定义剪裁方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ClipOval(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          clipper: MyCustomClipper(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomClipper</span> <span class="keyword">extends</span> <span class="title">CustomClipper</span>&lt;<span class="title">Rect</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  getClip(Size size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Rect rect = Rect.fromLTWH(size.width/<span class="number">2</span>, size.height/<span class="number">2</span>, size.width/<span class="number">2</span>, size.height/<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> rect;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> shouldReclip(CustomClipper oldClipper) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述的代码自定义了一个 <code>Rect</code> 的裁剪区域，为 <code>Container</code> 容器四分之一的矩形，位于右下角的位置。效果如下：</p>
<img src="/content/ec7a556a/2020331601.jpg" alt="2020331601" style="zoom:50%;">



<p>如果想显示四分之一的椭圆，可以通过如下设置：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomClipper</span> <span class="keyword">extends</span> <span class="title">CustomClipper</span>&lt;<span class="title">Rect</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  getClip(Size size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Rect rect = Rect.fromLTWH(-size.width, -size.height, size.width*<span class="number">2</span>, size.height*<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> rect;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> shouldReclip(CustomClipper oldClipper) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<img src="/content/ec7a556a/2020331614.jpg" alt="2020331614" style="zoom:50%;">





<h4 id="十、ClipRect-Widget"><a href="#十、ClipRect-Widget" class="headerlink" title="十、ClipRect Widget"></a>十、ClipRect Widget</h4><p><code>ClipRect</code> 是一个使用矩形裁剪其子 Widget 的 Widget 。默认情况下，<code>ClipRect</code> 阻止其子代在其边界外绘画，但是可以使用自定义裁剪器自定义裁剪矩形的大小和位置。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ClipRect(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CustomClipper&lt;Rect&gt;类型可选命名参数，如果非空，则使用自定义剪裁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipper,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，控制如何裁剪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.hardEdge,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>基本使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: ClipRect(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Align(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          widthFactor: <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          heightFactor: <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: Alignment.topLeft,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/ec7a556a/2020331700.jpg" alt="2020331700" style="zoom:50%;">



<h4 id="十一、ClipRRect-Widget"><a href="#十一、ClipRRect-Widget" class="headerlink" title="十一、ClipRRect Widget"></a>十一、ClipRRect Widget</h4><p><code>ClipRRect</code> 是一个使用圆角矩形裁剪其子 Widget 的 Widget 。默认情况下，<code>ClipRRect</code> 使用其自身的边界作为剪辑的基本矩形，但是可以使用自定义剪辑器自定义剪辑的大小和位置。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ClipRRect(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderRadius类型可选命名参数，圆角的边界半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.borderRadius = BorderRadius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CustomClipper&lt;RRect&gt;类型可选命名参数，如果非空，则使用自定义剪裁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipper,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，控制如何裁剪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.antiAlias,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ClipRRect(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          borderRadius: BorderRadius.all(Radius.circular(<span class="number">150</span>)), </span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<img src="/content/ec7a556a/2020331708.jpg" alt="2020331708" style="zoom:50%;">



<h4 id="十二、ClipPath-Widget"><a href="#十二、ClipPath-Widget" class="headerlink" title="十二、ClipPath Widget"></a>十二、ClipPath Widget</h4><p><code>ClipPath</code> 是一个使用路径裁剪其子 Widget 的 Widget 。每当要绘制小部件时，都会在委托上调用回调。 回调函数返回一个路径，该小部件可防止孩子在路径外绘制。剪切路径很昂贵。 某些形状具有更优化的小部件：</p>
<p>要剪辑到矩形，请考虑使用 <code>ClipRect</code> 。</p>
<p>要剪辑为椭圆形或圆形，请考虑 <code>ClipOval</code> 。</p>
<p>要裁剪到圆角矩形，请考虑 <code>ClipRRect</code>。</p>
<p>若要裁剪到特定的 <code>ShapeBorder</code> ，请考虑使用 <code>ClipPath.shape</code> 静态方法或 <code>ShapeBorderClipper</code> 自定义裁剪器类 。如果不自定义剪裁方式，则没有任何剪裁效果。</p>
<p><code>ClipPath</code> 构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ClipPath(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CustomClipper&lt;Path&gt;类型可选命名参数，如果非空，则使用自定义剪裁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipper,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，控制如何裁剪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.antiAlias,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>自定义裁剪需要的泛型为 <code>Path</code> ，是平面的复杂的一维子集。由当前点和多条路径组成。子路径由各种类型的线段组成，例如线，弧或贝塞尔曲线。子路径可以是开放的或封闭的，并且可以自相交。封闭的子路径基于当 前<code>fillType</code> 封闭平面的一个（可能是不连续的）区域。当前点最初位于原点。在每个操作将分段添加到子路径之后，当前点将更新到该分段的末尾。可以使用 <code>Canvas.drawPath</code> 在画布上绘制路径，并可以使 用<code>Canvas.clipPath</code> 用于创建剪辑区域。有如下两个构造方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空的路径对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Path()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建另一个路径的副本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">factory</span> Path.from(Path source)</span></pre></td></tr></table></figure>

<p>常用的方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在给定的坐标处开始一个新的子路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">moveTo(<span class="built_in">double</span> x, <span class="built_in">double</span> y);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//从当前点到给定点添加一条直线段  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lineTo(<span class="built_in">double</span> x, <span class="built_in">double</span> y);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//关闭最后一个子路径，就好像从当前点到子路径的第一点画了一条直线，对路径做闭合操作  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">close();</span></pre></td></tr></table></figure>

<p>更多可查看官网说明：<a href="https://api.flutter.dev/flutter/dart-ui/Path-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/dart-ui/Path-class.html</a> </p>
<p><code>ClipPath</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ClipPath(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          clipper: MyCustomClipper(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomClipper</span> <span class="keyword">extends</span> <span class="title">CustomClipper</span>&lt;<span class="title">Path</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  getClip(Size size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Path path = Path();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path.moveTo(<span class="number">0</span>, size.height);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path.lineTo(size.width/<span class="number">2</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path.lineTo(size.width, size.height);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path.close();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> path;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> shouldReclip(CustomClipper oldClipper) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/ec7a556a/2020331906.jpg" alt="2020331906" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>InputChip</tag>
        <tag>ClipOval</tag>
        <tag>Opacity</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十二)</title>
    <url>/content/92897541.html</url>
    <content><![CDATA[<h4 id="一、CustomScrollView-Widget"><a href="#一、CustomScrollView-Widget" class="headerlink" title="一、CustomScrollView Widget"></a>一、CustomScrollView Widget</h4><p><code>CustomScrollView</code> 是一个自定义的滚动 Widget 。使用 <code>CustomScrollView</code> 可以实现更为复杂的滚动列表样式。其构造方法如下：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CustomScrollView(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Axis类型可选命名参数，设置沿横轴还是纵轴滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Axis scrollDirection = Axis.vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，用于设置视图的滚动方向是否为读取方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，控制滚动视图滚动位置的控制器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ScrollController controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否是与父PrimaryScrollController相关联的主滚动视图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> primary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ScrollPhysics physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//boo类型可选命名参数，crollDirection中滚动视图的范围是否应由正在查看的内容确定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Key类型可选命名参数，用于标识在GrowthDirection.forward方向上的第一个Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，零滚动偏移量的相对位置，控制中心在视口中对齐的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> anchor = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，视口在可见区域之前和之后都有一个区域，用于缓存当用户滚动时将变得可见的项目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> cacheExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，子Widget类别</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.slivers = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，为CustomScrollView中的子列表中Widget提供语义信息的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> semanticChildCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p> 很多属性在上篇文章的 <code>ListView</code> 部分都有过介绍说明，可自行查看。</p>
<p><code>Key</code> 是小部件，元素和语义节点的标识符。如果新窗口小部件的键与与该元素关联的当前窗口小部件的键相同，则仅将其用于更新现有元素。在具有相同父元素的 Elements 中，键必须唯一。<code>Key</code> 的子类应该是 <code>LocalKey</code> 或  <code>GlobalKey</code> 的子类。</p>
<p><code>slivers</code> 是 <code>List&lt;Widget&gt;</code> 类型，用于设置 <code>CustomScrollView</code> 的子 Widget 列表。需要注意的是，这些子 Widget 必须生成 <code>RenderSliver</code> 对象。这些子 Widget 通常为 <code>SliverAppBar</code> 、 <code>SliverList</code> 、<code>SliverGrid</code> 、<code>SliverFixedExtentList</code> 、<code>SliverPadding</code> 。</p>
<p><code>SliverAppBar</code> 是与 <code>CustomScrollView</code> 集成在一起使用的应用栏。应用栏由工具栏和其他可能的小部件组成，例如 <code>TabBar</code> 和 <code>FlexibleSpaceBar</code> 。应用程序栏通常使用 <code>IconButton</code> 公开一个或多个常见操作，然后可以选择 <code>PopupMenuButton</code> 来执行不太常见的操作。Sliver 应用程序栏通常用作 <code>CustomScrollView</code> 的第一个子项，它使该应用程序栏与滚动视图集成在一起，以便其高度可以根据滚动偏移量而变化，或浮动在滚动视图中其他内容的上方。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverAppBar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在标题之前显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.leading,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，显示标题的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要在标题小部件后显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.actions,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，堆叠在工具栏和选项卡栏后面的Widget。它的高度将与应用栏的整体高度相同。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//通常为FlexibleSpaceBar</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.flexibleSpace,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PreferredSizeWidget类型可选命名参数，显示在应用程序栏的底部的Widget。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//通常是一个TabBar。 在应用程序栏的底部只能使用实现PreferredSizeWidget的窗口小部件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottom,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，当此应用栏位于其他内容上方时的Z坐标。这可控制应用栏下方阴影的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，即使内容不在AppBar下滚动，是否显示适合于高程的阴影</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.forceElevated = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，应用栏材料的颜色。通常，应与亮度，iconTheme，textTheme一起设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，应用栏材质的亮度。通常，这是与背景颜色，图标主题，textTheme一起设置的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.brightness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，应用栏图标的颜色，不透明度和大小。通常，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//这是与backgroundColor，brightness，textTheme一起设置的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.iconTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，用于尾随应用程序栏图标的颜色，不透明度和大小。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//仅当尾随图标的主题主题不同于前导图标时，才应使用此选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.actionsIconTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextTheme类型可选命名参数，应用栏中用于文本的印刷样式。通常，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//这与亮度backgroundColor，iconTheme一起设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此应用栏是否显示在屏幕顶部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，标题是否居中显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.centerTitle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，水平轴上标题内容周围的间距。即使没有前导内容或动作，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//也会应用此间距。如果希望标题占用所有可用空间，请将此值设置为0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，应用程序栏完全展开时的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.expandedHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，向下滚动时，是否应立即显示该应用程序栏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.floating = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，应用栏在滚动视图开始时是否应保持可见</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.pinned = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果对齐和浮动设置为true，则浮动应用程序栏将“捕捉”到视图中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.snap = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，应用栏是否应拉伸以填充过度滚动区域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.stretch = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，激活onStretchTrigger所需的过滚动偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.stretchTriggerOffset = <span class="number">100.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AsyncCallback类型可选命名参数，用户过度滚动到StretchTriggerOffset指定的偏移量时要执行的回调函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onStretchTrigger,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，材料的形状及其阴影</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>bottom</code> 用于设置底部工具栏，通常是一个 <code>TabBar</code> ，在应用程序栏的底部只能使用实现 <code>PreferredSizeWidget</code> 的 Widget 。关于 <code>TabBar</code> 的介绍可以查看 <a href="http://www.mwpush.com/content/c03861f.html">http://www.mwpush.com/content/c03861f.html</a> 。</p>
<p><code>SliverPadding</code> 是一个可以设置内边距的 Widget 。可以使用 <code>CustomScrollView</code> 进行组合以创建自定义滚动效果。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverPadding(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型必传参数，设置内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget sliver,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>SliverGrid</code> 与 <code>GridView</code> 类似，网格局部的 Widget 。几个构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverGrid(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverChildDelegate类型必传参数，SliverGrid的子Widget委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> SliverChildDelegate delegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverGridDelegate类型必传参数，控制子Widget的大小和位置的委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//还有其他两个构造方法，与GridView大同小异，可以参考</span></span></pre></td></tr></table></figure>

<p><code>SliverList</code> 与 <code>ListView</code> 类似，线性布局的 Widget 。几个构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverList(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverChildDelegate类型必传参数，子Widget的委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> SliverChildDelegate delegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>CustomScrollView</code> 基本使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key _sKey = Key(<span class="string">"c"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//      appBar: AppBar(</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        title: Text("HomePage"),</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//      ),</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: CustomScrollView(					<span class="comment">//CustomScrollView</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          center: _sKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          anchor: <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          slivers: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SliverAppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              key: _sKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Icon(Icons.markunread),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              automaticallyImplyLeading: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              actions: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">              flexibleSpace: Container(color: Colors.orange,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              floating: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              pinned: <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              snap: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              stretch: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              onStretchTrigger: stretchCallBack,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SliverPadding(padding: EdgeInsets.only(top: <span class="number">10</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SliverGrid(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              delegate: SliverChildListDelegate(&lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ]),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                crossAxisCount: <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mainAxisSpacing: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                crossAxisSpacing: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                childAspectRatio: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SliverPadding(padding: EdgeInsets.only(top: <span class="number">10</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SliverList(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              delegate: SliverChildBuilderDelegate((context, index)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> Padding(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  padding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    color: Colors.orange,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    child: ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      title: Text(<span class="string">"标题"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                );</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Future stretchCallBack() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"回调"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Future.value(<span class="string">"result"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/92897541/20203301156.jpg" alt="20203301156" style="zoom:50%;">



<h4 id="二、Flow-Widget"><a href="#二、Flow-Widget" class="headerlink" title="二、Flow Widget"></a>二、Flow Widget</h4><p><code>Flow</code> 是流式布局 Widget 。它可以实现对子 Widget 大小和位置的设置。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认构造方法，创建流式布局</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Flow(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FlowDelegate类型必传参数，控制子级转换矩阵的委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@required</span> <span class="keyword">this</span>.delegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，子Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">Flow.unwrapped(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FlowDelegate类型必传参数，控制子级转换矩阵的委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.delegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，子Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>delegate</code> 是 <code>FlowDelegate</code> 类型，委托用来控制流式布局的外观设置。流式布局的大小是由委托的<code>FlowDelegate.getSize</code> 函数独立于子级来确定的。然后，根据 <code>FlowDelegate.GetConstraintsFairld</code>函数的约束条件，独立调整子级的大小。</p>
<p>在绘制阶段，使用 <code>FlowDelegate.paintChildren</code> 函数中的矩阵来定位子对象，而不是在布局过程中定位子对象。可以通过简单地重新绘制流程来有效地重新定位子流程，这在子流程没有再次布局的情况下发生(与 <code>Stack</code> 形成对比，<code>Stack</code> 在布局期间一起进行大小调整和定位)。</p>
<p><code>FlowDelegate</code> 是一个抽象基类，并且没有提供可用的子类，需要自定义类并继承 <code>FlowDelegate</code> 。继承后必须实现 <code>void paintChildren(FlowPaintingContext context)</code> 和 <code>bool shouldRepaint(FlowDelegate oldDelegate)</code> 方法。</p>
<p><code>FlowPaintingContext</code> 是 <code>FlowDelegate</code> 绘制的上下文，提供有关容器和子对象的当前大小的信息，以及绘制子对象的机制。其提供了 <code>Size getChildSize(int i)</code> 、 <code>void paintChild(int i, { Matrix4 transform, double opacity = 1.0 })</code> 方法和两个 get 属性 <code>size</code> 、<code>childCount</code>。</p>
<p><code>Size getChildSize(int i)</code> 根据索引获取 <code>children</code> 中设置的 Widget 的 <code>Size</code> 。</p>
<p><code>void paintChild(int i, { Matrix4 transform, double opacity = 1.0 })</code> 用来根据索引和变化进行对应 Widget 的绘制操作。将在一个坐标系中绘制该子级，该坐标系将容器的坐标系与给定的变换连接在一起。 父级坐标系的原点是父级的左上角，其中x向右增加，y向下方增加。容器会将孩子固定在其边界上。</p>
<p><code>size</code> 绘制 <code>children</code> Widget 的容器大小。</p>
<p><code>childCount</code> 绘制 <code>children</code> 的数量。</p>
<p><code>Flow</code> 基本使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Flow(							<span class="comment">//Flow</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          delegate: MyFlowDelegate(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.greenAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlowDelegate</span> <span class="keyword">extends</span> <span class="title">FlowDelegate</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> paintChildren(FlowPaintingContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">double</span> dy = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; context.childCount; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      dy = (context.getChildSize(i).height + <span class="number">10</span>) * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      context.paintChild(i, transform: Matrix4.translationValues(<span class="number">0</span>, dy, <span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> shouldRepaint(FlowDelegate oldDelegate) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/92897541/2020330620.jpg" alt="2020330620" style="zoom:50%;">



<p>官方文档有动态的例子，查看网址：<a href="https://api.flutter.dev/flutter/widgets/Flow-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/widgets/Flow-class.html</a></p>
<h4 id="三、SingleChildScrollView-Widget"><a href="#三、SingleChildScrollView-Widget" class="headerlink" title="三、SingleChildScrollView Widget"></a>三、SingleChildScrollView Widget</h4><p><code>SingleChildScrollView</code> 是一个可滚动的 Widget 。当全部展示内容在视口范围内时，其不可滚动，当超出视口时，其可滚动。有时候由于手机尺寸不同，同一样式的界面在小屏幕手机上展示不完全时，可以使用此 Widget 。比如，其可以与 <code>Column</code> 配合使用，<code>Column</code> 当超出垂直方向范围时，超出部分不可见，配合 <code>SingleChildScrollView</code> 便可以垂直进行滚动操作。<code>SingleChildScrollView</code> 构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SingleChildScrollView(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Axis类型可选命名参数，设置沿横轴还是纵轴滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollDirection = Axis.vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，用于设置视图的滚动方向是否为读取方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.reverse = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，设置内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否是与父PrimaryScrollController相关联的主滚动视图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> primary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，控制滚动视图滚动位置的控制器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: SingleChildScrollView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          padding: EdgeInsets.all(<span class="number">5</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/92897541/2020330948.jpg" alt="2020330948" style="zoom:50%;">





<h4 id="四、Scrollable-Widget"><a href="#四、Scrollable-Widget" class="headerlink" title="四、Scrollable Widget"></a>四、Scrollable Widget</h4><p><code>Scrollable</code> 是一个滚动的 Widget 。它为可滚动窗口小部件实现了交互模型，包括手势识别，但对如何显示实际显示子项的视口没有意见。直接构造 <code>Scrollable</code> 很少见。 而是考虑将滚动，视口和布局模型结合在一起的 <code>ListView</code> 或 <code>GridView</code> 。 要组合布局模型(或使用自定义布局模式)，请考虑使用 <code>CustomScrollView</code> 。</p>
<p>静态 <code>Scrollable.of</code> 和 <code>Scrollable.ensureVisible</code> 函数通常用于与 <code>ListView</code> 或 <code>GridView</code> 中的 <code>Scrollable</code> 小部件进行交互。</p>
<h4 id="五、ListBody-Widget"><a href="#五、ListBody-Widget" class="headerlink" title="五、ListBody Widget"></a>五、ListBody Widget</h4><p><code>ListBody</code> 是一个将其子部件沿给定的轴顺序排列，迫使它们位于另一个轴上的父维度。这个小部件很少直接使用。相反，可以考虑使用 <code>ListView</code> (它结合了类似的布局算法和滚动行为)或 <code>Column</code> (它使您能够更灵活地控制一组垂直框的布局)。</p>
<h4 id="六、Scrollbar-Widget"><a href="#六、Scrollbar-Widget" class="headerlink" title="六、Scrollbar Widget"></a>六、Scrollbar Widget</h4><p><code>Scrollbar</code> 是滚动条 Widget ，用于指示可滚动窗口小部件的哪个部分实际可见。动态更改为类似于iOS平台上的<code>CupertinoScrollbar</code> 的iOS样式滚动条。要将滚动条添加到 <code>ScrollView</code> ，只需将滚动视图小部件包装在 <code>Scrollbar</code> 小部件中。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，要包装的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，用于实现滚动条拖动的滚动条控制器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Scrollbar(				<span class="comment">//Scrollbar</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: ListView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                margin: EdgeInsets.only(bottom: <span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下:</p>
<img src="/content/92897541/20203301047.jpg" alt="20203301047" style="zoom:50%;">



<h4 id="七、SafeArea-Widget"><a href="#七、SafeArea-Widget" class="headerlink" title="七、SafeArea Widget"></a>七、SafeArea Widget</h4><p><code>SafeArea</code> 一个设置安全区域的 Widget 。它通过足够的填充来插入其子级，以避免操作系统的入侵。例如，这将使孩子缩进足够多的位置，以避免屏幕顶部的状态栏。它还会使孩子缩进必要的数量，以避免在iPhone X上出现缺口或其他类似的创造性外观特征。当指定最小填充时，将应用最小填充或安全区域填充中的较大者。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SafeArea(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否避免左侧的系统入侵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.left = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否避免在屏幕顶部（通常是系统状态栏）出现系统入侵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.top = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否避免右边的系统入侵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.right = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否避免屏幕底部出现系统入侵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottom = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsets类型可选命名参数，最小填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minimum = EdgeInsets.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，指定当由当前上下文的MediaQuery的viewInsets占用时，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SafeArea是否应维护viewPadding而不是填充，默认为false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maintainBottomViewPadding = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: SafeArea(					<span class="comment">//SafeArea</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="八、SliverSafeArea-Widget"><a href="#八、SliverSafeArea-Widget" class="headerlink" title="八、SliverSafeArea Widget"></a>八、SliverSafeArea Widget</h4><p><code>SliverSafeArea</code> 与 <code>SafeArea</code> 功能相同。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverSafeArea(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.left = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.top = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.right = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottom = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minimum = EdgeInsets.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.sliver,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<h4 id="九、CircleAvatar-Widget"><a href="#九、CircleAvatar-Widget" class="headerlink" title="九、CircleAvatar Widget"></a>九、CircleAvatar Widget</h4><p><code>CircleAvatar</code> 是一个代表用户的圆 Widget 。通常与用户的个人资料图片一起使用，或者在没有此类图片的情况下与用户的姓名缩写一起使用。 为了保持一致，给定用户的姓名缩写应始终与相同的背景色配对。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CircleAvatar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，填充圆的颜色。改变背景颜色将会使头像变成新的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageProvider类型可选命名参数，圆圈的背景图像。改变背景图像将导致化身动画到新图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundImage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，圆圈中文本的默认文本颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.foregroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，化身的大小，表示为半径(直径的一半)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.radius,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，化身的最大尺寸，表示为半径(直径的一半)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minRadius,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，化身的最小大小，以半径(直径的一半)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxRadius,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中，<code>radius</code> 如果不为空，则不能设置 <code>minRadius</code> 和 <code>maxRadius</code> ，否则可以，二者只能选择其一。</p>
<p><code>backgroundImage</code> 是 <code>ImageProvider</code> 类型，在 <a href="http://www.mwpush.com/content/f0eb3e6d.html">http://www.mwpush.com/content/f0eb3e6d.html</a> 介绍过。有一个错误的地方，那篇文章里写了 <code>ImageProvider</code> 是一个抽象类，不能直接实例化。其有5个直接子类分别为：<code>AssetBundleImageProvider</code> ， <code>FileImage</code> ，<code>MemoryImage</code> ，<code>NetworkImage</code> ，<code>ResizeImage</code> ，可以直接使用，是错误的 <code>AssetBundleImageProvider</code> 也是一个抽象类，不能直接被实例化，需要使用它的子类 <code>AssetImage</code> 或 <code>ExactAssetImage</code> 。这里做下更正。</p>
<p><code>CircleAvatar</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: CircleAvatar( 				<span class="comment">//CircleAvatar</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"MW"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundColor: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          foregroundColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          radius: <span class="number">50</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/92897541/20203311039.jpg" alt="20203311039" style="zoom:50%;">



<h4 id="十、Chip-Widget"><a href="#十、Chip-Widget" class="headerlink" title="十、Chip Widget"></a>十、Chip Widget</h4><p><code>Chip</code> 是用长形椭圆表示用户或概念的 Widget ，其可以根据字符的长度增长。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Chip(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在Chip的label前显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.avatar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，Chip的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，Chip的label的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，Chip内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，设置onDeleted时显示的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，用户点击deleteIcon删除Chip时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onDeleted,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，删除图标的颜色。默认值基于环境IconTheme.color</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteIconColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，该信息用于Chip的删除按钮工具提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.deleteButtonTooltipMessage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，Chip的线框形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，内容将被裁剪（或不裁剪）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，一个可选的焦点节点，用作此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当前未将其范围内的其他节点作为焦点，则将此小部件选择为初始焦点时为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于未选中的已启用Chip背景的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，Chip内容和外部形状之间的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置点击目标的最小大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父级应用于Chip的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高程大于0时Chip阴影的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shadowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Chip(					<span class="comment">//Chip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          avatar: Icon(Icons.access_alarm),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          label: Text(<span class="string">'This is Label text'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          labelStyle: TextStyle(fontSize: <span class="number">24</span>, color: Colors.red),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          labelPadding: EdgeInsets.all(<span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          deleteIcon: Icon(Icons.delete),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onDeleted: ()=&gt; <span class="built_in">print</span>(<span class="string">"delete"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          deleteIconColor: Colors.lightBlueAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          deleteButtonTooltipMessage: <span class="string">"删除"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundColor: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          padding: EdgeInsets.all(<span class="number">5</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/92897541/20203311107.jpg" alt="20203311107" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>Chip</tag>
        <tag>Flow</tag>
        <tag>CircleAvatar</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十一)</title>
    <url>/content/3db8ee23.html</url>
    <content><![CDATA[<h4 id="一、Card-Widget"><a href="#一、Card-Widget" class="headerlink" title="一、Card Widget"></a>一、Card Widget</h4><p><code>Card</code> 是一个有圆角和阴影的卡片 Widget 。通常用于表示某些相关的信息，例如相册，地理位置，联系方式等。其构造方法如下：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Card(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，卡片背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，放置此卡片的z坐标。这可控制卡下方阴影的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，设置卡片形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否在子Widget面前绘制形状边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.borderOnForeground = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，卡片外边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.margin,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，内容将被如何裁剪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，这个小部件表示单个语义容器，还是如果为false，则表示单个语义节点的集合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticContainer = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中 <code>shape</code> 是一个 <code>ShapeBorder</code> 类型，如果不设置或为 <code>null</code> ，则使用 <code>ThemeData.cardTheme.shape</code> 。如果其也为 <code>null</code> ，则形状将为 <code>RoundedRectangleBorder</code> ，圆角半径为 4.0。<code>ShapeBorder</code> 是一个形状轮廓的基类，是一个抽象类，可以使用其子类设置不同的形状，常用有如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">CircleBorder <span class="comment">//圆形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">RoundedRectangleBorder  <span class="comment">//圆角矩形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ContinuousRectangleBorder   <span class="comment">//连续矩形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">BeveledRectangleBorder  <span class="comment">//斜角矩形</span></span></pre></td></tr></table></figure>

<p><code>clipBehavior</code> 是 <code>Clip</code> 类型，用于设置内容将被如何裁剪。如果为 <code>null</code> ，则使用<code>ThemeData.cardTheme.clipBehavior</code> 。 如果其也为 <code>null</code> ，则行为将为 <code>Clip.none</code> 。 </p>
<p><code>Card</code> 的默认就是有简单圆角和小阴影的 Widget ，使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Card(					 <span class="comment">//Card</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          elevation: <span class="number">10</span>,       <span class="comment">//为了观察，设置了较大的阴影</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下:</p>
<img src="/content/3db8ee23/202023291142.jpg" alt="202023291142" style="zoom:50%;">

<p>其实属性设置如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Card(								<span class="comment">//Card</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          shape: CircleBorder(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          borderOnForeground: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          margin: EdgeInsets.all(<span class="number">20</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          clipBehavior: Clip.hardEdge,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"hello"</span>, style: TextStyle(fontSize: <span class="number">160</span>),)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/3db8ee23/20203291221.jpg" alt="20203291221" style="zoom:50%;">



<h4 id="二、GridView-Widget"><a href="#二、GridView-Widget" class="headerlink" title="二、GridView Widget"></a>二、GridView Widget</h4><p><code>GridView</code> 是一个可滚动的二维网格布局的 Widget 。可通过设置滚动方向设置横向或纵向。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认构造方法，创建一个可滚动的二维网格布局Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GridView(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Axis类型可选命名参数，设置沿横轴还是纵轴滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Axis scrollDirection = Axis.vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，用于设置视图的滚动方向是否为读取方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，控制滚动视图滚动位置的控制器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ScrollController controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否是与父PrimaryScrollController相关联的主滚动视图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> primary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ScrollPhysics physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//boo类型可选命名参数，crollDirection中滚动视图的范围是否应由正在查看的内容确定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，设置内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  EdgeInsetsGeometry padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverGridDelegate类型必传参数，控制GridView中子级的布局</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在AutomaticKeepAlive组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在RepaintBoundary组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在IndexedSemantics组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，视口在可见区域之前和之后都有一个区域，用于缓存当用户滚动时将变得可见的项目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> cacheExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，为GridView中的子列表中Widget提供语义信息的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> semanticChildCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//按需创建一个可滚动的二维网格布局Widget  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GridView.builder(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverGridDelegate类型必传参数，控制GridView中子级的布局</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IndexedWidgetBuilder类型必传参数，为给定索引创建Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，创建Widget的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> itemCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//省略与GridView相同部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建小部件的可滚动网格Widget，并在横轴上具有固定数量的图块  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GridView.custom(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverGridDelegate类型必传参数，控制GridView中子级的布局</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.gridDelegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverChildDelegate类型必传参数，用于设置其子Widget的委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.childrenDelegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//省略与GridView相同部分  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//根据给定的数量创建小部件的可滚动网格Widget，在横轴上具有固定数量的图块  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GridView.count(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，次轴上子Widget的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">int</span> crossAxisCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，主轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，次轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个子Widget在次轴与主轴上的范围比例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，设置要显示的Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//省略与GridView相同部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//根据给定的最大范围值创建一个带有小块的可滚动网格Widget，每个小块具有最大跨轴范围的图块  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GridView.extent(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，在主滚动方向上每个子Widget的最大取值范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">double</span> maxCrossAxisExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，主轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，次轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个子Widget在次轴与主轴上的范围比例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，设置要显示的Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//省略与GridView相同部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>GridView</code> 与 <code>ListView</code> 很多属性相同，同样的属性这里就不再做说明，可以查看上一篇文章关于 <code>ListView</code> 的介绍。使用方式也大同小异，使用默认的构造可以实现其他构造的全部形态，使用具体的命名构造可以更快更方的创建出所需的网格布局 Widget 。</p>
<p><code>gridDelegate</code> 是 <code>SliverGridDelegate</code> 类型，用于设置 <code>GridView</code> 的布局。它是一个抽象类，需要使用其子类，<code>SliverGridDelegateWithFixedCrossAxisCount</code> 或 <code>SliverGridDelegateWithMaxCrossAxisExtent</code> 。</p>
<p><code>SliverGridDelegateWithFixedCrossAxisCount</code> 用于在次轴方向上创建固定数量的图块布局。如果网格是垂直的，则此委托将创建具有固定列数的布局。 如果网格是水平的，则此委托将创建一个具有固定行数的布局。该委托创建具有相等大小和间距的图块的网格。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverGridDelegateWithFixedCrossAxisCount(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，次轴上子Widget的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.crossAxisCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，主轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.mainAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，次轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.crossAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个子Widget在次轴与主轴上的范围比例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.childAspectRatio = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>SliverGridDelegateWithMaxCrossAxisExtent</code> 用于设置在次轴方向上设置每个子 Widget 的最大取值范围。例如，如果网格是垂直的，网格的宽度为500.0像素，<code>maxCrossAxisExtent</code> 为 150.0，则此委托将创建一个包含 4  列，宽度为 125.0 像素的网格。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverGridDelegateWithMaxCrossAxisExtent(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，在主滚动方向上每个子Widget的最大取值范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.maxCrossAxisExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，主轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.mainAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，次轴上每个子Widget的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.crossAxisSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个子Widget在次轴与主轴上的范围比例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.childAspectRatio = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>GridView</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: GridView(				<span class="comment">//GridView</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          padding: EdgeInsets.all(<span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          scrollDirection: Axis.vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            crossAxisCount: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mainAxisSpacing: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            crossAxisSpacing: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            childAspectRatio: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/3db8ee23/2020329242.jpg" alt="2020329242" style="zoom:50%;">



<p>由于 <code>GridView</code> 与 <code>ListView</code> 使用方式大同小异，这里不多做介绍了。</p>
<h4 id="三、PageView-Widget"><a href="#三、PageView-Widget" class="headerlink" title="三、PageView Widget"></a>三、PageView Widget</h4><p><code>PageView</code> 也是一个可以滚动的列表，它是按页滚动的 Widget 。页面视图的每个子视图都必须与视口具有相同的大小。构造方法如下： </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">PageView(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Axis类型可选命名参数，设置沿横轴还是纵轴滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.scrollDirection = Axis.horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，用于设置视图的滚动方向是否为读取方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.reverse = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PageController类型可选命名参数，页面控制器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  PageController controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，设置为false可禁用页面捕捉，这对于自定义滚动行为很有用，用于设置是否按页滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.pageSnapping = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;int&gt;类型可选命名参数，是一个无返回值的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onPageChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的页面Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">////<span class="markdown">DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>PageController</code> 是页面控制器，可以操纵在 <code>PageView</code> 中可见的页面。 除了能够控制 <code>PageView</code> 内部内容的像素偏移量之外，<code>PageController</code> 还使您可以按页面（即视口大小的增量）来控制偏移量。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">PageController(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，首次创建PageView时显示的页面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialPage = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，使用PageStorage保存当前页面，如果重新创建此控制器的可滚动页面，则将其还原</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.keepPage = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，每个页面应占据的视口比例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.viewportFraction = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>PageView</code> 基本使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: PageView(						<span class="comment">//PageView</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPageChanged: (<span class="built_in">int</span> index) =&gt; <span class="built_in">print</span>(index),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        scrollDirection: Axis.horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pageSnapping: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        controller: PageController(initialPage: <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"第一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"第二页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"第三页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          )</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/3db8ee23/2020329525.jpg" alt="2020329525" style="zoom:50%;">



<h4 id="四、FlutterLogo-Widget"><a href="#四、FlutterLogo-Widget" class="headerlink" title="四、FlutterLogo Widget"></a>四、FlutterLogo Widget</h4><p><code>FlutterLogo</code> 是一个展示 Flutter 系统图标的 Widget 。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FlutterLogo(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，logo的尺寸</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialColor类型可选命名参数，用来设置绘制logo的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.colors,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，logo文本颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textColor = <span class="keyword">const</span> Color(<span class="number">0xFF616161</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FlutterLogoStyle类型可选命名参数，是否以及在何处绘制“ Flutter”文本。 默认情况下，仅绘制logo。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.style = FlutterLogoStyle.markOnly,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Duration类型可选命名参数，如果更改了样式，颜色或textColor属性，则动画的时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.duration = <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">750</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Curve类型可选命名参数，logo动画的曲线（如果样式，颜色，用于文本的颜色发生更改）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.curve = Curves.fastOutSlowIn,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>MaterialColor</code> 用来定义单一颜色以及具有十种阴影的色样。颜色的阴影由索引引用。指数越大，颜色越深。有10个有效索引：50、100、200，…，900。此颜色的值应与索引 500 和 <code>shade500</code> 的值相同。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialColor(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，32位ARGB颜色值，主色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> primary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Map&lt;int, Color&gt;类型必传参数，用于定义10中不同的颜色深度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, Color&gt; swatch</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>

<p><code>primary</code> 应为色板中值之一的 32 位 ARGB 值，该值将传递给该相同颜色的新Color构造函数，并按值公开。 （这与样本中颜色的特定索引不同。）</p>
<p><code>MaterialColor</code> 定义方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">int</span>, Color&gt; color =</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">50</span> : Color(<span class="number">0xFFFF8888</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">100</span> : Color(<span class="number">0xFFFb7A7A</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">200</span> : Color(<span class="number">0xFFFB6868</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">300</span> : Color(<span class="number">0xFFFC5353</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">400</span> : Color(<span class="number">0xFFFD3C3C</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">500</span> : Color(<span class="number">0xFFFC2929</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">600</span> : Color(<span class="number">0xFFFC2121</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">700</span> : Color(<span class="number">0xFFFB1B1B</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">800</span> : Color(<span class="number">0xFFFB0F0F</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="number">900</span> : Color(<span class="number">0xFFFB0000</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">MaterialColor(<span class="number">0xFFFC2121</span>, color)</span></pre></td></tr></table></figure>

<p><code>FlutterLogoStyle</code> 用于设置绘制 logo 的样式，是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> FlutterLogoStyle &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//仅显示logo图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  markOnly,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在左侧显示Flutter的logo，在其右侧显示“ Flutter”标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在“ Flutter”标签上方显示Flutter的logo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  stacked,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>FlutterLogo</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: FlutterLogo(						<span class="comment">//FlutterLogo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          size: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          colors: MaterialColor(<span class="number">0xFFFC2121</span>, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">50</span> : Color(<span class="number">0xFFFF8888</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">100</span> : Color(<span class="number">0xFFFb7A7A</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">200</span> : Color(<span class="number">0xFFFB6868</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">300</span> : Color(<span class="number">0xFFFC5353</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">400</span> : Color(<span class="number">0xFFFD3C3C</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">500</span> : Color(<span class="number">0xFFFC2929</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">600</span> : Color(<span class="number">0xFFFC2121</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">700</span> : Color(<span class="number">0xFFFB1B1B</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">800</span> : Color(<span class="number">0xFFFB0F0F</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="number">900</span> : Color(<span class="number">0xFFFB0000</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          textColor: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          style: FlutterLogoStyle.horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/3db8ee23/2020329902.jpg" alt="2020329902" style="zoom:50%;">



<h4 id="五、Placeholder-Widget"><a href="#五、Placeholder-Widget" class="headerlink" title="五、Placeholder Widget"></a>五、Placeholder Widget</h4><p><code>Placeholder</code> 是一个占位符 Widget 。它绘制一直框，表示未来的时间将替换为其他 Widget 。默认情况下，占位符的大小适合其容器。如果占位符在无限制的空间中，它将根据给定的 <code>fallbackWidth</code> 和 <code>fallbackHeight</code> 自行调整大小。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Placeholder(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，占位符线框颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = <span class="keyword">const</span> Color(<span class="number">0xFF455A64</span>), <span class="comment">// Blue Grey 700</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，占位符框中的线宽</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.strokeWidth = <span class="number">2.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，占位符处于无界宽度情况下要使用的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fallbackWidth = <span class="number">400.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，占位符处于高度不受限制的情况下使用的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fallbackHeight = <span class="number">400.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Placeholder(						<span class="comment">//Placeholder</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          strokeWidth: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fallbackHeight: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fallbackWidth: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/3db8ee23/2020329913.jpg" alt="2020329913" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
        <tag>Card</tag>
        <tag>GridView</tag>
        <tag>PageView</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(十)</title>
    <url>/content/a22ef47b.html</url>
    <content><![CDATA[<h4 id="一、Table-Widget"><a href="#一、Table-Widget" class="headerlink" title="一、Table Widget"></a>一、Table Widget</h4><p><code>Table</code> 是一个使用表格布局算法布局子 Widget 的 Widget 。<code>Table</code> 的行根据其内容垂直调整大小。 若要控制列宽，使用 <code>columnWidths</code> 属性。</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Table(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;TableRow&gt;类型可选命名参数，表格每一行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children = <span class="keyword">const</span> &lt;TableRow&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Map&lt;int, TableColumnWidth&gt;类型可选命名参数，如何确定此表的列的水平范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.columnWidths,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TableColumnWidth类型可选命名参数，如何确定没有显式大小调整算法的列的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.defaultColumnWidth = <span class="keyword">const</span> FlexColumnWidth(<span class="number">1.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，列的排列方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TableBorder类型可选命名参数，为表格边框和内部分割线的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.border,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TableCellVerticalAlignment类型可选命名参数，未明确指定垂直对齐方式的单元格如何垂直对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.defaultVerticalAlignment = TableCellVerticalAlignment.top,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextBaseline类型可选命名参数，使用TableCellVerticalAlignment.baseline对齐行时要使用的文本基线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textBaseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>TableRow</code> 用于设置表格中一组水平单元格，表格中每一行必须有相同数量的子 Widget ，可以使用 <code>TableCell</code> 控制一行中单元格的对齐方式。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TableRow(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Decoration类型可选命名参数，行的背景装饰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decoration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，组成此行中单元格的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>TableColumnWidth</code> 是一个抽象类，用于描述列宽度，可以使用其子类进行设置。如果要设置固定宽度的列可以使用 <code>FixedColumnWidth</code> 。相对宽度可使用 <code>FlexColumnWidth</code> 、 <code>FractionColumnWidth</code> 。<code>FlexColumnWidth</code>  用于设置在其他列都已经设置好的情况下，剩余列宽度的大小。如果有多个 <code>FlexColumnWidth</code> 列，则会根据其设置的数值比例分配宽度。<code>FractionColumnWidth</code> 用来根据百分比设置列宽度，设置的列宽度为表格宽度乘以设置的百分比数值。<code>IntrinsicColumnWidth</code> 用来根据单元格的内容自动调整宽度，关于类似的说明在上篇文章提高多，此类应尽量少用，布局开销比较大，不能设置参数。 <code>MaxColumnWidth</code> 与 <code>MinColumnWidth</code>  有两个参数，为 <code>TableColumnWidth</code> 类型，可以使用以上的子类，分别用于设置两个尺寸中最大和最小的宽度。</p>
<p><code>TableBorder</code> 用于设置表格的边框样式，有几个构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别设置表格边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TableBorder(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，顶部边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.top = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，右侧边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.right = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，底部边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottom = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，左侧边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.left = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，横向边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.horizontalInside = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，纵向边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.verticalInside = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置统一边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">factory</span> TableBorder.all(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，边框颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color color = <span class="keyword">const</span> Color(<span class="number">0xFF000000</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，边框宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> width = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderStyle类型可选命名参数，边框线条样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BorderStyle style = BorderStyle.solid,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//分别设置表格内边框和外边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">factory</span> TableBorder.symmetric(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，表格内边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BorderSide inside = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型可选命名参数，表格外边框</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BorderSide outside = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>BorderSide</code> 用于设置某一侧的边框，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BorderSide(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，边框颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color = <span class="keyword">const</span> Color(<span class="number">0xFF000000</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ouble类型可选命名参数，边框宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderStyle类型可选命名参数，边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.style = BorderStyle.solid,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>BorderStyle</code> 为边框的线条样式，是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> BorderStyle &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//无样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//实线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  solid,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>TableCellVerticalAlignment</code> 用于设置单元格的垂直对齐方式，是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> TableCellVerticalAlignment &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//顶部对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  top,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//居中对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  middle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//底部对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  bottom,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//对齐具有此对齐方式的单元，以使它们都共享相同的基线。 没有基线的单元格将顶部对齐。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//使用的基线由RenderTable.textBaseline指定。 如果未指定RenderTable.textBaseline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则使用基线值无效。这种垂直对齐方式比较昂贵，因为它会使表格为该行中的每个单元格计算基线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  baseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//具有此对齐方式的单元格的大小应与该行一样高，然后使其适合该行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//如果所有单元格都具有此对齐方式，则该行的高度将为零</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  fill</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Table</code> 使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Table(						<span class="comment">//Table</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        children: &lt;TableRow&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          TableRow(children: &lt;Widget&gt;[Text(<span class="string">"Text1 Text1 Text1"</span>), Text(<span class="string">"Text2"</span>), Text(<span class="string">"Text3"</span>)]),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          TableRow(children: &lt;Widget&gt;[Text(<span class="string">"Text4"</span>), Text(<span class="string">"Text5"</span>), Text(<span class="string">"Text6"</span>)]),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          TableRow(children: &lt;Widget&gt;[Text(<span class="string">"Text7"</span>), Text(<span class="string">"Text8"</span>), Text(<span class="string">"Text9"</span>)]),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        columnWidths: &lt;<span class="built_in">int</span> , TableColumnWidth&gt;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="number">0</span> : FractionColumnWidth(<span class="number">0.2</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="number">1</span> : FractionColumnWidth(<span class="number">0.4</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="number">2</span> : FlexColumnWidth(<span class="number">100</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        border: TableBorder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          top: BorderSide(color: Colors.red, width: <span class="number">3</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          right: BorderSide(color: Colors.blue, width: <span class="number">3</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          bottom: BorderSide(color: Colors.blueGrey, width: <span class="number">3</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          left: BorderSide(color: Colors.deepPurpleAccent, width: <span class="number">3</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          horizontalInside: BorderSide(color: Colors.deepPurpleAccent, width: <span class="number">3</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          verticalInside: BorderSide(color: Colors.lightBlueAccent, width: <span class="number">3</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        defaultVerticalAlignment: TableCellVerticalAlignment.middle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a22ef47b/20203271136.jpg" alt="20203271136" style="zoom:50%;">



<h4 id="二、ListView-Widget"><a href="#二、ListView-Widget" class="headerlink" title="二、ListView Widget"></a>二、ListView Widget</h4><p><code>ListView</code> 是一个线性排列的可滚动的 Widget ，是最常用的滚动 Widget，可以横向和纵向滚动。可以通过4种方式创建 <code>ListView</code> ，其构造方法分别如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认构造方法，显示设置字Widget，适用于具有少量子Widget的ListView。因为其需要显示提供</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//所有需要在ListView中显示的子Widget，而不是仅仅提供界面空间内可见的子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ListView(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Axis类型可选命名参数，设置沿横轴还是纵轴滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Axis scrollDirection = Axis.vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，用于设置视图的滚动方向是否为读取方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollController类型可选命名参数，控制滚动视图滚动位置的控制器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ScrollController controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否是与父PrimaryScrollController相关联的主滚动视图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> primary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，滚动视图应如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ScrollPhysics physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//boo类型可选命名参数，crollDirection中滚动视图的范围是否应由正在查看的内容确定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，内边距，使用EdgeInsets</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  EdgeInsetsGeometry padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，不为空则强制子级在滚动方向上具有给定范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.itemExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在AutomaticKeepAlive组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在RepaintBoundary组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在IndexedSemantics组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> addSemanticIndexes = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，用于设置不可见的缓存区域的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> cacheExtent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，用于设置滚动列表的每一项Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，为ListView中的子列表中Widget提供语义信息的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> semanticChildCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DragStartBehavior dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//此构造方法采用IndexedWidgetBuilder，可以根据需要创建子Widget。适用于有大量或无限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//个子Widget的ListView。其只对可见的子Widget进行构建  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ListView.builder(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IndexedWidgetBuilder类型必传参数，为给定索引创建Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，创建Widget的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> itemCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//...省略与ListView相同部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//此构造方法采用IndexedWidgetBuilder，一个是itemBuilder，可以根据需要创建子Widget，另一个是separatorBuilder，同样构建出现在子项目之间的分隔子项目。此构造函数适用于具有固定数目的子元素的列表视图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ListView.separated(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IndexedWidgetBuilder类型必传参数，为给定索引创建Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> IndexedWidgetBuilder itemBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IndexedWidgetBuilder类型必传参数，为给定索引创建Widget分割Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> IndexedWidgetBuilder separatorBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，创建Widget的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">int</span> itemCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//...省略与ListView相同部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//此构造方法采用SliverChildDelegate，它提供了自定义模型的其他方面的功能。例如，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//SliverChildDelegate可以控制用于估计实际不可见的子代大小的算法  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ListView.custom(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliverChildDelegate类型必传参数，为ListView提供子Widget的委托</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.childrenDelegate,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//...省略与ListView相同部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Axis</code> 在上篇文章中介绍过，用于设置水平排列还是垂直排列。</p>
<p><code>reverse</code> 用来设置视图的滚动方向是否为读取方向。例如，如果读取方向是从左到右，并且 <code>scrollDirection</code> 是 <code>Axis.horizontal</code>，则当 <code>reverse</code> 为 <code>false</code> 时，滚动视图从左向右滚动；当 <code>reverse</code> 为 <code>true</code> 时，从右向左滚动。如果 <code>scrollDirection</code> 为 <code>Axis.vertical</code> ，则当 <code>reverse</code> 为 <code>false</code> 时，滚动视图从顶部滚动到底部，而当 <code>reverse</code> 为 <code>true</code> 时，滚动视图从底部滚动到顶部。默认为 <code>false</code> 。</p>
<p><code>ScrollController</code> 用于控制滚动视图的滚动位置和进行位置监听，当 <code>primary</code> 为 <code>true</code> 时，<code>controller</code> 必须为空。除了可以控制滚动视图的位置外，它还可用于控制滚动视图是否应自动保存并恢复其在 <code>PageStorage</code> 中的滚动位置。它可用于读取当前滚动位置或更改它。</p>
<p><code>primary</code> 用于控制在滚动视图有足够空间显示全部视图的情况下，<code>ListView</code> 是否可以滚动。当可用空间展示了全部视图的情况下，此属性如果为 <code>false</code> ，则 <code>ListView</code> 不可滚动，否则可以滚动。当可用空间不能完全展示全部视图的情况下，无论设置 <code>true</code> 还是 <code>false</code> ，<code>ListView</code> 都可以滚动。在 iOS 上，这还标识了滚动视图，该滚动视图将响应状态栏中的轻击而滚动到顶部。当 <code>scrollDirection</code> 为 <code>Axis.vertical</code> 且 <code>controller</code> 为空时，默认值为 <code>true</code>。</p>
<p><code>ScrollPhysics</code> 确定可滚动小部件的物理性质，用于确定如何响应用户输入，也就是如何响应用户的操作。比如，确定用户停止拖动滚动视图后滚动视图如何继续进行动画处理。其也可以用来强制滚动视图在不可以滚动时也始终可以进行滚动，设置 <code>physics: const AlwaysScrollableScrollPhysics()</code> 即可。如果想强制始终不可滚动，则需设置为 <code>physics: const ScrollPhysics()</code> 或 <code>physics: NeverScrollableScrollPhysics()</code>。</p>
<p><code>shrinkWrap</code> 用来设置 <code>ListView</code> 在滚动方向上的长度是否为 <code>ListView</code> 的所有子 Widget 所占用的最小长度。如果为 <code>true</code> ，<code>ListView</code> 将根据其子 Widget 列表来最小化的设置其显示范文。如果为 <code>false</code> ，则其将尝试将填充 <code>ListView</code> 的父级所提供的全部可用空间。如果滚动视图在滚动方向上没有限制约束，则 <code>shrinkWrap</code> 必须为 <code>true</code> 。</p>
<p><code>EdgeInsetsGeometry</code> 主要用于设置边距，是一个抽象基类，可以使用其子类 <code>EdgeInsets</code> 。</p>
<p><code>itemExtent</code> 如果不为空，则强制子 Widget 在滚动方向上具有给定的范围。如果纵向滚动，则强制子 Widget 具有给定的高度，如果横向滚动，则强制子 Widget 具有给定的宽度。</p>
<p><code>addAutomaticKeepAlives</code> 是否将每个子Widget都包装在 <code>AutomaticKeepAlive</code> 组件中，<code>AutomaticKeepAlive</code> 也是一个 Widget ，功能类似于 <code>KeepAlive</code> ，主要作用是将子 Widget 标记为需要存活，即使该子 Widget 处于懒惰列表中也可以将其删除。但 <code>addAutomaticKeepAlives</code> 并没有明确配置此功能，而是用来监听子 Widget 和其他后代的 <code>KeepAliveNotification</code> 消息。</p>
<p><code>addRepaintBoundaries</code> 是否将每个子Widget都包装在 <code>RepaintBoundary</code> 组件中 。<code>RepaintBoundary</code> 是一个为其子 Widget 创建单独的显示列表的 Widget 。如果子树在与树的周围部分不同的时间重新绘制，则可以提高性能。</p>
<p><code>addSemanticIndexes</code> 是否将每个子Widget都包装在 <code>IndexedSemantics</code> 组件中。<code>IndexedSemantics</code> 是一个使用索引来注释子Widget 语义的 Widget 。</p>
<p><code>cacheExtent</code> 视口在可见区域之前和之后都有一个区域，用于缓存当用户滚动时将变得可见的项目。属于此缓存区域的项目即使在屏幕上尚不可见，也可以进行布局。 <code>cacheExtent</code> 描述了缓存区域在视口的前缘和后缘之前延伸了多少像素。视口将尝试用子项覆盖的总范围是：前边缘之前的cacheExtent +主轴的范围+后边缘之后的cacheExtent。缓存区域还用于在iOS上实现隐式可访问性滚动：当可访问性焦点从可见视口中的项目移动到缓存区域中的不可见项目时，框架将通过（隐式）滚动动作将该项目显示在视图中。</p>
<p><code>semanticChildCount</code> ，<code>ScrollView</code> 的某些子类型可以自动推断此值。 例如，<code>ListView</code> 将使用子列表中小部件的数量，而新的 <code>ListView.separated</code> 构造函数将使用该数量的一半。对于 <code>CustomScrollView</code> 和其他未接收到构建器或小部件列表的类型，必须明确提供子计数。 如果该数字未知或无界，则应保持不变或将其设置为空。</p>
<p><code>DragStartBehavior</code> ，传递给 <code>DragStartDetails</code> 的偏移量的配置，用于设置确定用户启动拖动时拖动何时正式开始。是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DragStartBehavior &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在检测到第一个下降事件的位置设置初始偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  down,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//将初始位置设置在检测到拖动开始事件的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>itemBuilder</code> 是一个 <code>IndexedWidgetBuilder</code> 类型，其是一个返回一个 Widget 的方法，原型为：<code>Widget Function(BuildContext context, int index)</code> ，功能是为给定索引创建 Widget 。</p>
<p><code>separatorBuilder</code> 与 <code>itemBuilder</code> 相同，只是在语义上不同，主要用来设置列表子 Widget 的分割 Widget 。</p>
<p><code>childrenDelegate</code> 是 <code>SliverChildDelegate</code> 类型，用于在 <code>ListView.custom</code> 中显示指定委托。使用 <code>SliverChildDelegate</code> 可以惰性的构建 <code>ListView</code> ，以避免创建比可视区域更多的子 Widget 。<code>SliverChildDelegate</code> 是一个抽象基类，需要使用其子类 <code>SliverChildListDelegate</code> 或 <code>SliverChildBuilderDelegate</code> 。</p>
<p><code>SliverChildListDelegate</code>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个使用给定列表为子项供应子Widget的委托。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">SliverChildListDelegate(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型必传参数，要显示的Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在AutomaticKeepAlive组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.addAutomaticKeepAlives = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在RepaintBoundary组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.addRepaintBoundaries = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在IndexedSemantics组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.addSemanticIndexes = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SemanticIndexCallback类型可选命名参数，当addSemanticIndexes为true时使用的  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SemanticIndexCallback，默认为每个窗口小部件提供索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticIndexCallback = _kDefaultSemanticIndexCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，要添加到此小部件生成的语义索引的初始偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticIndexOffset = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>如果子级的顺序从不改变，请考虑使用常量 <code>SliverChildListDelegate.fixed</code> 构造函数，其创建一个恒定版本的委托，所有参数与 <code>SliverChildListDelegate</code> 均相同。</p>
<p><code>SliverChildBuilderDelegate</code> 构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按需创建子Widget的委托，惰性加载</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SliverChildBuilderDelegate(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IndexedWidgetBuilder类型必传参数，是一个构建器方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.builder, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ChildIndexGetter类型可选命名参数，在重新排序的情况下，根据子项的键来调用以查找子项的新索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.findChildIndexCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="comment">//int类型可选命名参数，子Widget的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.childCount,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在AutomaticKeepAlive组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.addAutomaticKeepAlives = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在RepaintBoundary组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.addRepaintBoundaries = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将每个子Widget都包装在IndexedSemantics组件中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.addSemanticIndexes = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SemanticIndexCallback类型可选命名参数，当addSemanticIndexes为true时使用的  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SemanticIndexCallback，默认为每个窗口小部件提供索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticIndexCallback = _kDefaultSemanticIndexCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，要添加到此小部件生成的语义索引的初始偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticIndexOffset = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>ListView</code> 的使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ScrollController _lstController = ScrollController(initialScrollOffset: <span class="number">610</span>);  <span class="comment">//初始化偏移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _lstController.addListener(()=&gt;<span class="built_in">print</span>(_lstController.offset));  <span class="comment">//监听输出列表偏移值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: SizedBox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: ListView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            scrollDirection: Axis.vertical,  <span class="comment">//vertical为纵向滚动列表，horizontal为横向滚动列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            padding: EdgeInsets.all(<span class="number">10</span>),     <span class="comment">//设置内边距，四周留有10像素的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//            shrinkWrap: false,             //ListView是否铺满父级的可用空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            itemExtent: <span class="number">600</span>,                 <span class="comment">//item高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            controller: _lstController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.lightBlueAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 1"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 2"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 3"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a22ef47b/2020328128.jpg" alt="2020328128" style="zoom:50%;">

<p>这里设置了初始化偏移一个子 Widget 的距离，所以初始化显示为第二个 Widget 在顶端。使用了监听滑动列表时列表的偏移，这里只是做了输出，如果需要对界面做更改等操作，需要使用 <code>StatefulWidget</code> 。</p>
<p><code>ListView.builder</code> 可以按需创建子 Widget 。<code>itemCound</code> 如果为空，不进行设置，则会创建占满屏幕的子 Widget ，并在滑动后继续创建占满可用空间的子 Widget 。所以提供一个合理的值，可以提高 <code>ListView</code> 估算最大滚动范围的能力。如果要在创建 <code>ListView</code> 时，一次性创建所有子 Widget ，使用默认构造 <code>ListView()</code> 效率更高。默认情况下，<code>ListView.builder</code> 不支持子级重新排序。 如果您打算以后更改子顺序，请考虑使用<code>ListView</code> 或 <code>ListView.custom</code> 。 <code>ListView.builder</code> 使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&gt; itemList = &lt;<span class="built_in">Map</span>&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"title"</span> : <span class="string">"这个是标题1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"detail"</span> : <span class="string">"这是详细信息1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"title"</span> : <span class="string">"这个是标题2"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"detail"</span> : <span class="string">"这是详细信息2"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"title"</span> : <span class="string">"这个是标题3"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"detail"</span> : <span class="string">"这是详细信息3"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: ListView.builder(  			<span class="comment">//ListView.builder</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        itemBuilder: (context, index)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            padding: EdgeInsets.fromLTRB(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> , <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.greenAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                crossAxisAlignment: CrossAxisAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Text(<span class="string">"标题：<span class="subst">$&#123;itemList[index][<span class="string">"title"</span>]&#125;</span>"</span>, style: TextStyle(fontSize: <span class="number">24</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Text(<span class="string">"详细：<span class="subst">$&#123;itemList[index][<span class="string">"detail"</span>]&#125;</span>"</span>, style: TextStyle(fontSize: <span class="number">18</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        itemCount: itemList.length,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a22ef47b/2020328305.jpg" alt="2020328305" style="zoom:50%;">



<p><code>ListView.separated</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&gt; itemList = &lt;<span class="built_in">Map</span>&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"title"</span> : <span class="string">"这个是标题1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"detail"</span> : <span class="string">"这是详细信息1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"title"</span> : <span class="string">"这个是标题2"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"detail"</span> : <span class="string">"这是详细信息2"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"title"</span> : <span class="string">"这个是标题3"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"detail"</span> : <span class="string">"这是详细信息3"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.fromLTRB(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> , <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ListView.separated(							<span class="comment">//ListView.separated</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          itemBuilder: (context, index)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                crossAxisAlignment: CrossAxisAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Text(<span class="string">"标题：<span class="subst">$&#123;itemList[index][<span class="string">"title"</span>]&#125;</span>"</span>, style: TextStyle(fontSize: <span class="number">24</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Text(<span class="string">"详细：<span class="subst">$&#123;itemList[index][<span class="string">"detail"</span>]&#125;</span>"</span>, style: TextStyle(fontSize: <span class="number">18</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          separatorBuilder: (context, index) &#123;   <span class="comment">//分割线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          itemCount: itemList.length,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a22ef47b/2020328314.jpg" alt="2020328314" style="zoom:50%;">



<p><code>ListView.custom</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.fromLTRB(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> , <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ListView.custom(								<span class="comment">//ListView.custom</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          childrenDelegate: SliverChildListDelegate(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.lightBlueAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 1"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 2"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: <span class="keyword">const</span> Center(child: Text(<span class="string">"Text 3"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实现效果与 <code>ListView()</code> 相同。</p>
<h4 id="三、ListTile-Widget"><a href="#三、ListTile-Widget" class="headerlink" title="三、ListTile Widget"></a>三、ListTile Widget</h4><p><code>ListTile</code> 是一个固定高度的行 Widget ，常用在 <code>ListView</code> 、<code>Column</code> 、<code>Drawer</code> 、<code>Card</code> 中。其是一个可以包含文本以及前导和后导 Widget 的 Widget。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ListTile(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，在标题之前显示的Widget，通常为Icon或CircleAvatar</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.leading,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，标题Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，标题下方显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.subtitle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，标题后面显示的Widget，通常为Icon</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.trailing,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否提供至少3行文本显示。如果为true，subtitle不能为null。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//为false时，可以不提供subtitle，只显示提高行，提供则显示两行的高度并显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isThreeLine = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否密集显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dense,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.contentPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，ListTile是否可以交互</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//GestureTapCallback类型可选命名参数，点击操作的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onTap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//GestureLongPressCallback类型可选命名参数，长按操作的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onLongPress,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果还启用了此图块，则图标和文本将以相同的颜色呈现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selected = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ListTile(							<span class="comment">//ListTile</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          leading: Icon(Icons.access_alarm),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"这里显示的标题"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          subtitle: Text(<span class="string">"副标题"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          trailing: Icon(Icons.add_box),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          isThreeLine: <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          contentPadding: EdgeInsets.all(<span class="number">10</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onTap: () =&gt; <span class="built_in">print</span>(<span class="string">"点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onLongPress: ()=&gt; <span class="built_in">print</span>(<span class="string">"长按"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          dense: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          selected: <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a22ef47b/20203281004.jpg" alt="20203281004" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(九)</title>
    <url>/content/df87830f.html</url>
    <content><![CDATA[<h4 id="一、ConstrainedBox-Widget"><a href="#一、ConstrainedBox-Widget" class="headerlink" title="一、ConstrainedBox Widget"></a>一、ConstrainedBox Widget</h4><p><code>ConstrainedBox</code> 是一个可以在其子 Widget 上附加约束的 Widget 。</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ConstrainedBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//BoxConstraints类型必传参数，设置子Widget约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.constraints,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>BoxConstraints</code> 用于设置约束，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过给定的宽高设置约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最小宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minWidth = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最大宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最小高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minHeight = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最大高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建仅由给定大小决定的约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">BoxConstraints.tight(Size size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建需要给定高度和宽度的约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints.tightFor(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建需要给定高度和宽度的约束，除非他们是无限的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints.tightForFinite(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> width = <span class="built_in">double</span>.infinity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> height = <span class="built_in">double</span>.infinity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建禁止大于给定Size的约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">BoxConstraints.loose(Size size)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建具有固定宽高的约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints.expand(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>ConstrainedBox</code> 的使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: ConstrainedBox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            constraints: BoxConstraints (</span></pre></td></tr><tr><td class="code"><pre><span class="line">              minWidth: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              maxWidth:  <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              minHeight: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              maxHeight:  <span class="number">500</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"hello"</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="二、LimitedBox-Widget"><a href="#二、LimitedBox-Widget" class="headerlink" title="二、LimitedBox Widget"></a>二、LimitedBox Widget</h4><p><code>LimitedBox</code> 用来在不受约束的 Widget 限制其大小。使用此 Widget 需要注意的是，只有在 <code>LimitedBox</code> 的宽度或高度或高宽不受限制时，其才起作用。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> LimitedBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最大宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最大高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>不生效的使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: LimitedBox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxWidth: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxHeight: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/20203251022.jpg" alt="20203251022" style="zoom:50%;">

<p>因为 <code>LimitedBox</code> 受屏幕宽高的限制，所以其不起作用，如果要生效，需要在其不受限制的情况下使用，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Row(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            LimitedBox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              maxWidth: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              maxHeight: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/20203251024.jpg" alt="20203251024" style="zoom:50%;">

<p>因为 <code>Row</code> 是横向布局 Widget ，其在水平方向上理论上是不受宽度限制的，只是其不能显示超出屏幕的部分而已。因为 <code>Row</code> 只有在水平方向不受限制，所以 <code>LimitedBox</code> 的 <code>maxWidth</code> 起作用，而垂直方向不生效。如果要同时生效，可使用在水平和垂直方向同时不受限制的 Widget 即可。</p>
<h4 id="三、AspectRatio-Widget"><a href="#三、AspectRatio-Widget" class="headerlink" title="三、AspectRatio Widget"></a>三、AspectRatio Widget</h4><p><code>AspectRatio</code> 用来尝试将子 Widget 调整为固定纵横比(宽高比)的 Widget 。其会首先尝试布局约束允许的最大宽度，子 Widget 的高度是通过给定的比例来确定。如果宽度是无限制的，则会通过高度和纵横比来确定初始宽度。如果有纵横比为2.0，并且布局约束要求宽度在0.0到100.0之间，而高度在0.0到100.0之间。 我们将选择100.0的宽度（允许的最大宽度）和50.0的高度（以匹配宽高比）。</p>
<p>在相同的情况下，如果宽高比为0.5，我们还将选择100.0的宽度（仍然是允许的最大宽度），并且尝试使用200.0的高度。 不幸的是，这违反了约束，因为孩子的身高最高为100.0像素。 然后，小部件将使用该值并再次应用纵横比以获得50.0的宽度。 约束允许该宽度，并且孩子的宽度为50.0，高度为100.0。 如果宽度不允许，则小部件将继续迭代约束。 如果在咨询每个约束后小部件未找到可行的大小，则小部件将最终为子对象选择一个大小，该大小符合布局约束，但不能满足长宽比约束。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AspectRatio(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，宽高比，大于0的有限值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.aspectRatio,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示和限制比例的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: AspectRatio(      <span class="comment">//AspectRatio</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          aspectRatio: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="四、FractionallySizedBox-Widget"><a href="#四、FractionallySizedBox-Widget" class="headerlink" title="四、FractionallySizedBox Widget"></a>四、FractionallySizedBox Widget</h4><p><code>FractionallySizedBox</code> 通过百分比将其子 Widget 的大小调整为总可用空间的一部分。<code>FractionallySizedBox</code>   通过设置宽高因子来确定其大小，计算方式为可用空间的宽度值乘以宽度因子，可用空间的高度值乘以高度因子。如果不设置宽高因子，则会填满可用空间。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FractionallySizedBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，如何对齐子Widget，通常使用Alignment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，宽度因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.widthFactor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，高度因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.heightFactor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: FractionallySizedBox(        <span class="comment">//FractionallySizedBox</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            alignment: Alignment.topCenter,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            widthFactor: <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            heightFactor: <span class="number">1.2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<img src="/content/df87830f/20203251108.jpg" alt="20203251108" style="zoom:50%;">



<h4 id="五、Transform-Widget"><a href="#五、Transform-Widget" class="headerlink" title="五、Transform Widget"></a>五、Transform Widget</h4><p><code>Transform</code> 是在绘制 Widget 前应用矩阵转换的 Widget 。可以对子 Widget 实现旋转、平移、缩放等操作。一些改造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个可转换其子Widget的Widget，可同时设置旋转、平移、缩放等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Transform(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Matrix4类型必传参数，设置变换矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.transform,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型可选命名参数，应用矩阵的坐标系的原点(相对于此渲染对象的左上角)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.origin,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，对齐方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，执行命中测试时是否应用转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) </span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个围绕指定中心点旋转一定弧度的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Transform.rotate(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，旋转的弧度()，它以顺时针角度给出旋转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">double</span> angle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型可选命名参数，应用矩阵的坐标系的原点(相对于此渲染对象的左上角)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.origin,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，对齐方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，执行命中测试时是否应用转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个指定偏移量平移的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Transform.translate(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型必传参数，应用矩阵的坐标系的原点(相对于此渲染对象的左上角)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> Offset offset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，执行命中测试时是否应用转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个指定缩放比例均匀缩放子Widget的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Transform.scale(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，缩放比例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="built_in">double</span> scale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型可选命名参数，应用矩阵的坐标系的原点(相对于此渲染对象的左上角)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.origin,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，对齐方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，执行命中测试时是否应用转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.transformHitTests = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Matrix4</code> 是一个 <code>4*4</code> 的矩阵，值按列存储。其可以通过设置 <code>4*4</code> 的数值来设置矩阵，也可以直接使用其提供的构造方法，以后会详细介绍 <code>Matrix4</code> 。</p>
<p><code>Transform</code> 的使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.blueGrey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Transform(						<span class="comment">//Transform</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                transform: Matrix4.rotationZ(pi/<span class="number">180</span>*<span class="number">45</span>)..scale(<span class="number">0.5</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                alignment: Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Matrix4.rotationZ()</code> 设置的值为弧度，如果想使用角度需要做转换，<code>1角度=π/180</code> 。使用 pi 值需要添加系统数学库 <code>import &#39;dart:math&#39;;</code> 。上述代码为旋转45度并缩放至 0.5 倍 。使用 <code>Transform</code> 需要注意，其原点位于其所在 Widget 的左上角，而非其子 Widget 的左上角。针对上述代码可以通过 <code>Alignment.center</code> 改变原点，或者设置 <code>origin: Offset(80, 80)</code> 。效果如下：</p>
<img src="/content/df87830f/2020326605.jpg" alt="2020326605" style="zoom:50%;">



<p><code>Transform.rotate</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.blueGrey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Transform.rotate(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                angle: pi/<span class="number">180</span>*<span class="number">45</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/2020326609.jpg" alt="2020326609" style="zoom:50%;">



<p><code>Transform.translate</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.blueGrey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Transform.translate(     <span class="comment">//Transform.translate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                offset: Offset(<span class="number">80</span>, <span class="number">80</span>),       <span class="comment">//x，y轴移动80</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/2020326613.jpg" alt="2020326613" style="zoom:50%;">



<p><code>Transform.scale</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">160</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.blueGrey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Transform.scale(   		<span class="comment">//Transform.scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                scale: <span class="number">0.8</span>,									<span class="comment">//缩放为原来的0.8倍</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/2020326615.jpg" alt="2020326615" style="zoom:50%;">



<h4 id="六、RotatedBox-Widget"><a href="#六、RotatedBox-Widget" class="headerlink" title="六、RotatedBox Widget"></a>六、RotatedBox Widget</h4><p><code>RotatedBox</code> 是一个将其子 Widget 旋转整数倍的 Widget 。与 <code>Transform</code> 不同的是，<code>Transform</code> 是在绘制之前进行变换操作，这意味着在计算其子 Widget 消耗空间时不考虑转换操作(计算前转换已完成)。而 <code>RotatedBox</code> 是对象布局之前应用旋转，意味着旋转要消耗其子 Widget 所需的空间。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RotatedBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，顺时针旋转四分之一圈的次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.quarterTurns,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: RotatedBox(        <span class="comment">//RotatedBox</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            quarterTurns: <span class="number">1</span>,    <span class="comment">//相当于旋转90度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"hello"</span>, style: TextStyle(fontSize: <span class="number">30</span>, backgroundColor: Colors.red),)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/2020326900.jpg" alt="2020326900" style="zoom:50%;">



<h4 id="七、IntrinsicHeight-And-IntrinsicWidth-Widget"><a href="#七、IntrinsicHeight-And-IntrinsicWidth-Widget" class="headerlink" title="七、IntrinsicHeight And IntrinsicWidth Widget"></a>七、IntrinsicHeight And IntrinsicWidth Widget</h4><p><code>IntrinsicHeight</code> 是一种根据子 Widget 固定高度来调整子 Widget 高度的 Widget，<code>IntrinsicWidth</code> 是一种根据子 Widget 固定宽度来调整子 Widget 大小的 Widget。这两个 Widget 会根据可用空间来尽量完全的展示子 Widget 的原始大小。如果有容器限制尺寸情况，这两个 Widget 会在子 Widget 比例保持不变的情况下进行缩放，但是最大尺寸就是原始尺寸。但是这两个布局 Widget 的使用成本比较高，因为他们是在最终布局之前添加了一个推测性布局遍历。构造方法分别为：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IntrinsicHeight</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IntrinsicHeight(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IntrinsicWidth(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，不为null，则强制子Widget的宽度为该值的倍数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.stepWidth, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，不为null，则强制子Widget的高度为该值的倍数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.stepHeight, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: IntrinsicWidth(				<span class="comment">//IntrinsicWidth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            stepHeight: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            stepWidth: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="八、DecoratedBox-Widget"><a href="#八、DecoratedBox-Widget" class="headerlink" title="八、DecoratedBox Widget"></a>八、DecoratedBox Widget</h4><p><code>DecoratedBox</code> 是在子 Widget 绘制之前或之后绘制装饰的 Widget ，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DecoratedBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Decoration类型必传参数，设置装饰属性，通常使用BoxDecoration.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.decoration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DecorationPosition类型可选命名参数，在子Widget的后面还是前面绘制装饰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.position = DecorationPosition.background,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>关于 <code>BoxDecoration</code> 在组件基础(六)中介绍过，地址为：<a href="http://www.mwpush.com/content/a04d6e7.html">http://www.mwpush.com/content/a04d6e7.html</a> 。</p>
<p><code>DecorationPosition</code> 用于设置在子 Widget 后面还是前面绘制装饰，是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DecorationPosition &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在后面绘制装饰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  background,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在前面绘制装饰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  foreground,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>DecoratedBox</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: DecoratedBox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          decoration: BoxDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            border: Border.all(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">4</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              style: BorderStyle.solid,     <span class="comment">//边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            borderRadius: BorderRadius.all(Radius.circular(<span class="number">20</span>)),  <span class="comment">//圆角</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          position: DecorationPosition.background,  <span class="comment">//设置前景图片将被覆盖掉,因为设置了颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/2020326950.jpg" alt="2020326950" style="zoom:50%;">



<h4 id="九、Baseline-Widget"><a href="#九、Baseline-Widget" class="headerlink" title="九、Baseline Widget"></a>九、Baseline Widget</h4><p><code>Baseline</code> 是一个根据子 Widget 的基线放置子 Widget 的 Widget 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Baseline(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型必传参数，从顶部开始放置子Widget基线的逻辑像素，子Widget底部距离顶部的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.baseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextBaseline类型必传参数，用于定位子Widget基线的类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.baselineType,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>TextBaseline</code> 是设置用于对齐文本的水平线，其为一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> TextBaseline &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//用于对齐字母字符的字形底部的水平线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  alphabetic,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//用于对齐表意字符的水平线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ideographic,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Baseline</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: Row(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Baseline(							<span class="comment">//Baseline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              baseline: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              baselineType: TextBaseline.alphabetic,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"Hello"</span> ,style: TextStyle(fontSize: <span class="number">30</span>, backgroundColor: Colors.red),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Baseline(							<span class="comment">//Baseline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              baseline: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              baselineType: TextBaseline.alphabetic,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/df87830f/20203261026.jpg" alt="20203261026" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(八)</title>
    <url>/content/c35669eb.html</url>
    <content><![CDATA[<h4 id="一、Stack-Widget"><a href="#一、Stack-Widget" class="headerlink" title="一、Stack Widget"></a>一、Stack Widget</h4><p><code>Stack</code> Widget 可以用来设置多个子 Widget ，这些子 Widget 以堆叠的方式进行排列。<code>Stack</code> 的子 Widget 可以分为已定位和未定位，定位使用 <code>Positioned</code> Widget 配合 <code>Stack</code> 一起使用。<code>Stack</code> 本身的大小将包含所有未定位的子 Widget ，这些子 Widget 根据对齐方式定位(在从左到右的环境中，默认为左上角，在从右到左的环境中，默认为右上角)。然后根据已定位的子 Widget 的上、右、下、左的属性相对于 <code>Stack</code> 放置它们。</p>
<a id="more"></a>

<p><code>Stack</code> 的构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stack(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，如何对齐Stack中未定位和部分定位的子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//使用AlignmentDirectional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = AlignmentDirectional.topStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，文本对齐方向设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//StackFit类型可选命名参数，如何调整Stack中未定位的子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fit = StackFit.loose,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Overflow类型可选命名参数，设置溢出部分如何剪裁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.overflow = Overflow.clip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>AlignmentDirectional</code> 用于设置如何对齐 <code>Stack</code> 中未定位和部分定位的子 Widget 。对于未定位的子 Widget 项彼此相对放置，以使通过对齐确定的点位于同一位置。部分定位的子 Widget 指的是未在特定轴上指定对齐方式的子 Widget ，使用对齐方式来确定应如何在未指定的轴上定位它们。<code>AlignmentDirectional</code> 的构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个参数均为double类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AlignmentDirectional(<span class="keyword">this</span>.start, <span class="keyword">this</span>.y)</span></pre></td></tr></table></figure>

<p>可以使用构造方法设置，也可以直接使用提供好的位置静态属性，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The top corner on the "start" side.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional topStart = AlignmentDirectional(<span class="number">-1.0</span>, <span class="number">-1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the top edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">///</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Consider using [Alignment.topCenter] instead, as it does not need</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">to be [resolve]d to be used.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional topCenter = AlignmentDirectional(<span class="number">0.0</span>, <span class="number">-1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The top corner on the "end" side.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional topEnd = AlignmentDirectional(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the "start" edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional centerStart = AlignmentDirectional(<span class="number">-1.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point, both horizontally and vertically.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">///</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Consider using [Alignment.center] instead, as it does not need to</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">be [resolve]d to be used.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional center = AlignmentDirectional(<span class="number">0.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the "end" edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional centerEnd = AlignmentDirectional(<span class="number">1.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The bottom corner on the "start" side.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional bottomStart = AlignmentDirectional(<span class="number">-1.0</span>, <span class="number">1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the bottom edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">///</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">Consider using [Alignment.bottomCenter] instead, as it does not</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">need to be [resolve]d to be used.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional bottomCenter = AlignmentDirectional(<span class="number">0.0</span>, <span class="number">1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The bottom corner on the "end" side.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AlignmentDirectional bottomEnd = AlignmentDirectional(<span class="number">1.0</span>, <span class="number">1.0</span>);</span></pre></td></tr></table></figure>

<p>位置属性简单易懂，不做中文说明了。<code>AlignmentDirectional</code> 的设置与 <code>TextDirection</code> 是关系的，对于不同的环境方向，<code>AlignmentDirectional</code> 的起始位置也不同。</p>
<p><code>StackFit</code> 用于设置如何调整Stack中未定位的子 Widget ，其是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> StackFit &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//从其父级传递到Stack的约束被放宽了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//例如：如果Stack具有强制其为350x600的约束，那么这将允许Stack的未定位子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//具有从0到350的任何宽度和从0到600的任何高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  loose,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//从其父级传递到Stack的约束被收紧到允许的最大大小。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//例如：如果Stack具有宽度在10到100范围内、高度在0到600范围内的松散约束，则Stack中未</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//定位的子级的大小都将为100像素宽、600像素高</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  expand,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//从其父级传递到Stack的约束未修改地传递到未定位的子级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//例如：如果Stack是行的扩展子级，则水平约束将是紧的，而垂直约束将是松的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  passthrough,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Stack</code> 的使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">500</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child:Stack(              <span class="comment">//Stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: AlignmentDirectional.topStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          textDirection: TextDirection.ltr,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fit: StackFit.loose,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          overflow: Overflow.clip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Stack1"</span>, style: TextStyle(color: Colors.blue, fontSize: <span class="number">30</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Stack2"</span>,style: TextStyle(color: Colors.red, fontSize: <span class="number">20</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c35669eb/2020324102.jpg" alt="2020324102" style="zoom:50%;">



<p>定位 Widget 使用 <code>Positioned</code> ，用于控制 <code>Stack</code> 的子 Widget 的位置。如果一个 Widget 包装在 <code>Positioned</code> 中，那么这个 Widget 就是 <code>Stack</code> 中的一个定位 Widget 。如果单独设置 <code>top</code> 则表示该子 Widget 距离 <code>Stack</code> 顶部的距离，同时设定 <code>top</code> 和 <code>bottom</code> 则子 Widget 会根据设置调整子 Widget 的高度以使其满足顶部和底部的距离，左右也是一样。其中 <code>top</code> 、<code>bottom</code> 和 <code>height</code> 只能同时设置其中的两项，另外一项必须为空，如果都为空，则使用 <code>Stack</code> 的 <code>alignment</code> 在垂直方向进行定位。 <code>left</code> 、<code>right</code> 和 <code>width</code> 也只能设置其中两项，另外一项必须为空，如果所有都为空，则使用 <code>Stack</code> 的 <code>alignment</code> 在水平方向进行定位。</p>
<p> <code>Positioned</code> 的构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Positioned(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，子Widget底部距离Stack左边的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.left,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，子Widget底部距离Stack顶部的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.top,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，子Widget底部距离Stack右边的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.right,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，子Widget底部距离Stack底部的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottom,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，子Widget的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，子Widget的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">500</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child:Stack(              <span class="comment">//Stack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: AlignmentDirectional.topStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          textDirection: TextDirection.ltr,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fit: StackFit.loose,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          overflow: Overflow.clip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Positioned(				<span class="comment">//Positioned</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              bottom: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              top: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              left: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Container(child: Text(<span class="string">"Stack1"</span>, style: TextStyle(color: Colors.blue, fontSize: <span class="number">30</span>,), ), color: Colors.red,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Stack2"</span>,style: TextStyle(color: Colors.red, fontSize: <span class="number">20</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c35669eb/2020324208.jpg" alt="2020324208" style="zoom:50%;">



<h4 id="二、IndexedStack-Widget"><a href="#二、IndexedStack-Widget" class="headerlink" title="二、IndexedStack Widget"></a>二、IndexedStack Widget</h4><p><code>Stack</code> 可以显示一组 Widget ，<code>IndexedStack</code> 继承自 <code>Stack</code> ，用于选择性的只显示一组 Widget 中的一个。要显示的 Widget 通过 <code>index</code> 索引设置，编号从 0 开始。<code>IndexedStack</code> 的大小总是和一组 Widget 中的最大的 Widget 一样大。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">IndexedStack(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，如何对齐Stack中未定位和部分定位的子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//使用AlignmentDirectional</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  AlignmentGeometry alignment = AlignmentDirectional.topStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，文本对齐方向设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextDirection textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//StackFit类型可选命名参数，如何调整Stack中未定位的子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  StackFit sizing = StackFit.loose,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>IndexedStack</code> 只比 <code>Stack</code> 多了一个 <code>index</code> 属性，其他属性相同，默认显示 Widget 列中的第一个 Widget ，下标为 0 。<code>IndexedStack</code> 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">500</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child:IndexedStack(              <span class="comment">//IndexedStack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: AlignmentDirectional.topStart,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          textDirection: TextDirection.ltr,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          sizing: StackFit.loose,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          index: <span class="number">2</span>,       <span class="comment">//要显示的Widget的下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Positioned(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              bottom: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              top: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              left: <span class="number">120</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Container(child: Text(<span class="string">"Stack1"</span>, style: TextStyle(color: Colors.blue, fontSize: <span class="number">30</span>,), ), color: Colors.red,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Stack2"</span>,style: TextStyle(color: Colors.red, fontSize: <span class="number">20</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="三、SizedBox-Widget"><a href="#三、SizedBox-Widget" class="headerlink" title="三、SizedBox Widget"></a>三、SizedBox Widget</h4><p><code>SizedBox</code> 是设置固定尺寸的 Widget ，如果设置了宽高，则子 Widget 会被强制为 <code>SizedBox</code> 的尺寸，如果不设置宽高，则 <code>SizedBox</code> 的尺寸将与子 Widget 相同。 如果没有给定子 Widget ，<code>SizedBox</code> 将尝试在给定父对象约束的情况下，将自身的大小调整到尽可能接近指定的高度和宽度。如果高度或宽度为空或未指定，将被视为零。</p>
<p>有以下几个构造方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建固定尺寸的SizedBox，宽高可以为空，此时表示大小不受限制</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SizedBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，设置SizedBox的宽度，子Widget也会具有此宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，设置SizedBox的高度，子Widget也会具有此高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个将变得与其父级允许一样大的SizedBox，等效于将width和height设置为double.infinity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SizedBox.expand(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个将变得尽可能小的SizeBox</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SizedBox.shrink(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个指定尺寸的SizeBox</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">SizedBox.fromSize(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Size类型可选命名参数，设置SizedBox的尺寸，子Widget也具有此尺寸</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Size size</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: SizedBox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          width: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            height: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里的子 Widget 是 <code>Container</code> ，虽然 <code>Container</code> 也设置了宽高，但是没有生效，其宽高与 <code>SizedBox</code> 相同。但是如果子 Widget 不能设置宽高属性，则子 Widget 的大小不会与 <code>SizedBox</code> 设置的相同，但是会受其最大尺寸约束。上述代码效果如下：</p>
<img src="/content/c35669eb/2020324330.jpg" alt="2020324330" style="zoom:50%;">



<h4 id="四、Flex-Widget"><a href="#四、Flex-Widget" class="headerlink" title="四、Flex Widget"></a>四、Flex Widget</h4><p><code>Flex</code> 使用一维数组来设置一组子 Widget ，其可以通过设置主轴的方向来控制水平或垂直显示 Widget ，它是上篇文章中介绍过的 <code>Row</code> 和 <code>Column</code> 的父类。如果在使用前已知要显示的 Widget 的方向，应考虑使用 <code>Row</code> 或 <code>Column</code> 。</p>
<p><code>Flex</code> 是一个不可以滚动的 Widget ，当要显示的 Widget 超过可用范围则会抛出异常。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Flex(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Axis类型必传参数，设置主轴的方向(垂直或者水平)，不设置会抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.direction,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisAlignment类型可选命名参数，如何沿着主轴放置子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.mainAxisAlignment = MainAxisAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisSize类型可选命名参数，主轴上应占用多少空间，该值传入最大化还是最小化可用空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.mainAxisSize = MainAxisSize.max,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CrossAxisAlignment类型可选命名参数，如何沿着次轴放置子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.crossAxisAlignment = CrossAxisAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，设置子Widget横向的排列方向，默认为环境方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VerticalDirection类型可选命名参数，设置子Widget纵向的排列顺序以及如何解释垂直方向的开始和结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextBaseline类型可选命名参数，果根据基线对齐项目，使用哪个基线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textBaseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的Widgets</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Axis</code> 用于设置主轴的方向，即要显示的 Widgets 的排列方向，是一个枚举类型值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Axis &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//水平排列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//垂直排列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其他属性在上一篇文章做过说明，可查看上篇文章的 <code>Row</code> 部分。 <code>Flex</code> 的使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Flex(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        direction: Axis.horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"Text1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"Text2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"Text3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"Text4"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Text(<span class="string">"Text5"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="五、Expanded-Widget"><a href="#五、Expanded-Widget" class="headerlink" title="五、Expanded Widget"></a>五、Expanded Widget</h4><p><code>Expanded</code> 是用来扩展 <code>Row</code> 、<code>Column</code> 或 <code>Flex</code> 的子 Widget ，其作用是按一定比例填充子 Widgets 间的可用空间。如果要扩展多个 Widget ，可以通过设置扩展因子在可用空间进行空间分配。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，扩展因子  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> flex = <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，要显示的Widget </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> Widget child,  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Flex(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        direction: Axis.horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Expanded(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(child: Text(<span class="string">"Text1"</span>), color: Colors.red, height: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            flex: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Expanded(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(child: Text(<span class="string">"Text2"</span>), color: Colors.blue, height: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            flex: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Expanded(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Container(child: Text(<span class="string">"Text3"</span>), color: Colors.yellow, height: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            flex: <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c35669eb/2020324508.jpg" alt="2020324508" style="zoom:50%;">

<p>上面的代码中设置了扩展因子，是倍数关系，所以显示的结果宽度也是倍数关系，如果是垂直排列 Widget ，则高度是倍数关系。不设置扩展因子则子 Widget 会平均分配可用空间。也可以单独设置某个子 Widget 的扩展因子。</p>
<h4 id="六、Wrap-Widget"><a href="#六、Wrap-Widget" class="headerlink" title="六、Wrap Widget"></a>六、Wrap Widget</h4><p><code>Wrap</code> 也可以显示多个子 Widget ，其可以设置排列方向(水平或者垂直)显示 Widgets ，与 <code>Row</code> 和 <code>Column</code> 的不同之处在于，<code>Row</code> 和 <code>Column</code> 在可用空间无法显示全部 Widget 时会抛出异常，而 <code>Warp</code> 显示不下时会自动换行。</p>
<p>构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Wrap(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Axis类型可选命名参数，设置主轴的方向(垂直或者水平)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.direction = Axis.horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//WrapAlignment类型可选命名参数，在主轴上如何排列子Widgets</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = WrapAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，主轴上排列的每个Widget之间的间隙</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.spacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//WrapAlignment类型可选命名参数，!!!没有整明白此参数的作用，使用也没有看到效果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.runAlignment = WrapAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，如果是横向排列则是每行之间的间距，纵向排列则是每列之间的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.runSpacing = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//WrapCrossAlignment类型可选命名参数，如何沿着次轴放置子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，设置子Widget横向的排列方向，默认为环境方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VerticalDirection类型可选命名参数，设置子Widget纵向的排列顺序以及如何解释垂直方向的开始和结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的Widgets</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.amber,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Wrap(						<span class="comment">//Wrap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          direction: Axis.horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          textDirection: TextDirection.ltr,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: WrapAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          crossAxisAlignment: WrapCrossAlignment.end,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          spacing: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          runSpacing: <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          runAlignment: WrapAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text1"</span>), color: Colors.red, height: <span class="number">100</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text2"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">100</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text3"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text4"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text5"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text6"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text7"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text8"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text9"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text10"</span>), color: Colors.red, height: <span class="number">50</span>, width: <span class="number">50</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Text11"</span>), color: Colors.red, height: <span class="number">30</span>, width: <span class="number">120</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c35669eb/2020325953.jpg" alt="2020325953" style="zoom:50%;">



<h4 id="七、FittedBox-Widget"><a href="#七、FittedBox-Widget" class="headerlink" title="七、FittedBox Widget"></a>七、FittedBox Widget</h4><p><code>FittedBox</code> 用于管理子 Widget 在其父级 Widget 如何对齐和缩放。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FittedBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BoxFit类型可选命名参数，如何适配子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fit = BoxFit.contain,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，如何在父级范围内对齐子Widget，使用Alignment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: FittedBox(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fit: BoxFit.fitHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: Alignment.topLeft,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>BoxFit</code> 的设置和样式可以查看官网，地址为：<a href="https://api.flutter.dev/flutter/painting/BoxFit-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/painting/BoxFit-class.html</a> 。</p>
<p>上述代码效果如下：</p>
<img src="/content/c35669eb/20203241037.jpg" alt="20203241037" style="zoom:50%;">



<h4 id="八、OverflowBox-Widget"><a href="#八、OverflowBox-Widget" class="headerlink" title="八、OverflowBox Widget"></a>八、OverflowBox Widget</h4><p>通常，当一个子 Widget 在 父 Widget 中时，子 Widget 是受父 Widget 的约束限制的，超出父 Widget 的部分一般会被截掉。如果想子 Widget 不受父 Widget 的限制，可以使用 <code>OverflowBox</code> ，它是一个溢出 Widget ，可以使用与父 Widget 不同的约束。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OverflowBox(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，如何在父级范围内对齐子Widget，使用Alignment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最小宽度，不设置(默认值)，使用父级约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最大宽度，不设置(默认值)，使用父级约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最小高度，不设置(默认值)，使用父级约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，最大高度，不设置(默认值)，使用父级约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: OverflowBox(				<span class="comment">//OverflowBox</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          minHeight: <span class="number">100</span>,	</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxHeight: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          minWidth: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxWidth: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: Alignment.topRight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/c35669eb/2020325929.jpg" alt="2020325929" style="zoom:50%;">



<h4 id="九、Offstage-Widget"><a href="#九、Offstage-Widget" class="headerlink" title="九、Offstage Widget"></a>九、Offstage Widget</h4><p>在开发中，有时候需要根据需要来对某个 Widget 进行显示或隐藏，就可以使用 <code>Offstage</code> 。当 <code>Offstage</code> 设置为隐藏时，其不接收任何事件，也不占用父级的任何空间。但如果在 <code>Offstage</code> 中有动画执行，即便其为隐藏状态，动画都会在后台继续执行，会消耗电量和 CPU 。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Offstage(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否隐藏子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.offstage = <span class="keyword">true</span>, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示或隐藏的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child:  Offstage(					<span class="comment">//Offstage</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          offstage: <span class="keyword">false</span>,       <span class="comment">//当设置为true时，在界面上不会显示Text</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Offstage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(七)</title>
    <url>/content/a04d6e7.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>因为很多的基础小部件( <code>Widget</code> ) 依赖于布局 <code>Widget</code> ，所以在本套基础讲解中，会穿插各种 Widget 的说明，并没有按照一定的分组顺序进行讲解。就是用到什么讲解什么，但是力争做到讲解的够清晰。所以现在开始说明一些基础的布局 Widget， 后续很多其他的 Widget 在使用中会依赖于或用到布局的 Widget ，所以在此先进行说明。</p>
<a id="more"></a>

<h4 id="二-、Container-Widget"><a href="#二-、Container-Widget" class="headerlink" title="二 、Container Widget"></a>二 、Container Widget</h4><p>容器 Widget ，其是一个可以设置宽高，边距，装饰等的 Widget ，有一个子 Widget 属性 <code>child</code> 。如果没有设置子 Widget ，容器会尽可能大的展示。它继承自 <code>StatelessWidget</code> ，是一个无状态的 Widget 。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，容器内子Widget如何对其，使用其子类Alignment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，设置容器内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，容器填充色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Decoration类型可选命名参数，绘制在child子Widget后面的装饰，使用BoxDecoration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Decoration decoration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Decoration类型可选命名参数，绘制在child子Widget前面的装饰，使用BoxDecoration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.foregroundDecoration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，容器的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，容器的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BoxConstraints类型可选命名参数，对child设置的Widget的约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BoxConstraints constraints,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，设置容器外边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.margin,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Matrix4类型可选命名参数，在绘制容器之前要应用的转换矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.transform,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，容器包含的子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中 <code>color</code> 与 <code>decoration</code> 不能同时设置。</p>
<p><code>Decoration</code> 是一个抽象类，这里需要使用 <code>BoxDecoration</code> ，是一个用于设置如何绘制盒子的不可变的的描述。盒子的主体是分层绘制的。 最底层是颜色，它填充了框。 在此之上的是渐变，渐变也填充了该框。 最后是图像，其精确对齐由 <code>DecorationImage</code> 类控制。边框涂在身体上，阴影自然在其下方绘制。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxDecoration(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，填充背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DecorationImage类型可选命名参数，在背景或渐变上绘制的图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.image,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BoxBorder类型可选命名参数，边框设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.border,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderRadiusGeometry类型可选命名参数，设置圆角</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.borderRadius,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;BoxShadow&gt;类型可选命名参数，盒子后面的盒子投射的阴影列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.boxShadow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Gradient类型可选命名参数，填充框时使用的渐变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.gradient,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BlendMode类型可选命名参数，应用于框的颜色或渐变背景的混合模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundBlendMode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BoxShape类型可选命名参数，将背景颜色、渐变和图像填充到并作为boxShadow投射的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape = BoxShape.rectangle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Container</code> 基本使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(    <span class="comment">//Container</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此时的 <code>Container</code> 会充满整个屏幕，尽可能大。</p>
<p>其它属性设置</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(				<span class="comment">//Container</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"这是一个文本"</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        alignment: Alignment.topCenter,  <span class="comment">//子Widget的相对于父级Container的对齐方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.all(<span class="number">20</span>),   <span class="comment">//设置内边距，文本的每个边外都有20的边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        margin: EdgeInsets.all(<span class="number">50</span>),   <span class="comment">//设置外边距，Container每个边外有50的外边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,    <span class="comment">//填充色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        transform: Matrix4.rotationZ(<span class="number">0.2</span>),   <span class="comment">//围绕Z轴旋转指定弧度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        foregroundDecoration: BoxDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          image: DecorationImage(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            image: NetworkImage(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fit: BoxFit.fill</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          border: Border.all(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.blue</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a04d6e7/20203201145.jpg" alt="20203201145" style="zoom:50%;">

<p><code>foregroundDecoration</code> 用于设置前景装饰效果，所以如果有重叠，当加载图片时会覆盖 <code>Container</code> 本身的内容。如果不希望覆盖，使用背景装饰效果 <code>decoration</code> 即可，使用方式相同，只是使用 <code>decoration</code> 时不能使用 <code>color</code> ，使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"这是一个文本"</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        alignment: Alignment.topCenter,  <span class="comment">//子Widget的相对于父级Container的对齐方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.all(<span class="number">20</span>),   <span class="comment">//设置内边距，文本的每个边外都有20的边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        margin: EdgeInsets.all(<span class="number">50</span>),   <span class="comment">//设置外边距，Container每个边外有50的外边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        transform: Matrix4.rotationZ(<span class="number">0.2</span>),   <span class="comment">//围绕Z轴旋转指定弧度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        constraints: BoxConstraints(    <span class="comment">//设置最大最小约束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          minHeight: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          minWidth: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxHeight: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          maxWidth: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        decoration: BoxDecoration( 		<span class="comment">//decoration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          image: DecorationImage(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            image: NetworkImage(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fit: BoxFit.fill</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          border: Border.all(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            width: <span class="number">5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.blue</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          borderRadius: BorderRadius.all(Radius.circular(<span class="number">10</span>)),  <span class="comment">//设置圆角</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a04d6e7/2020321827.jpg" alt="2020321827" style="zoom:50%;">



<p><code>BoxDecoration</code> 还可以设置渐变色等属性。</p>
<h4 id="三、Center-Widget"><a href="#三、Center-Widget" class="headerlink" title="三、Center Widget"></a>三、Center Widget</h4><p><code>Center</code> 是将子 Widget 放置于其中心的 Widget 。如果其宽高没有设置，则其会尽可能大的展示。可通过设置宽度与高度因子来控制大小。比如设置宽度因子后，<code>Center</code> 的宽度值为子 Widget 的宽度乘以宽度因子的值。宽度与高度因子的值必须为正数。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Center(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，宽度因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> widthFactor, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，高度因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> heightFactor, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellowAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Center(				<span class="comment">//Center</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          widthFactor: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          heightFactor: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"中心文本"</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里为了看清显示的效果，使用了 <code>Container</code> Widget 来包裹 <code>Center</code> 和 <code>Center</code> 的 <code>child</code> Widget ，因为 <code>Container</code> 可以设置填充色，便于区分。效果如下：</p>
<img src="/content/a04d6e7/2020322752.jpg" alt="2020322752" style="zoom:50%;">





<h4 id="四、Padding-Widget"><a href="#四、Padding-Widget" class="headerlink" title="四、Padding Widget"></a>四、Padding Widget</h4><p><code>Padding</code> 是用来设置内填充(内边距)的 Widget ，在 <code>Container</code> 中也可以设置 <code>Container</code> 的 <code>padding</code> ，两者并没有区别。<code>Container</code> 是将多个单独的 Widget 进行组合使用，需要时只需设置相应的属性即可。作用是通过设置内边距的大小使其进行膨胀，在其子 Widget 周围创造出一定的空间。其构造函数方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Padding(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型必传参数，内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方法如下，与上述 <code>Center</code> 实现效果差不多，代码中的 <code>Container</code> 也是为了使效果看的更清晰：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Padding( 			<span class="comment">//Padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          padding: EdgeInsets.all(<span class="number">50</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"Padding"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="五、Align-Widget"><a href="#五、Align-Widget" class="headerlink" title="五、Align Widget"></a>五、Align Widget</h4><p><code>Align</code> 可以设置其子 Widget 相对自己的对齐方式，并可以根据子 Widget 的大小调整其自己的大小。其可以设置宽度和高度因子，如果不设置，则其会尽可能的大的展示，如果设置，比如设置宽度因子，则 <code>Align</code> 的宽度将是其子 <code>Widget</code> 的宽度乘以宽度因子。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Align(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，设置如何对齐，AlignmentGeometry为抽象类，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//通常使用Alignment或FractionalOffset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，宽度因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.widthFactor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，高度因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.heightFactor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Align</code> 与 <code>Center</code> 类似，不同的是 <code>Align</code> 可以设置其子 Widget 相对于自己的对齐方式，而 <code>Center</code> 则是居中对齐。</p>
<p><code>Alignment</code> 在此用来设置对其方式，其定义的是一个矩形中的点。其提供了几种对齐方式可以直接使用，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The top left corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment topLeft = Alignment(<span class="number">-1.0</span>, <span class="number">-1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the top edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment topCenter = Alignment(<span class="number">0.0</span>, <span class="number">-1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The top right corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment topRight = Alignment(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the left edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment centerLeft = Alignment(<span class="number">-1.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point, both horizontally and vertically.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment center = Alignment(<span class="number">0.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the right edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment centerRight = Alignment(<span class="number">1.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The bottom left corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment bottomLeft = Alignment(<span class="number">-1.0</span>, <span class="number">1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the bottom edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment bottomCenter = Alignment(<span class="number">0.0</span>, <span class="number">1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The bottom right corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Alignment bottomRight = Alignment(<span class="number">1.0</span>, <span class="number">1.0</span>);</span></pre></td></tr></table></figure>

<p>比较简单，不做中文说明。从其定义可以看出，其定义的方式都是使用 <code>Alignment()</code> 构造方法，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x，y均为double类型的必传参数，用于定义一个点的x和y轴值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Alignment(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y)</span></pre></td></tr></table></figure>

<p>所以可以直接使用构造函数定义需要通过哪个点对齐，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Align(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Container(child: Text(<span class="string">"Align"</span>), color: Colors.red,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          alignment: Alignment(<span class="number">0.2</span>, <span class="number">0.5</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          widthFactor: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          heightFactor: <span class="number">10</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Alignment(0.0, 0.0)</code> 表示矩形的中心点。从 -1.0 到 +1.0 的距离是从矩形的一侧到矩形的另一侧的距离。 因此，水平（或垂直）2.0 个单位等于矩形的宽度（或高度）。<code>Alignment(-1.0, -1.0)</code> 表示矩形的左上方，<code>Alignment(1.0, 1.0)</code> 表示矩形的右下角。<code>Alignment(0.0, 3.0)</code> 表示一个点，该点相对于矩形水平居中，垂直于矩形底部低于矩形的高度。<code>Alignment(0.0, -0.5)</code>表示相对于矩形水平居中且顶部边缘与中心之间垂直居中的点。</p>
<p>以上面的代码为例，其对齐的点的计算方法为<code>( 0.2*Text的宽度/2 + Text的宽度/2, 0.5*Text的高度/2+Text的高度/2 )</code> 。</p>
<p><code>Alignment</code> 使用的坐标系，其原点位于容器的中心点。</p>
<p><code>FractionalOffset</code> 用来定义一个偏移量，其也提供了几个常用的值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The top left corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset topLeft = FractionalOffset(<span class="number">0.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the top edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset topCenter = FractionalOffset(<span class="number">0.5</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The top right corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset topRight = FractionalOffset(<span class="number">1.0</span>, <span class="number">0.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the left edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset centerLeft = FractionalOffset(<span class="number">0.0</span>, <span class="number">0.5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point, both horizontally and vertically.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset center = FractionalOffset(<span class="number">0.5</span>, <span class="number">0.5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the right edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset centerRight = FractionalOffset(<span class="number">1.0</span>, <span class="number">0.5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The bottom left corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset bottomLeft = FractionalOffset(<span class="number">0.0</span>, <span class="number">1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The center point along the bottom edge.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset bottomCenter = FractionalOffset(<span class="number">0.5</span>, <span class="number">1.0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">The bottom right corner.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FractionalOffset bottomRight = FractionalOffset(<span class="number">1.0</span>, <span class="number">1.0</span>);</span></pre></td></tr></table></figure>

<p>可以看到，其与 <code>Alignment</code> 类似，不同之处在于 <code>Alignment()</code> 定义的是一个点(计算方法在上面)，而 <code>FractionalOffset()</code> 定义的是两个点，这两个点是单独确定的。对于当前 Widget ，这里为 <code>Text</code> ，其点的计算方式为：<code>(0.2*Text的宽度, 0.5*Text的高度)</code> 。对于父级 Widget ，这里为 <code>Container</code> 则是 <code>(0.2*Container的宽度, 0.5*Container的高度)</code> 。最后使两个点重合，即将 <code>Text</code> 的点移动到 <code>Container</code> 定位的点处。使用 </p>
<p><code>FractionalOffset</code> 时，其原点位于容器的左上角。</p>
<p>此外，除了提供 <code>FractionalOffset(double x, double y)</code> 构造方法，另外还提供了如下两个构造方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">factory</span> FractionalOffset.fromOffsetAndSize(Offset offset, Size size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">assert</span>(size != <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">assert</span>(offset != <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> FractionalOffset(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    offset.dx / size.width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    offset.dy / size.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">factory</span> FractionalOffset.fromOffsetAndRect(Offset offset, Rect rect) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> FractionalOffset.fromOffsetAndSize(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    offset - rect.topLeft,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rect.size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>





<h4 id="六、Row-Widget"><a href="#六、Row-Widget" class="headerlink" title="六、Row Widget"></a>六、Row Widget</h4><p><code>Row</code> 是一个可以同时显示多个子 Widget 的 Widget ，这些子 Widget 以水平方式进行排列。<code>Row</code> Widget 不是一个可以滚动的 Widget ，如果水平显示的子 Widget 的总范围超出了可用空间会抛出异常。如果有需要进行水平或垂直方向的滚动操作，考虑使用 <code>ListView</code> ，后面会讲到。<code>Row</code> 的构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisAlignment类型可选命名参数，如何沿着主轴放置子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisSize类型可选命名参数，主轴上应占用多少空间，该值传入最大化还是最小化可用空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CrossAxisAlignment类型可选命名参数，如何沿着次轴放置子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，设置子Widget横向的排列方向，默认为环境方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextDirection textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VerticalDirection类型可选命名参数，设置子Widget纵向的排列顺序以及如何解释垂直方向的开始和结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextBaseline类型可选命名参数，如果根据基线对齐项目，使用哪个基线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextBaseline textBaseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的子Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>MainAxisAlignment</code> 用于设置子 Widget 在主轴(这里是水平方向)上的排列方式，是一个枚举类型，有如下值：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> MainAxisAlignment &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//子Widget放置在尽可能靠近主轴起点的位置。如果在水平方向使用，则必须使</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//用TextDirection来确定起点是左侧还是右侧。如果在垂直方向上使用此值，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则VerticalDirection必须可用以确定起点是顶部还是底部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  start,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	<span class="comment">//子Widget放置在尽可能靠近主轴末端的位置。如果在水平方向上使用此值，则必须使</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//用TextDirection来确定末端是左侧还是右侧。如果在垂直方向上使用此值，则必须</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//使用VerticalDirection来确定末端是顶部还是底部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  end,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//子Widget放置在尽可能靠近主轴的中心</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  center,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//子Widget均匀的放置在可用空间内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  spaceBetween,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//将自由空间平均放置在两个子Widget之间，以及第一个和最后一个Widget前后的一半空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  spaceAround,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在子Widget之间以及第一个Widget和最后一个Widget之前和之后均匀地放置自由空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  spaceEvenly,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>CrossAxisAlignment</code> 用于设置子 Widget 在次轴(这里是垂直方向)上的排列方式，是一个枚举类型，有如下值：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> CrossAxisAlignment &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//子Widget放置在尽可能靠近次轴起点的位置。如果在水平方向上使用此值，则必须使</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//用TextDirection来确定起点是左侧还是右侧。如果在垂直方向上使用此值，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则VerticalDirection必须可用以确定起点是顶部还是底部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  start,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//子Widget放置在尽可能靠近次轴末端的位置。如果在水平方向上使用此值，则必须使</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//用TextDirection来确定末端是左侧还是右侧。如果在垂直方向上使用此值，则必须</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//使用VerticalDirection来确定末端是顶部还是底部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  end,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//子Widget放置在尽可能靠近次轴的中心</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  center,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//子Widget填满次轴</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  stretch,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在次轴上放置子Widget，使其与基线对齐，使用此值需要设置textBaseline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  baseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>VerticalDirection</code> 用于设置垂直的排列方向，是一个枚举类型值，有如下值：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> VerticalDirection &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//盒子应从底部开始，并垂直向上堆叠。“开始”在底部，“结束”在顶部。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  up,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//盒子应从顶部开始，并垂直向下堆叠。“开始”在顶部，“结束”在底部。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  down,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Row</code> 的使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Row(   						<span class="comment">//Row</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          textBaseline: TextBaseline.alphabetic,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          mainAxisAlignment: MainAxisAlignment.spaceAround,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          crossAxisAlignment: CrossAxisAlignment.end,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//            Image.network("http://www.mwpush.com/uploads/avatar.png"),</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Row1"</span>), color: Colors.red,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Row2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Row3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a04d6e7/20203231204.jpg" alt="20203231204" style="zoom:50%;">



<h4 id="七、Column-Widget"><a href="#七、Column-Widget" class="headerlink" title="七、Column Widget"></a>七、Column Widget</h4><p><code>Column</code> 是一个可以同时显示多个子 Widget 的 Widget ，这些子 Widget 以垂直方式进行排列。<code>Column</code> Widget 不是一个可以滚动的 Widget ，如果垂直显示的子 Widget 的总范围超出了可用空间会抛出异常。如果有需要进行水平或垂直方向的滚动操作，考虑使用 <code>ListView</code> 。<code>Column</code> 的构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Column(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisAlignment类型可选命名参数，如何沿着主轴放置子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MainAxisSize类型可选命名参数，主轴上应占用多少空间，该值传入最大化还是最小化可用空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CrossAxisAlignment类型可选命名参数，如何沿着次轴放置子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，设置子Widget横向的排列方向，默认为环境方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextDirection textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VerticalDirection类型可选命名参数，设置子Widget纵向的排列顺序以及如何解释垂直方向的开始和结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextBaseline类型可选命名参数，如果根据基线对齐项目，使用哪个基线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextBaseline textBaseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要显示的子Widget列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>构造方法与 <code>Row</code> 相同，只是排列的基准不同。使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        width: <span class="number">500</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          mainAxisAlignment: MainAxisAlignment.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          crossAxisAlignment: CrossAxisAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//            Image.network("http://www.mwpush.com/uploads/avatar.png"),</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Container(child: Text(<span class="string">"Row1"</span>), color: Colors.red,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Row2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(<span class="string">"Row3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/content/a04d6e7/20203231212.jpg" alt="20203231212" style="zoom:50%;">]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(六)</title>
    <url>/content/950cce6d.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>上篇文章介绍 <code>MaterialApp</code> 、<code>Scaffold</code> ，但是没有内容比较多，没有介绍完毕。本篇文章继续上文继续说明。</p>
<a id="more"></a>

<h4 id="二、-Scaffold-Widget-补充"><a href="#二、-Scaffold-Widget-补充" class="headerlink" title="二、 Scaffold Widget 补充"></a>二、 Scaffold Widget 补充</h4><p><code>bottomNavigationBar</code> 是 <code>Scaffold</code> 的属性，用来设置应用程序的底部应用或导航栏，其是一个 Widget ，通常使用 <code>BottomAppBar</code> 或 <code>BottomNavigationBar</code> 。主要用来显示消息以及提供特定功能的导航。</p>
<p><code>BottomAppBar</code> 是一个顶部可以有凹口的 Widget ，是一个 <code>StatefulWidget</code> 。通常与 <code>FloatingActionButton</code> 一起使用。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BottomAppBar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，底部程序栏的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父应用程序栏放置底部应用程序栏的z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//NotchedShape类型可选命名参数，为浮动操作按钮制作的凹槽</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，设置内容裁剪方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，浮动动作按钮和底部应用栏的凹口之间的边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.notchMargin = <span class="number">4.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyFirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Center(child: Text(<span class="string">"主体内容"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      bottomNavigationBar: BottomAppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"底部BottomAppBar"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButton: FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">print</span>(<span class="string">"点击"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果不提供 <code>BottomAppBar</code> 的 <code>child</code> 设置，不会抛出异常，但是不会显示 <code>BottomAppBar</code> 。</p>
<p>本例的效果如下：</p>
<p><img src="/content/950cce6d/2020312245.jpg" alt="2020312245"></p>
<p>如果想要设置 <code>BottomAppBar</code> 的高度，可以通过嵌套使用带有高度的 Widget ，如下使用 <code>Container</code> ：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Center(child: Text(<span class="string">"主体内容"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      bottomNavigationBar: BottomAppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"底部BottomAppBar"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">50.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButton: FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">print</span>(<span class="string">"点击"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="/content/950cce6d/2020312513.jpg" alt="2020312513"></p>
<p>使用有凹口的 <code>BottomAppBar</code> 需要 <code>shape</code> 和 <code>FloatingActionButtonLocation.centerDocked</code> 或 <code>FloatingActionButtonLocation.endDocked</code> 配合使用。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Center(child: Text(<span class="string">"主体内容"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      bottomNavigationBar: BottomAppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shape: <span class="keyword">const</span> CircularNotchedRectangle(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">50.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButton: FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">print</span>(<span class="string">"点击"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/950cce6d/2020312725.jpg" alt="2020312725"></p>
<p><code>BottomAppBar</code> 中也可以显示多个 <code>Widget</code> ，需要使用 <code>Row</code> 横向布局 Widget 容器，后面会详细介绍 <code>Row</code> 。使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Center(child: Text(<span class="string">"主体内容"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      bottomNavigationBar: BottomAppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shape: <span class="keyword">const</span> CircularNotchedRectangle(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Row(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">              IconButton(icon: Icon(Icons.<span class="built_in">print</span>), onPressed: ()&#123;&#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              IconButton(icon: Icon(Icons.add), onPressed: ()&#123;&#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              IconButton(icon: Icon(Icons.add_a_photo), onPressed: ()&#123;&#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">50.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButton: FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">print</span>(<span class="string">"点击"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/950cce6d/2020312739.jpg" alt="2020312739"></p>
<p><code>BottomNavigationBar</code> 主要用于应用的底部导航，继承自 <code>StatefulWidget</code> ，为有状态的 Widget ，构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">BottomNavigationBar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;BottomNavigationBarItem&gt;类型必传参数，底部导航栏中的选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.items,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;int&gt;类型可选命名参数，点击某个选项时的回调函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onTap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，当前被选择的选项索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.currentIndex = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，此底部导航栏的z坐标。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation = <span class="number">8.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BottomNavigationBarType类型可选命名参数，定义底部导航栏的布局和行为</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BottomNavigationBarType type,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，被选择的选项的颜色，get属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color fixedColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，底部导航栏背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，底部导航中的图标的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.iconSize = <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，所选底部导航图标和底部导航图标标签的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color selectedItemColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，未选择的底部导航图标和底部导航图标标签的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.unselectedItemColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，当前选定的底部导航图标中图标的大小、不透明度和颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedIconTheme = <span class="keyword">const</span> IconThemeData(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，当前未选中的底部导航图标中图标的大小、不透明度和颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.unselectedIconTheme = <span class="keyword">const</span> IconThemeData(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，选择时底部导航项标签的字体大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedFontSize = <span class="number">14.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，未选择时底部导航项标签的字体大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.unselectedFontSize = <span class="number">12.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，选择时底部导航项标签的文本样式。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedLabelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，未选择时底部导航项标签的文本样式。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.unselectedLabelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否为选择的底部导航图标显示标签文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showSelectedLabels = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否为未选定的底部导航项显示标签文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> showUnselectedLabels,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>BottomNavigationBarItem</code> 为带有图标和标题的交互式按钮，通常与 <code>BottomNavigationBar</code> 一起使用，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BottomNavigationBarItem(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，底部导航选项的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，底部导航选项的标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，选择底部导航选项的替代图标。当选项被选择时将使用此设置的图标，如果不为null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget activeIcon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，底部导航栏的背景径向动画的颜色。只有当设置BottomNavigationBarType.shifting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//时才生效，点击后底部导航背景色将变化为此色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyRootNavigationPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRootNavigationPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createState</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> _MyRootNavigationPage();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyRootNavigationPage</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyRootNavigationPage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; _pageTitles = &lt;<span class="built_in">String</span>&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"page 1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"page 2"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"page 3"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> _pageTitle;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> _currentSelected = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; _pageWidget = &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _FirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _SecondPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _ThirdPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  _itemSelected(<span class="built_in">int</span> valueIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _currentSelected = valueIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _pageTitle = _pageTitles.elementAt(valueIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _pageTitle = _pageTitles.first;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"<span class="subst">$_pageTitle</span>"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: _pageWidget.elementAt(_currentSelected),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      bottomNavigationBar: BottomNavigationBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        items: &lt;BottomNavigationBarItem&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          BottomNavigationBarItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            icon: Icon(Icons.<span class="built_in">print</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            title: Text(<span class="string">"Page1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          BottomNavigationBarItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            icon: Icon(Icons.party_mode),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            title: Text(<span class="string">"Page2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          BottomNavigationBarItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            icon: Icon(Icons.add_a_photo),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            title: Text(<span class="string">"Page3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        currentIndex: _currentSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onTap: _itemSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        backgroundColor: Colors.yellowAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        selectedItemColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        unselectedItemColor: Colors.black45,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">"Page 1"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_SecondPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">"Page 2"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ThirdPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">"Page 3"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对于 <code>BottomNavigationBarItem</code> 内的显示图标，可以使用 <code>Image</code> 加载自定义的图片。上述代码效果如下：</p>
<p><img src="/content/950cce6d/20203121058.jpg" alt="20203121058"></p>
<p><code>BottomNavigationBar</code> 的 <code>type</code> 为 <code>BottomNavigationBarType</code> 类型，是一个枚举类型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> BottomNavigationBarType &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//底部导航条的底部导航条有固定的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  fixed,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//底部导航栏底部导航栏的位置和大小动画和标签在被点击时淡入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  shifting,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><code>Scaffold</code> 的 <code>persistentFooterButtons</code> 为 <code>List&lt;Widget&gt;</code> 类型，是一组显示在 <code>Scaffold</code> 底部的 Widget ，通常使用 <code>FlatButton</code> 。这组 Widget 会呈现在 <code>bottomNavigationBar</code> 的上方，<code>body</code> 下方。他们是持续可见的，即使 <code>body</code> 进行滚动依然如此。使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">persistentFooterButtons: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FlatButton(onPressed: ()&#123;&#125;, child: Text(<span class="string">"按钮1"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FlatButton(onPressed: ()&#123;&#125;, child: Text(<span class="string">"按钮1"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FlatButton(onPressed: ()&#123;&#125;, child: Text(<span class="string">"按钮1"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ],</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/950cce6d/20203121115.jpg" alt="20203121115"></p>
<p><code>bottomSheet</code> 对应的是一个 Widget ，是一个始终可见的 Widget 。可以用来定义底部的菜单或对话框。也可以使用 Flutter 提供好的 </p>
<p>使用任意 Widget 的方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyFirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Center(child: Text(<span class="string">"主体内容"</span>),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      bottomSheet: Container(    <span class="comment">//bottomSheet</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">80</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Center(child: Text(<span class="string">"BottomSheet"</span>)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/950cce6d/2020313235.jpg" alt="2020313235"></p>
<p>在底部展示消息还可以使用 <code>SnackBar</code> Widget ，其是一个 <code>StatefulWidget</code> ，是一个轻量级的带有可选操作的在屏幕底部暂时出现的 Widget。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SnackBar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.content,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于指定背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，SnackBar的z坐标，这可以控制SnackBar下方阴影的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，SnackBar的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SnackBarBehavior类型可选命名参数，用于设置SnackBar的行为和位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.behavior,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SnackBarAction类型可选命名参数，要执行的行为</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.action,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Duration类型可选命名参数，SnackBar的持续显示时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.duration = _snackBarDisplayDuration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Animation&lt;double&gt;类型可选命名参数，动画</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.animation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//VoidCallback类型可选命名参数，第一次在Scaffold中出现时的回调函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onVisible,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyFirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        builder: (BuildContext context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"SnackBar"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ScaffoldState state = Scaffold.of(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  SnackBar snBar = SnackBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    content: Text(<span class="string">"这是一个提示信息"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    backgroundColor: Colors.deepPurpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    action: SnackBarAction(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      label: <span class="string">"点击查看详情"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="built_in">print</span>(<span class="string">"详情内容"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    onVisible: ()=&gt; <span class="built_in">print</span>(<span class="string">"第一次出现执行，仅执行一次"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  state.showSnackBar(snBar);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/950cce6d/2020314732.gif" alt="2020314732"></p>
<h4 id="三、MaterialApp-Widget-补充"><a href="#三、MaterialApp-Widget-补充" class="headerlink" title="三、MaterialApp Widget 补充"></a>三、MaterialApp Widget 补充</h4><p><code>MaterialApp</code> 中的 <code>theme</code>  和 <code>darkTheme</code> 均是 <code>ThemeData</code> 类型，用于设置应用的主题颜色和板式值。可以配置 <code>Theme</code> 或 <code>MaterialApp</code> Widget ，获取当前的主题，可以使用 <code>Theme.of</code> 。区别在于 <code>darkTheme</code> 意思是提供暗黑模式的主题，在设置 <code>ThemeData</code> 的 <code>Brightness</code> 时应设置为 <code>dark</code> 。如果同时提供 <code>theme</code>  和 <code>darkTheme</code> ，则可以设置 <code>themeMode</code> 进行主题选择，这就是同时提供两种主题模式的用途，可以通过不同的设置提供不同的主题样式。主题主要用来定义应用程序通用的样式和颜色基调，可以再对不同的 Widget 做具体细节调整。其构工厂造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">factory</span> ThemeData(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，用于设置主题的模式，dark或者light</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Brightness brightness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialColor类型可选命名参数，用于定义一种单一的颜色，此颜色带有始终色调的颜色样本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MaterialColor primarySwatch,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于设置工具栏、标签栏等的背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color primaryColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，在主题模式不变的情况下设置基色(工具栏等)的文本和图标反色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Brightness primaryColorBrightness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，原色的较轻版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color primaryColorLight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，原色的较暗版本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color primaryColorDark,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，小部件的前景色(旋钮、文本、过卷边缘效果等)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color accentColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，用于确定放置在强调色顶部的文本和图标的颜色(例如，浮动操作按钮上的图标)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Brightness accentColorBrightness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，画布颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color canvasColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，Scaffold的页面背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color scaffoldBackgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，底部应用栏的默认颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color bottomAppBarColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，Card的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color cardColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，分隔线和弹出窗口的颜色也用于列表间、数据表中的行间等等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color dividerColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，使用的焦点颜色表示组件具有输入焦点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于指示指针何时悬停在组件上的悬停颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，高亮颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color highlightColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，InkWell颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color splashColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InteractiveInkFeatureFactory类型可选命名参数，定义墨水池和墨水响应产生的墨水飞溅的外观</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  InteractiveInkFeatureFactory splashFactory,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于突出显示选定行的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color selectedRowColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，处于非活动(但已启用)状态的小部件所用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color unselectedWidgetColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，不工作的小部件所用的颜色，与它们的状态无关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，“凸起”按钮中使用的材料的默认填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color buttonColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ButtonThemeData类型可选命名参数，定义按钮小部件的默认配置，如上升按钮和平板按钮</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ButtonThemeData buttonTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ToggleButtonsThemeData类型可选命名参数，定义ToggleButtons小部件的默认配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ToggleButtonsThemeData toggleButtonsTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，当有选定行时，分页数据表的标题颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color secondaryHeaderColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，文本字段中文本选择的颜色，如文本字段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color textSelectionColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，TextField(如文本字段)等中光标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color cursorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于调整当前所选文本部分的手柄颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color textSelectionHandleColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，与原色形成对比的颜色，例如用作进度条的剩余部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，对话框元素的背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color dialogBackgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，标签栏中所选标签指示器的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color indicatorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于提示文本或占位符文本的颜色，例如在文本字段中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color hintColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于输入验证错误的颜色，例如在文本字段中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color errorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于突出显示可切换小部件(如开关、收音机和复选框)活动状态的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color toggleableActiveColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于设置字体名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> fontFamily,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextTheme类型可选命名参数，文字颜色与卡片和画布颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextTheme textTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextTheme类型可选命名参数，与原色形成对比的文本主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextTheme primaryTextTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextTheme类型可选命名参数，与强调色形成对比的文本主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextTheme accentTextTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InputDecorationTheme类型可选命名参数，输入编辑器、文本字段和文本表单字段的默认输入配置值基于此主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  InputDecorationTheme inputDecorationTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，与卡片和画布颜色形成对比的图标主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  IconThemeData iconTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，与原色形成对比的图标主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  IconThemeData primaryIconTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，与强调色形成对比的图标主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  IconThemeData accentIconTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SliderThemeData类型可选命名参数，用于渲染滑块的颜色和形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  SliderThemeData sliderTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TabBarTheme类型可选命名参数，用于自定义标签栏指示器的大小、形状和颜色的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TabBarTheme tabBarTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TooltipThemeData类型可选命名参数，用于自定义工具提示视觉属性的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TooltipThemeData tooltipTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CardTheme类型可选命名参数，用于渲染卡片的颜色和样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  CardTheme cardTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ChipThemeData类型可选命名参数，用于渲染芯片的颜色和样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ChipThemeData chipTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TargetPlatform类型可选命名参数，材料部件应适应目标的平台</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TargetPlatform platform,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，配置某些材质小部件的命中测试大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MaterialTapTargetSize materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，在材质表面应用半透明叠加颜色，以指示深色主题的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> applyElevationOverlayColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PageTransitionsTheme类型可选命名参数，每个目标平台的默认材质页面输出转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  PageTransitionsTheme pageTransitionsTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AppBarTheme类型可选命名参数，用于自定义应用栏的颜色、高度、亮度、图标主题和文本主题的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  AppBarTheme appBarTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BottomAppBarTheme类型可选命名参数，用于自定义底部工具栏的形状、高度和颜色的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BottomAppBarTheme bottomAppBarTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ColorScheme类型可选命名参数，一组十三种颜色，可用于配置大多数组件的颜色属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ColorScheme colorScheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DialogTheme类型可选命名参数，用于自定义对话框形状的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DialogTheme dialogTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FloatingActionButtonThemeData类型可选命名参数，用于自定义浮动动作按钮的形状、高度和颜色的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  FloatingActionButtonThemeData floatingActionButtonTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Typography类型可选命名参数，用于配置文本主题、主文本主题和重音文本主题的颜色和几何文本主题值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Typography typography,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//CupertinoThemeData类型可选命名参数，要从“材料”主题“数据”自适应中覆盖的CupertinoThemeData的组件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  CupertinoThemeData cupertinoOverrideTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//SnackBarThemeData类型可选命名参数，用于自定义SnackBar的颜色、形状、高度和行为的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  SnackBarThemeData snackBarTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BottomSheetThemeData类型可选命名参数，用于自定义底部工作表的颜色、高度和形状的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BottomSheetThemeData bottomSheetTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PopupMenuThemeData类型可选命名参数，用于自定义弹出菜单的颜色、形状、高度和文本样式的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  PopupMenuThemeData popupMenuTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialBannerThemeData类型可选命名参数，用于自定义材质横幅的颜色和文本样式的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  MaterialBannerThemeData bannerTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DividerThemeData类型可选命名参数，自定义分割线、垂直分割线等的颜色、厚度和缩进的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  DividerThemeData dividerTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ButtonBarThemeData类型可选命名参数，自定义按钮栏小部件外观和布局的主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ButtonBarThemeData buttonBarTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>关于 <code>ThemeData</code> 的不同属性只是翻译自官方文档，部分没有做验证看效果，各位要自己试验看效果。</p>
<p><code>locale</code> 用于设置应用程序的本地语言初始化环境值。如果为 <code>null</code> ，则使用系统的区域设置值。如果 <code>Localizations.locale</code> 的值与 <code>supportedLocales</code> 之一匹配，则它将等于该语言环境。 否则它将是第一个 <code>supportedLocale</code>。</p>
<p>关于国际化的使用方式查看官方网址：<a href="https://flutter.dev/docs/development/accessibility-and-localization/internationalization" target="_blank" rel="noopener">https://flutter.dev/docs/development/accessibility-and-localization/internationalization</a> 。后续文章也会详细介绍。</p>
<p>上述说的都是单独的界面，如果涉及到页面的切换，比如查看列表的详细信息，进入下一级等，需要使用到 <code>Navigator</code> Widget 。</p>
<p><code>Navigator</code> 是使用堆栈规则管理一组 Widget ，这些 Widget (界面)称为 <code>Route</code> 对象 。其继承自 <code>StatefulWidget</code> ，是一个有状态的 Widget 。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Navigator(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，要显示的第一个路由(页面)的名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialRoute,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//RouteFactory类型必传参数，调用以生成给定路由设置的路由</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onGenerateRoute,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//RouteFactory类型必传参数，当onGenerateRoute无法生成路由时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onUnknownRoute,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;NavigatorObserver&gt;类型必传参数，导航器的观察者列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.observers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>在执行路由线路切换需要使用 <code>Navigator</code> 的 <code>push</code> 和 <code>pop</code> 方法，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将制定路由添加到到导航的路由栈中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;T&gt; push&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, Route&lt;T&gt; route) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Navigator.of(context).push(route);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//用于弹出最顶端的路由</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> pop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, [ T result ]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Navigator.of(context).pop&lt;T&gt;(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Navigator.push()</code> 接收两个参数，一个是上下文信息，另一个是 <code>Route</code> ，可以使用 <code>MaterialPageRote</code>的实例。其构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialPageRoute(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//WidgetBuilder类型必传参数，构建路线的主要内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//RouteSettings类型可选命名参数，路由的设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  RouteSettings settings,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，路由处于非活动状态时是否应保留在内存中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maintainState = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此页面路由是否为全屏对话框。在iOS上，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//这些页面从底部到顶部（而不是水平）进行动画处理。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> fullscreenDialog = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        builder: (BuildContext context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"下一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 Navigator.push(context, MaterialPageRoute(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   builder: (context) =&gt; FirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   fullscreenDialog: <span class="keyword">false</span>,  <span class="comment">//如果为true，则动画为从下至上推出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                 ));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"FirstPage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"上一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Navigator.pop(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/950cce6d/2020315123.gif" alt="2020315123"></p>
<p>也可以通过设置 <code>Material.routes</code> 来设置导航的顶级路由路线，通过 <code>Navigator.pushNamed</code> 方法进行导航界面切换，<code>pushNamed</code> 方法原型如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;T&gt; pushNamed&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BuildContext类型必传参数，上线文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BuildContext context,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型必传参数，路由路径名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> routeName, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Object类型可选命名参数，参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Object</span> arguments,</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Navigator.of(context).pushNamed&lt;T&gt;(routeName, arguments: arguments);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      routes: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"/first"</span> : (context)=&gt; FirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        builder: (BuildContext context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"下一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Navigator.pushNamed(context, <span class="string">"/first"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"FirstPage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"上一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Navigator.pop(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>因为在 <code>home</code> 中设置了首页，所以在 <code>routes</code> 中不需要设置 <code>/</code> 来表示首页，<code>home</code> 等同于 <code>/</code> 。 </p>
<p>如果涉及到页面传值，正向传值如果使用 <code>Navigator.push()</code> ，可以使用被传递参数的 Widget 的构造方法，使用<code>Navigator.pushNamed()</code> ，可以使用其第三个参数 <code>arguments</code> 进行参数设置。 反向可以使用 <code>Navigator.pop</code> 的参数进行设置。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        builder: (BuildContext context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"下一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="comment">//使用push</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                 Navigator.push(context, MaterialPageRoute(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   builder: (context) =&gt; FirstPage(<span class="string">"hike"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   fullscreenDialog: <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 )</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 ).then((value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  FirstPage(<span class="keyword">this</span>.userName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> userName;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"FirstPage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"上一页 名字为:<span class="subst">$userName</span>"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Navigator.pop(context, <span class="string">"返回给HomePage的值"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"HomePage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Builder(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        builder: (BuildContext context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child: Text(<span class="string">"下一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                onPressed: () <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="keyword">final</span> result = <span class="keyword">await</span> Navigator.pushNamed(context, <span class="string">"/first"</span>, arguments: &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="string">"name"</span> : <span class="string">"hike"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="string">"age"</span> : <span class="string">"20"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="built_in">print</span>(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    RouteSettings setting = ModalRoute.of(context).settings;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span> args = ModalRoute.of(context).settings.arguments;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(setting.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"FirstPage"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"上一页"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Navigator.pop(context, &lt;<span class="built_in">String</span>&gt;[<span class="string">"hike"</span>, <span class="string">"nick"</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在正向传值中，使用 <code>Navigator.pushNamed()</code> 方法时，参数 <code>arguments</code> 参数为 <code>Object</code> 类型，所以可以定义任意类型参数，也可以使用 <code>class</code> 等包装参数进行传递。当在接收参数页面接收参数时，使用 <code>ModalRoute.of</code> 进行获取，其返回一个带有参数的当前路由。 </p>
<p>在反向传值时，当调用 <code>Navigator.pop()</code> 时，会将其中的参数包装到该方法返回的 <code>Feature</code> 对象中。后续文章会详细介绍。可以查看官方说明文档：<a href="https://flutter.dev/docs/cookbook/navigation/returning-data" target="_blank" rel="noopener">https://flutter.dev/docs/cookbook/navigation/returning-data</a></p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(五)</title>
    <url>/content/c03861f.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>前面几篇文章介绍了一些基本的Flutter Widget ，现在开始介绍一下前面一直用到但没做过多说明的 <code>MaterialApp</code> ，<code>Scaffold</code> 和一些布局组件，因为后面的很多 Widget 中要使用部分布局 Widget ， 所以这里插入先对这些 Widget 做下讲解。</p>
<a id="more"></a>

<p>为了方便的创建出特定风格的应用程序，Flutter 包装了创建应用程序的 Widget ：<code>MaterialApp</code> 用于创建 Material 设计风格( Android 风格 )的应用程序，<code>CupertinoApp</code> 用于创建 ios 设计风格的应用程序。这里首先介绍下 <code>MaterialApp</code> ，以后在对 <code>CupertinoApp</code> 做说明。</p>
<h4 id="二、MaterialApp"><a href="#二、MaterialApp" class="headerlink" title="二、MaterialApp"></a>二、MaterialApp</h4><p><code>MaterialApp</code> 是一个 Widget ，代表使用 Material 设计风格的应用。在 Flutter 中创建一个Material 设计风格的移动应用程序，应首先在 Widget 树的根插入 <code>MaterialApp</code> Widget 。<code>MaterialApp</code> 继承自 <code>StatefulWidget</code> ，是一个有状态的 Widget ，虽然在其构造函数中没有必传参数，但是有很多命名可选参数是不能为 <code>null</code> 的，必须为他们分配值，这是通过断言的方式的实现的。<code>MaterialApp</code> 主要用来设置应用程序启动时的首界面，主题，路由功能，本地化语言环境，文本的方向等。</p>
<p>其构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialApp(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//GlobalKey&lt;NavigatorState&gt;类型可选命名参数，构建导航器时要使用的键</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.navigatorKey,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，应用打开时，要显示的第一个页面(主页)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.home,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Map&lt;String, WidgetBuilder&gt;类型可选命名参数，路由，用于定义应用中的页面跳转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.routes = <span class="keyword">const</span> &lt;<span class="built_in">String</span>, WidgetBuilder&gt;&#123;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，初始化路由，用于在构建了导航器的情况下，设置要显示的第一个路由的名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialRoute,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//RouteFactory类型可选命名参数，在应用导航到命名路由时使用的路由生成器回调</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onGenerateRoute,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//RouteFactory类型可选命名参数，当onGenerateRoute未能生成路由(初始路由除外)时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onUnknownRoute,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;NavigatorObserver&gt;类型可选命名参数，为此应用程序创建的导航器的观察器列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.navigatorObservers = <span class="keyword">const</span> &lt;NavigatorObserver&gt;[],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TransitionBuilder类型可选命名参数，用于将小部件插入到Navigator上方并且在WidgetApp创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//的其他小部件下方的构建器，或用于完全替换Navigator的构建器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.builder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，用于标识应用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title = <span class="string">''</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//GenerateAppTitle类型可选命名参数，如果非空，则调用该回调函数来生成应用程序的标题字符串，否则使用标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//onGenerateTitle上下文参数包括WidgetsApp的Localizations小部件，因此该回调可用于生成本地化的标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onGenerateTitle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，操作系统界面中用于应用程序的主要颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ThemeData类型可选命名参数，用于设置应用的主题(外观)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.theme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ThemeData类型可选命名参数，设置暗模式主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.darkTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ThemeMode类型可选命名参数，用于确定在同时设置了 theme 和 darkTheme 的情况下使用哪个主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.themeMode = ThemeMode.system,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Locale类型可选命名参数，用于设置应用程序本地化初始语言</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.locale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Iterable&lt;LocalizationsDelegate&gt;类型可选命名参数，应用程序本地化代理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.localizationsDelegates,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//LocaleListResolutionCallback类型可选命名参数，该回调负责在应用启动时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//以及用户更改设备的区域设置时选择应用的区域设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.localeListResolutionCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//LocaleResolutionCallback类型可选命名参数，这个回调传递给由这个小部件构建的WidgetsApp</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.localeResolutionCallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Iterable&lt;Locale&gt;类型可选命名参数，应用支持的本地化语言，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//不能为空，默认的语言解析算法根据设置顺序进行解析</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.supportedLocales = <span class="keyword">const</span> &lt;Locale&gt;[Locale(<span class="string">'en'</span>, <span class="string">'US'</span>)],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示网格(可用于调试UI)，仅检查模式可用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.debugShowMaterialGrid = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否显示性能提示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showPerformanceOverlay = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否打开栅格缓存图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.checkerboardRasterCacheImages = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，检查渲染到屏幕外的图层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.checkerboardOffscreenLayers = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选明敏参数是否显示语义调试</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.showSemanticsDebugger = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，在检查模式下，在屏幕右上角是否显示 DEBUG 横幅，发布模式无效</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.debugShowCheckedModeBanner = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>第一个 <code>Key</code> 参数，是作为 <code>Widget</code> 、<code>Element</code> 、<code>SemanticsNode</code> 的标识符，其作用是，当现有元素的键与当前 Widget 的键相同时，会使用新的 Widget 更新现有的元素。前面介绍过的构造参数都有这个参数，这里做下说明。</p>
<p>在这些属性中，<code>home</code> 、<code>routes</code> 、<code>onGeneratedRoute</code> 、<code>builder</code>  在创建 <code>MaterialApp</code> 时，至少有一个必须进行设置，不能为 <code>null</code> ，否则会报异常。对于指定应用的首界面，如果在 <code>MaterialApp</code> 提供了 <code>home</code> ，则使用 <code>home</code> 指定的 Widget 。如果 <code>home</code> 为 <code>null</code> ，则寻找 <code>routes</code> 中的 <code>&quot;/&quot;</code> ，如果进行了设置，则使用 <code>&quot;/&quot;</code> 对应的 Widget 作为首界面。如果<code>routes</code> 中没有设置 <code>&quot;/&quot;</code> ，且没有设置 <code>home</code> ，则调用回调函数 <code>onGenerateRoute</code> ，如果提供了，它会作为首界面进行回调。如果没有设置 <code>onGenerateRoute</code> ，也没有提供 <code>builder</code> ，则调用 <code>onUnknownRoute</code> 。如果提供了 <code>builder</code> 则会覆盖以上流程中设置的首界面。</p>
<p>只提供 <code>home</code> 如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: FirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">"Page 1"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>路由 ( <code>routes</code> ) 用来设置顶级导航的不同界面。如果只提供了 <code>routes</code> ，则必须包含 <code>&quot;/&quot;</code> ，表示应用启动的第一个界面，<code>home</code> 与 <code>&quot;/&quot;</code> 不能同时指定。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      routes: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"/"</span> : (context)=&gt; FirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"/second"</span> : (context)=&gt; SecondPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"/third"</span> : (context)=&gt; ThirdPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      initialRoute: <span class="string">"/"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">"Page 1"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">"Page 2"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">"Page 3"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><code>onGenerateRoute</code> 的类型是 <code>RouteFactory</code> ，其是一个 <code>Function</code> ，原型为 <code>Route&lt;dynamic&gt; Function(RouteSettings settings)</code> 。 使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      onGenerateRoute: (settings) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> MaterialPageRoute(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          builder: (context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><code>builder</code> 的类型是 <code>TransitionBuilder</code> ，也是一个 <code>Function</code> ，原型为：<code>Widget Function(BuildContext context, Widget child)</code> 。使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      builder: (context, child) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>如果以上都没有设置就会调用 <code>onUnknownRoute</code> ，其类型也是一个 <code>RouteFactory</code> ，使用方式与 <code>onGenerateRoute</code> 相同。<code>onUnknownRoute</code> 主要用于错误处理，用于描述未找到 Widget ，类似 404 错误页面设置。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      onUnknownRoute: (settings) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> MaterialPageRoute(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          builder: (context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(<span class="string">"没有找到路由"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            );</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        );</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上正确设置的效果如下图：</p>
<p><img src="/content/c03861f/2020310627.jpg" alt="2020310627"></p>
<p>现在的界面是没有导航的，在一个完整的应用程序中，一般都会有导航组件，在 Flutter 中，需要使用 <code>Scaffold</code> 来组织界面布局结构。<code>MaterialApp</code> 中的其他属性，在介绍完 <code>Scaffold</code> 后统一说明。</p>
<h4 id="三、Scaffold-Widget"><a href="#三、Scaffold-Widget" class="headerlink" title="三、Scaffold Widget"></a>三、Scaffold Widget</h4><p><code>Scaffold</code> 称为脚手架 Widget ，用于组织界面布局，其中包含了创建一个应用程序的几乎所有东西。构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scaffold(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PreferredSizeWidget类型可选命名参数，应用顶部的导航栏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.appBar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，主界面显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.body,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，悬浮在界面上方的按钮</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.floatingActionButton,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FloatingActionButtonLocation类型可选命名参数，设置悬浮按钮的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.floatingActionButtonLocation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FloatingActionButtonAnimator类型可选命名参数，将悬浮按钮移动到一个新的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.floatingActionButtonAnimator,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，在界面底部显示的一组按钮，呈现在bottomNavigationBar上方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.persistentFooterButtons,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，抽屉Widget，显示在侧面的面板，入口在顶部导航左侧</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.drawer,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，抽屉Widget，显示在侧面的面板，入口在顶部导航右侧</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.endDrawer,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，底部应用栏或导航栏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottomNavigationBar,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的永久性底部工作表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottomSheet,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，设置整个Scafflod组件的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型参数，已弃用，使用resizeToAvoidBottomInset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.resizeToAvoidBottomPadding,   <span class="comment">//已弃用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，指定当键盘出现时，正文是否应该调整大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.resizeToAvoidBottomInset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，Scaffold是否在屏幕顶部显示，如果为true，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则appBar的高度将扩展为屏幕状态栏的高度，即MediaQuery的顶部填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动启动行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.drawerDragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为真，并且指定了底部导航栏或持久底托按钮，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则主体延伸到脚手架的底部，而不是仅延伸到底部导航栏或持久底托按钮的顶部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.extendBody = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为true，并且指定了一个应用栏，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//则主体的高度将被扩展为包括应用栏的高度，并且主体的顶部与应用栏的顶部对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.extendBodyBehindAppBar = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，抽屉打开时，主体遮罩的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.drawerScrimColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，滑动打开抽屉的有效拖动宽度，为0则滑动无法打开抽屉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.drawerEdgeDragWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中，<code>appBar</code> 的类型为 <code>PreferredSizeWidget</code> ，是一个抽象类，需要使用其子类 <code>AppBar</code> 来创建顶部导航，<code>body</code> 是界面显示的主体部分，可以使用任何组件，具体使用什么取决于应用程序要实现的功能。</p>
<p> <code>AppBar</code> 构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要在标题前显示的小部件(顶部导航左侧的Widget)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.leading,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，leading如果为空，是否尝试按时前导Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，用于设置导航栏标题显示的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.title,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型可选命名参数，要在标题小部件后显示的小部件(顶部导航右侧的Widget)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.actions,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，该小部件堆叠在顶部导航和选项卡栏的后面，通常为FlexibleSpaceBar类型。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//它的高度将与应用顶部导航栏的整体高度相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.flexibleSpace,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//PreferredSizeWidget类型可选命名参数，应用程序导航栏底部工具栏，通常为Tabbar  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottom,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父应用程序栏放置的z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，形状设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，导航栏颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，导航栏亮度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.brightness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，导航栏图标颜色、不透明度、大小设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.iconTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconThemeData类型可选命名参数，应用程序栏中出现的图标的颜色、不透明度和大小。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//只有当动作的主题不同于应用程序栏主窗口中出现的图标时，才应使用此选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.actionsIconTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextTheme类型可选命名参数，应用程序顶部导航栏中用于文本的排版样式。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//通常，这与亮度背景颜色、图标主题一起设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，此应用程序栏是否显示在屏幕顶部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，标题是否居中显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.centerTitle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，水平轴上标题内容周围的间距。即使没有前导内容或动作，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//也会应用此间距。如果希望title占用所有可用空间，请将该值设置为0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，应用程序顶部导航栏的工具栏部分有多不透明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，应用程序栏底部有多不透明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>通过构造函数可以发现，无论 <code>Scaffold</code> 还是 <code>AppBar</code> 都没有必须要设置的必传参数，直接使用就可以。基本的使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/c03861f/20203101018.jpg" alt="20203101018"></p>
<p><code>AppBar</code> 布局位置如下图所示：</p>
<p><img src="/content/c03861f/app_bar.jpg" alt="app_bar"></p>
<p>基本属性设置：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          leading: Icon(Icons.<span class="built_in">print</span>),   <span class="comment">//顶部导航栏左侧Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          automaticallyImplyLeading: <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Page 1"</span>),   <span class="comment">//顶部导航栏标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          actions: &lt;Widget&gt;[   <span class="comment">//顶部导航栏右侧Widget List</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            IconButton(icon: Icon(Icons.add), onPressed: ()&#123;&#125;,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundColor: Colors.amber,   <span class="comment">//顶部导航背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          brightness:Brightness.light,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          iconTheme: IconThemeData(color: Colors.lightGreen, opacity: <span class="number">1</span>, size: <span class="number">30</span>), <span class="comment">//设置顶部导航栏的Icon图标属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          textTheme: TextTheme(title: TextStyle(color: Colors.red)),   <span class="comment">//顶部导航文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          centerTitle: <span class="keyword">true</span>,    <span class="comment">//居中显示标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/c03861f/2020311643.jpg" alt="2020311643"></p>
<p><code>AppBar</code> 中的 <code>bottom</code> 属性，是显示在顶部导航底部的 Widget，通常使用 <code>TabBar</code> ，是一个水平显示的 Widget 。<code>TabBar</code> 通常也与 <code>TabBarView</code> 一起使用。</p>
<p><code>TabBar</code> 构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TabBar(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型必传参数，选项卡显示的Widget，通常为Tab。此list长度必须与控制器的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TabController.length和TabBarView.children列表的长度匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.tabs,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TabController类型可选命名参数，用于控制TabBar选项卡与TabBarView界面切换状态。如果不提供此参数，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//需要使用DefaultTabController</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，菜单标签是否可以横向滚动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isScrollable = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，被选中的选项卡下方线条的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.indicatorColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，被选中的选项卡下方线条的粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.indicatorWeight = <span class="number">2.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，被选中的选项卡下方线条的水平填充间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.indicatorPadding = EdgeInsets.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Decoration类型可选命名参数，用于定义选项卡指示器的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.indicator,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TabBarIndicatorSize类型可选命名参数，选项卡指示器的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.indicatorSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，选项卡标签颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，选项卡标签文本颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，选项卡每个标签的内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.labelPadding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，未选中的选项卡标签的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.unselectedLabelColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，未选中选项卡标签的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.unselectedLabelStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，用于定义处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ValueChanged&lt;int&gt;类型可选命名参数，点击选显卡标签时的回调函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onTap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>其中 <code>tabs</code> 的 <code>list</code> 使用的 <code>Tab</code> 是一个无状态 Widget ，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Tab(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，要显示的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.text,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，为用作标签的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>TabBar</code> 的 <code>controller</code> 是 <code>TabController</code> 类型。其提供的构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TabController(&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，不能为null，用于设置初始化状态选项卡的被选中下标，从0开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> initialIndex = <span class="number">0</span>, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，选项卡选项的总数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.length, </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TickerProvider类型必传参数，其为抽象类，需要使用其子类SingleTickerProviderStateMixin，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//下面具体说明</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> TickerProvider vsync </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;): <span class="keyword">assert</span>(length != <span class="keyword">null</span> &amp;&amp; length &gt;= <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">assert</span>(initialIndex != <span class="keyword">null</span> &amp;&amp; initialIndex &gt;= <span class="number">0</span> &amp;&amp; (length == <span class="number">0</span> || initialIndex &lt; length)),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _index = initialIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _previousIndex = initialIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _animationController = AnimationController.unbounded(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        value: initialIndex.toDouble(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vsync: vsync,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      );</span></pre></td></tr></table></figure>

<p>这里需要特殊说明的是 <code>vsync</code> 参数，从初始化列表可以看出，其是赋值给 <code>AnimationController.unbounded</code> 的构造方法中的 <code>vsync</code> 。<code>AnimationController</code> 是一个动画控制器，是用来控制和生成动画的。<code>vsync</code> 为<code>AnimationController.unbounded</code> 构造方法的必传参数。<code>vsync</code> 为 <code>TickerProvider</code> 类型，其为抽象类，不能直接使用，根据官方文档的说明如下：</p>
<blockquote>
<p>If you are creating an AnimationController from a State, then you can use the TickerProviderStateMixin and SingleTickerProviderStateMixin classes to obtain a suitable TickerProvider.</p>
</blockquote>
<p>意思是：如果从一个状态类( <code>State</code> )中创建 <code>AnimationController</code> ，可以使用 <code>TickerProviderStateMixin</code> 和 <code>SingleTickerProviderStateMixin</code> 来获取一个适合的 <code>TickerProvider</code> 。</p>
<p>如果在状态的声明周期中有多个 <code>AnimationController</code> ，则使用 <code>TickerProviderStateMixin</code> 。如果只有一个 <code>AnimationController</code> ，则使用 <code>SingleTickerProviderStateMixin</code> 效率更高。使用方法为混合该类，然后将 <code>this</code> 设置给 <code>vsync</code> 即可。官方说明地址为：<a href="https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html</a> 。</p>
<p>使用 <code>TabController</code> 的目的是关联 <code>TabBar</code> 和 <code>TabBarView</code> ，<code>TabBarView</code> 是一个页面视图，用于显示与当前选择的选项卡对应的 Widget 。<code>TabBarView</code> 为一个有状态的 Widget ，其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TabBarView(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;Widget&gt;类型必传参数，用于设置每个选项卡标签对应的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.children,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TabController类型可选命名参数，用于关联TabBar和TabBarView，设置动画状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.controller,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ScrollPhysics类型可选命名参数，设置页面视图应该如何响应用户输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.physics,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DragStartBehavior类型可选命名参数，确定处理拖动开始行为的方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.dragStartBehavior = DragStartBehavior.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<p><code>TabBar</code> 的使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyAppTabPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppTabPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createState</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> _MyAppTabPageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAppTabPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyAppTabPage</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span> _tabMenu = &lt;Tab&gt;[ Tab(text: <span class="string">"菜单1"</span>), Tab(text: <span class="string">"菜单2"</span>,)];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TabController _tabController;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.initState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _tabController = TabController(length: _tabMenu.length, vsync: <span class="keyword">this</span>, initialIndex: <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> dispose() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _tabController.dispose();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.dispose();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),   <span class="comment">//顶部导航栏标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        bottom: TabBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          tabs: _tabMenu,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          controller: _tabController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          onTap: (value) &#123;<span class="built_in">print</span>(value);&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: TabBarView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Center(child: Text(<span class="string">"Page 1"</span>, style: TextStyle(fontSize: <span class="number">60</span>, color: Colors.yellow),),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Center(child: Text(<span class="string">"Page 2"</span>, style: TextStyle(fontSize: <span class="number">60</span>, color: Colors.yellow),),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        controller: _tabController,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中 <code>initState()</code> 方法为当对象插入到 Widget 树中时调用，仅执行一次，做数据的初始化操作，后续会详细介绍。</p>
<p>执行结果如下图：</p>
<p><img src="/content/c03861f/20203121030.jpg" alt="20203121030"></p>
<p>上面说过，如果在 <code>TabBar</code> 中不提供 <code>controller</code> ，可以使用 <code>DefaultTabController</code> 。因为 <code>TabController</code> 是一个监听状态的控制器，其继承关系如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TabController &lt; ChangeNotifier &lt; <span class="built_in">Object</span></span></pre></td></tr></table></figure>

<p>其不是一个 Widget ，当共享显示创建 <code>TabController</code> 不太方便时可以使用 <code>DefaultTabController</code> 。其继承自 <code>StatefulWidget</code> ，是一个有状态的 Widget ，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DefaultTabController(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，选项卡选项的总数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.length,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，不能为null，用于设置初始化状态选项卡的被选中下标，从0开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialIndex = <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyAppTabPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppTabPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span> _tabMenu = &lt;Tab&gt;[ Tab(text: <span class="string">"菜单1"</span>), Tab(text: <span class="string">"菜单2"</span>,)];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> DefaultTabController(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      length: _tabMenu.length,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      child: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          bottom: TabBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tabs: _tabMenu,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: TabBarView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Center(child: Text(<span class="string">"Page 1"</span>, style: TextStyle(fontSize: <span class="number">60</span>, color: Colors.yellow),),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Center(child: Text(<span class="string">"Page 2"</span>, style: TextStyle(fontSize: <span class="number">60</span>, color: Colors.yellow),),),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实现效果与上述相同。</p>
<p>关于 <code>floatingActionButton</code> ，其为一个悬浮按钮，通常使用 <code>FloatingActionButton</code> 。前面介绍 Button 的文章做过基础的具体说明，地址为：<a href="http://www.mwpush.com/content/aa8d162.html">http://www.mwpush.com/content/aa8d162.html</a> 。在 <code>Scaffold</code> 中的 <code>floatingActionButton</code> 用于特定位置，会悬浮于 <code>body</code> 之上。可以对其做一些属性设置，比如位置等。使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyFirstPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButton: FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">print</span>(<span class="string">"点击"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/c03861f/20203121138.jpg" alt="20203121138"></p>
<p>其中 <code>FloatingActionButtonLocation</code> 用来设置浮动按钮的位置，有以下几种位置可以选择使用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在屏幕底部末端浮动，不设置位置参数，默认使用此参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation endFloat = _EndFloatFloatingActionButtonLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在屏幕底部居中浮动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation centerFloat = _CenterFloatFloatingActionButtonLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在屏幕底部末端，浮动在Scaffold.bottomNavigationBar上方，以便浮动操作按钮的中心与</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//底部导航栏的顶部对齐。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果Scaffold.bottomNavigationBar的值为BottomAppBar，则底部应用栏可以设置一个凹口，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以容纳浮动按钮，没有底部栏不建议使用此位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation endDocked = _EndDockedFloatingActionButtonLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在屏幕底部居中，浮动在Scaffold.bottomNavigationBar上方，以便浮动操作按钮的中心与</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//底部导航栏的顶部对齐。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//如果Scaffold.bottomNavigationBar的值为BottomAppBar，则底部应用栏可以设置一个凹口，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以容纳浮动按钮，没有底部栏不建议使用此位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation centerDocked = _CenterDockedFloatingActionButtonLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在屏幕上方开始位置，Scaffold.appBar和Scaffold.body之间的过渡上浮动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation startTop = _StartTopFloatingActionButtonLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在屏幕上方开始位置，Scaffold.appBar和Scaffold.body之间的过渡上浮动，其位置与startTop相同。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//但是，如果FloatingActionButton.mini设置为true，并在Scaffold.body的ListView中的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//ListTile.ListTiles的前导槽的CircleAvatars对齐，请考虑使用miniStartTop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation miniStartTop = _MiniStartTopFloatingActionButtonLocation();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//在屏幕上方末端位置，Scaffold.appBar和Scaffold.body之间的过渡上浮动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> FloatingActionButtonLocation endTop = _EndTopFloatingActionButtonLocation();</span></pre></td></tr></table></figure>



<p><code>drawer</code> 为抽屉 Widget ，通常使用 <code>Drawer</code> ，是一个 <code>StatelessWidget</code> 无状态 Widget ，一个由侧边划入主界面的 Widget ，其 <code>child</code> 通常是 <code>ListView</code> ，其第一个子级是 <code>DrawerHeader</code> ，它显示有关当前用户的状态信息。 其余的抽屉式子代通常使用 <code>ListTile</code> 构造，通常使用 <code>AboutListTile</code> 结束。 <code>endDrawer</code> 与 <code>drawer</code> 一样，只是入口按钮分别分布在顶部导航的右侧和左侧。其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Drawer(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其上级放置此抽屉的Z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation = <span class="number">16.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，当抽屉打开和关闭时，辅助功能框架用来宣布屏幕转换的对话框的语义标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>这里引用官方文档的例子，展示下效果。关于 <code>ListView</code> 后面文章会详细介绍，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyAppTabPage(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppTabPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(<span class="string">"Page 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      drawer: Drawer(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: ListView(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            DrawerHeader(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              decoration: BoxDecoration(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                color: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              child: Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="string">'Drawer Header'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  color: Colors.white,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  fontSize: <span class="number">24</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Icon(Icons.message),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: Text(<span class="string">'Messages'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Icon(Icons.account_circle),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: Text(<span class="string">'Profile'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListTile(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              leading: Icon(Icons.settings),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              title: Text(<span class="string">'Settings'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      endDrawer: Drawer(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButton: FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="built_in">print</span>(<span class="string">"点击"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/c03861f/2020312100.jpg" alt="2020312100"></p>
<p>限于篇幅限制，下一篇文章将继续说明 <code>MaterialApp</code> 、<code>Scaffold</code> 。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(四)</title>
    <url>/content/aa8d162.html</url>
    <content><![CDATA[<h4 id="一、Button-Widget"><a href="#一、Button-Widget" class="headerlink" title="一、Button Widget"></a>一、Button Widget</h4><p>按钮是开发中常用的可与用户交互的组件，在 Flutter 中，提供了很多跟按钮相关的 Widget 。</p>
<a id="more"></a>

<h5 id="1-MaterialButton"><a href="#1-MaterialButton" class="headerlink" title="1. MaterialButton"></a>1. MaterialButton</h5><p><code>MaterialButton</code> 是用来构建一个依赖于 <code>ButtomTheme</code> 和 <code>Theme</code> 的实用工具类。其实现了按钮的基本需求功能，但是官方不建议直接使用此类来创建按钮，此类多用于定时和按钮 Widget 的基类。 应该尽量使用其提供的三个子类来创建，三个子类分别为：<code>RaisedButton</code> 、<code>FlatButton</code> 、<code>OutlineButton</code> 。这三个子类实现了 Material Design 设计风格的默认参数设置。<code>MaterialButton</code> 继承自 <code>StatelessWidget</code> ，为无状态 Widget， 其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MaterialButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Function类型必传参数，为当按钮点击时的回调方法，如果为null，按钮将处于禁用状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Function类型可选命名参数，为当长按按钮时的回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onLongPress,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Function类型可选命名参数，为当按钮突出(高亮)显示或停止突出显示时调用的回调方法，参数bool类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onHighlightChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ButtonTextTheme类型可选命名参数，用来定义按钮的基本颜色，最小尺寸，内部填充和形状的默认值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，为按钮文本的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，为按钮禁用时的按钮文本的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledTextColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮状态为可用时且未被点击时的填充色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，为按钮禁用时的按钮填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，当按钮具有输入焦点时的填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，指针悬停在按钮上时的填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于设置按钮的高亮颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.highlightColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮点击时水波纹效果的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.splashColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Brightness类型可选命名参数，用于设置按钮的主题亮度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.colorBrightness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父级放置此按钮的z坐标，可用于控制凸起按钮下方的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//阴影大小，默认值为2，不能为负数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，当按钮启用并具有焦点时，按钮的elevation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，当按钮启用且指针悬停在按钮上方时，按钮的按钮的elevation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，按钮为启用状态并被按下时其相对于父级的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.highlightElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，当按钮为不可用状态时其相对于父级的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，设置按钮的内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，设置按钮形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，用于设置内容将被如何裁剪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//FocusNode类型可选命名参数，按钮的焦点节点  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名命名参数，用于设置是否按钮为当前焦点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，设置按钮的最小点击尺寸</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Duration类型可选命名参数，用于定义按钮形状或高亮变化的动画的持续时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.animationDuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，按钮的最小宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.minWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，按钮的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，当检测到手势时，是否提供听觉视觉的反馈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enableFeedback = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，是为按钮设置的显示标签，可以为任意Widget，通常使用Text</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>基本使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Widget基础"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: studyWidget(context),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码值修改此函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> MaterialButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Text(<span class="string">"MaterialButton"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.red,    <span class="comment">//不设置填充色默认为无色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="2-RaisedButton-Widget"><a href="#2-RaisedButton-Widget" class="headerlink" title="2. RaisedButton Widget"></a>2. RaisedButton Widget</h5><p><code>RaisedButton</code> 是一种外观凸起的按钮，其最小尺寸为 88.0 * 36.0 。构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RaisedButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> VoidCallback onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VoidCallback onLongPress,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ValueChanged&lt;<span class="built_in">bool</span>&gt; onHighlightChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ButtonTextTheme textTheme,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color textColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color disabledTextColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color highlightColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Color splashColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Brightness colorBrightness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> focusElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> hoverElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> highlightElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> disabledElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  EdgeInsetsGeometry padding,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ShapeBorder shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Clip clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  FocusNode focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  MaterialTapTargetSize materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Duration</span> animationDuration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>参数与 <code>MaterialButton</code> 相同部分不再介绍。使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码值修改此函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Text(<span class="string">"RaisedButton"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也可写做如下形式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码值修改此函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Text(<span class="string">"RaisedButton"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    onPressed: buttonPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> buttonPressed() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其默认效果如下：</p>
<p><img src="/content/aa8d162/202038212.jpg" alt="202038212"></p>
<p>其他属性如下，使用纵向布局 Widget <code>Column</code> 来展示，如下： </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">      RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"RaisedButton1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.red,   <span class="comment">//按钮填充色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        textColor: Colors.amber,  <span class="comment">//文字颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"RaisedButton2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        textTheme: ButtonTextTheme.primary,  <span class="comment">//按钮主题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"RaisedButton3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        disabledColor: Colors.blue,  <span class="comment">//按钮禁用时的填充色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"RaisedButton4"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        disabledTextColor: Colors.tealAccent,  <span class="comment">//按钮禁用时的文字颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"RaisedButton5"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        padding: EdgeInsets.all(<span class="number">20.0</span>),  <span class="comment">//设备按钮内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      RaisedButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"RaisedButton6"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shape: BeveledRectangleBorder(    <span class="comment">//设置按钮形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          borderRadius: BorderRadius.circular(<span class="number">8</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/aa8d162/202038245.jpg" alt="202038245"></p>
<p><code>ButtonTextTheme</code> 是一个枚举类型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ButtonTextTheme &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮文本的颜色是黑还是白取决于主题 [ThemeData.brightness]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  normal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮文本的颜色与[ThemeData.accentColor]相同 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  accent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//按钮文本的颜色依赖于[ThemeData.accentColor]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  primary,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>在设置内边距 <code>padding</code> 使用的是 <code>EdgeInsetsGeometry</code> ，<code>EdgeInsetsGeometry</code> 是一个抽象类，其有两个子类 <code>EdgeInsets</code> 和 <code>EdgeInsetsDirectional</code> ，这里使用 <code>EdgeInsets</code> ，其构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过左、上、右、底来创建边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">EdgeInsets.fromLTRB(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.right, <span class="keyword">this</span>.bottom);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//四周创建同样距离的边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">EdgeInsets.all(<span class="built_in">double</span> value) : left = value, top = value, right = value, bottom = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//可以单独为某个方向创建边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">EdgeInsets.only(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.left = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.top = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.right = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.bottom = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//纵向和横向边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">EdgeInsets.symmetric(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> vertical = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> horizontal = <span class="number">0.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) : left = horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">     top = vertical,</span></pre></td></tr><tr><td class="code"><pre><span class="line">     right = horizontal,</span></pre></td></tr><tr><td class="code"><pre><span class="line">     bottom = vertical;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建于指定窗口边距相同的边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">EdgeInsets.fromWindowPadding(ui.WindowPadding padding, <span class="built_in">double</span> devicePixelRatio)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  : left = padding.left / devicePixelRatio,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    top = padding.top / devicePixelRatio,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    right = padding.right / devicePixelRatio,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bottom = padding.bottom / devicePixelRatio;</span></pre></td></tr></table></figure>



<p><code>shape</code> 设置形状使用的是 <code>ShapeBorder</code> ，其也是一个抽象类，这里使用的是其子类，如下：</p>
<p><code>BeveledRectangleBorder</code> 用于创建带有平角或斜角的矩形边框。构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BeveledRectangleBorder(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderSide类型参数，为边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.side = BorderSide.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BorderRadiusGeometry类型命名可选参数，为每个角的半径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.borderRadius = BorderRadius.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>除此之外还有很多其他的形状类可以使用。</p>
<h5 id="3-FlatButton-Widget"><a href="#3-FlatButton-Widget" class="headerlink" title="3. FlatButton Widget"></a>3. FlatButton Widget</h5><p><code>FlatButton</code> 是平面按钮，没有凸起与阴影等效果，如果不设置颜色等只能看见文字(设置文字的情况下)。使用方式与上述相同。</p>
<h5 id="4-OutlineButton-Widget"><a href="#4-OutlineButton-Widget" class="headerlink" title="4. OutlineButton Widget"></a>4. OutlineButton Widget</h5><p><code>OutlineButton</code> 为带边框的按钮，其构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OutlineButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> VoidCallback onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	<span class="comment">//BorderSide类型可选命名参数，为在按钮可用且未点击状态的边框样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.borderSide,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，为按钮不可用状态时的边框颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledBorderColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，为按钮可用状态并按下时边框的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.highlightedBorderColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//.... 省略相同属性部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方式与上述相同。</p>
<p>上面介绍的是 <code>MaterialButton</code> 与其子类按钮，下面介绍其他的功能按钮。</p>
<h5 id="5-FloatingActionButton-Widget"><a href="#5-FloatingActionButton-Widget" class="headerlink" title="5. FloatingActionButton Widget"></a>5. FloatingActionButton Widget</h5><p><code>FloatingActionButton</code> 为 Material Design 设计风格的浮动按钮，可悬停在内容之上，以提升应用程序的主要操作。每个屏幕最多使用一个浮动按钮。其继承自 <code>StatelessWidget</code> 为无状态按钮，有两个构造函数如下：</p>
<p><code>FloatingActionButton()</code> 构造函数，用于创建圆形浮动操作按钮。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FloatingActionButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，是为按钮设置的显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，按钮按下时弹出的提示文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，默认图标和文本颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.foregroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮的背景填充色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，当按钮具有输入焦点时用于填充按钮的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，指针悬停在按钮上时的填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮点击时水波纹效果的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.splashColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Object类型可选命名参数，应用于按钮的“英雄”小部件的标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.heroTag = <span class="keyword">const</span> _DefaultHeroTag(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，相对于其父按钮放置此按钮的z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，当按钮具有输入焦点时，相对于其父按钮放置该按钮的z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，当按钮启用且指针悬停在按钮上方时，按钮的按钮的elevation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，按钮为启用状态并被按下时其相对于父级的高程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.highlightElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，按钮禁用时放置该按钮的z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledElevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Function类型必传参数，为当按钮点击时的回调方法，如果为null，按钮将处于禁用状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，控制此按钮的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.mini = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，设置按钮形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Clip类型可选命名参数，用于设置内容将被如何裁剪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果在当前范围内没有其他节点被聚焦时，此小部件将被选为初始焦点，则为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//MaterialTapTargetSize类型可选命名参数，设置按钮的最小点击尺寸</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.materialTapTargetSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果这是“扩展”浮动操作按钮，则为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isExtended = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Icon(Icons.<span class="built_in">print</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foregroundColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    backgroundColor: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/aa8d162/202038437.jpg" alt="202038437"></p>
<p><code>FloatingActionButton.extended()</code> 构造函数，用于创建一个更宽的带有可选图标和标签的边框形状的浮动操作按钮。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FloatingActionButton.extended(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，为要实现的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，为按钮要显示的标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> Widget label,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//...省略相同功能的属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> FloatingActionButton.extended(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    icon: Icon(Icons.memory),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    label: Text(<span class="string">"按钮"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    foregroundColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    backgroundColor: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    onPressed: ()=&gt; <span class="built_in">print</span>(<span class="string">"按钮被点击"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/aa8d162/202038440.jpg" alt="202038440"></p>
<h5 id="6-IconButton-Widget"><a href="#6-IconButton-Widget" class="headerlink" title="6. IconButton Widget"></a>6. IconButton Widget</h5><p>Material Design 设计风格图标按钮，其继承自 <code>StatelessWidget</code> 为无状态按钮，构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IconButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，用来定义按钮内图标的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.iconSize = <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，用于定义图标按钮的内边距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，用于设置图标显示的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，按钮内部使用的图标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮处于启动状态时，内部图标使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，当按钮具有输入焦点时，按钮图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//Color类型可选命名参数，指针悬停在按钮上时的填充颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hoverColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，用于设置按钮的高亮颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.highlightColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮点击时水波纹效果的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.splashColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选类型参数，按钮禁用状态下，内部图标使用的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	<span class="comment">//Function类型必传参数，为当按钮点击时的回调方法，如果为null，按钮将处于禁用状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onPressed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当其范围内没有其他节点当前被聚焦时，此小部件将被选为初始焦点，则为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，按钮按下时弹出的提示文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，检测到的手势是否提供听觉视觉的反馈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enableFeedback = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> IconButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    icon: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    onPressed: ()&#123;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="7-DropdownButton-Widget"><a href="#7-DropdownButton-Widget" class="headerlink" title="7. DropdownButton Widget"></a>7. DropdownButton Widget</h5><p><code>DropdownButton</code> 用于定义一个下拉菜单按钮，每一个菜单项使用 <code>DropdownMenuItem</code> 定义。一个菜单中的菜单项需要为同一类型。<code>DropdownButton</code> 继承自 <code>StatefulWidget</code> 为一个有状态的 Widget ，其构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DropdownButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// List&lt;DropdownMenuItem&lt;T&gt;&gt;类型必传参数，设置的菜单项列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.items,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//DropdownButtonBuilder类型可选命名参数，用于定制与项目中的下拉菜单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//项(DropdownMenuItem)相对应的按钮</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.selectedItemBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//泛型T类型可选命名参数，为当前选择的是哪个下拉菜单项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，下拉按钮显示的占位符Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.hint,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，当下拉菜单被禁用时显示的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.disabledHint,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Function类型必传参数，选择一个菜单项时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.onChanged,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，打开时放置菜单的z坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation = <span class="number">8</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选命名参数，用于设置下拉菜单中文本的文本的样式，以及点击按钮时出现的下拉菜单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，用于绘制下拉按钮下划线的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.underline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，下拉按钮图标的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮禁用状态的内部图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.iconDisabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，按钮启用状态的内部图标的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.iconEnabledColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，下拉按钮的向下箭头图标按钮的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.iconSize = <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否降低按钮的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isDense = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否将下拉列表的内部内容设置为水平填充其父项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.isExpanded = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，如果为null，则菜单项高度将根据每个菜单项的固有高度而变化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.itemHeight = kMinInteractiveDimension,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，当按钮具有输入焦点时，按钮材质的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FocusNode类型可选命名参数，此小部件的焦点节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.focusNode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果当其范围内没有其他节点当前被聚焦时，此小部件将被选为初始焦点，则为True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>DropdownMenuItem</code> 菜单项的构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DropdownMenuItem(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//泛型T类型可选参数，为当用户选择此菜单项时返回的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.value,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，菜单项要显示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> Widget child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>基本使用方式如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> DropdownButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    items: &lt;DropdownMenuItem&lt;<span class="built_in">int</span>&gt;&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">      DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"Item 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        value: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"Item 2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        value: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Text(<span class="string">"Item 3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        value: <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ],</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    onChanged: (value)=&gt; <span class="built_in">print</span>(value),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="/content/aa8d162/2020381102.jpg" alt="2020381102"></p>
<p>但是现在存在一个问题，虽然可以选择菜单项并且输出对应的 <code>value</code> ，但是操作后界面是无变化的。上面说过 <code>DropdownButton</code> 继承自 <code>StatefulWidget</code> ，是一个有状态的 Widget，对于有状态的 Widget ，前面文章曾经介绍过，都会与状态类一起使用，在状态类中对数据界面做操作才能实现界面的更新操作，更改代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Widget基础"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: MyDropdownMenu(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDropdownMenu</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> _MyDropdownMenuState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyDropdownMenuState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyDropdownMenu</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> currentSelectIndex = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> DropdownButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      items: &lt;DropdownMenuItem&lt;<span class="built_in">int</span>&gt;&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Item 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Item 2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Item 3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ],</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      value: currentSelectIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      onChanged: (value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          currentSelectIndex = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>将更新数据项放在 <code>setState()</code> 方法内进行操作即可。</p>
<p>其他属性设置如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyDropdownMenuState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyDropdownMenu</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> currentSelectIndex = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> DropdownButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      items: &lt;DropdownMenuItem&lt;<span class="built_in">int</span>&gt;&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Item 1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Item 2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        DropdownMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"Item 3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ],</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      value: currentSelectIndex,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      selectedItemBuilder: (BuildContext context)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Icon(Icons.<span class="built_in">print</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          Icon(Icons.ac_unit),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      hint: Text(<span class="string">"hint"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      disabledHint: Text(<span class="string">"按钮被禁用"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fontSize: <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      underline: Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        height: <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      icon: Icon(Icons.arrow_downward),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      onChanged: (value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          currentSelectIndex = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/aa8d162/202039228.jpg" alt="202039228"></p>
<p><code>selectedItemBuilder</code> 使用 <code>DropdownButtonBuilder</code> 构造器，其是一个返回 <code>List&lt;Widget&gt;</code> 的 <code>Function</code> ，圆形为：<code>List&lt;Widget&gt; Function(BuildContext context)</code> ，作用是定义与下拉列表中选项相对应的每一个 Widget ，这个 Widget 用来显示在菜单未点开的情况下显示。</p>
<p><code>hint</code> 用来定义按钮在 <code>value</code> 属性为 <code>null</code> 或此按钮被禁用且 <code>disabledHint</code> 属性也为 <code>null</code> 时显示。</p>
<p><code>disabledHint</code> 如果不为 <code>null</code> ，在按钮被禁用时显示。</p>
<p><code>icon</code> 属性用来定义下拉按钮靠右侧显示的图标。</p>
<h5 id="8-PopupMenuButton-Widget"><a href="#8-PopupMenuButton-Widget" class="headerlink" title="8. PopupMenuButton Widget"></a>8. PopupMenuButton Widget</h5><p><code>PopupMenuButton</code> 是弹出菜单</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PopupMenuButton(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PopupMenuItemBuilder&lt;T&gt;类型必传参数，当按下按钮创建要在菜单中显示的项目时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.itemBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//泛型T类型可选命名参数，菜单打开时应突出显示的菜单项的值(如果有)，也就是打开时选择哪一项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.initialValue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PopupMenuItemSelected&lt;T&gt;类型可选命名参数，当用户从该按钮创建的弹出菜单中选择一个值时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onSelected,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PopupMenuCanceled类型可选命名参数，当用户在不选择项目的情况下关闭弹出菜单时调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.onCanceled,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，按钮按下时弹出的提示文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.tooltip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，打开时放置菜单的z坐标。这控制了菜单下阴影的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.elevation,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//EdgeInsetsGeometry类型可选命名参数，默认情况下匹配图标按钮的8 dps填充。在某些情况下，特别是当该按钮作为列表项的尾部元素出现时，能够将填充设置为零是很有用的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.padding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，如果提供，child是用于该按钮的小部件，该按钮将利用InkWell进行点击</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型可选命名参数，如果图标用于此按钮，该按钮的行为类似IconButton</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.icon,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Offset类型可选命名参数，应用于弹出菜单按钮的偏移量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.offset = Offset.zero,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，该弹出菜单按钮是否是交互式的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.enabled = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ShapeBorder类型可选命名参数，用于菜单的形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shape,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，菜单背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，如果为真(缺省值)，那么菜单将被包装成继承主题的副本，如主题和弹出主题，它们被定义在显示菜单的构建上下文之上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.captureInheritedThemes = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>itemBuilder</code> 的类型是 <code>PopupMenuItemBuilder&lt;T&gt;</code> ，其是一个 <code>Function</code> ，原型为：<code>List&lt;PopupMenuEntry&lt;T&gt;&gt; Function(BuildContext context)</code> 。<code>PopupMenuButton</code> 的使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Widget基础"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: MyPopupMenuButton(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPopupMenuButton</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement build</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> PopupMenuButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      itemBuilder: (context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> &lt;PopupMenuEntry&lt;<span class="built_in">String</span>&gt;&gt; [</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">const</span> PopupMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"选项1"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value: <span class="string">"1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">const</span> PopupMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"选项2"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value: <span class="string">"2"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">const</span> PopupMenuItem(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child: Text(<span class="string">"选项3"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value: <span class="string">"3"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      onSelected: (value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      onCanceled: ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">print</span>(<span class="string">"未选择任何选项，菜单关闭"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      icon: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      initialValue: <span class="string">"2"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      offset: Offset(<span class="number">50</span>, <span class="number">110</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中，<code>child</code> 和 <code>icon</code> 只能选择一个使用，都是图标在界面上未展开时显示的 Widget 。这里使用的是无状态的形式，如果需要对界面做数据更新处理，则需要使用 <code>StatefulWidget</code> 。</p>
<p>效果如下：</p>
<p><img src="/content/aa8d162/2020310448.jpg" alt="2020310448"></p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(三)</title>
    <url>/content/f0eb3e6d.html</url>
    <content><![CDATA[<h4 id="一、Image-Widget"><a href="#一、Image-Widget" class="headerlink" title="一、Image Widget"></a>一、Image Widget</h4><p><code>Image</code> Widget 是 Flutter 中用来显示图片的小部件。支持以下图像格式：JPEG，PNG，GIF，动画GIF，WebP，动画WebP，BMP和WBMP 。 <code>Image</code> Widget 提供了以下构造函数用于创建图像：</p>
<a id="more"></a>

<p><code>Image()</code> ，用于从 <code>ImageProvider</code> 获取图像。</p>
<p><code>Image.asset()</code> ，从 <code>AssetBundle</code> 获取图像。</p>
<p><code>Image.network</code> ，从URL获取图像。</p>
<p><code>Image.file</code> ，从本地文件获取图像。</p>
<p><code>Image.memory</code> ，从 <code>Uint8List</code> 获取图像。</p>
<h5 id="1-Image-构造方法"><a href="#1-Image-构造方法" class="headerlink" title="1. Image() 构造方法"></a>1. Image() 构造方法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Image(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageProvider类型必传参数，为要显示的图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.image,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageFrameBuilder类型可选命名参数，是一个Function，返回一个代表该图像的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.frameBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageLoadingBuilder类型可选命名参数，用于指定在图像加载过程中向用户展示的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.loadingBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，为图像的语义标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，是否从语义中排除此图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，图像要显示的宽度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，图像要显示的高度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，如果不为null，则使用colorBlendMode将此颜色与每个图像像素混合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BlendMode类型可选命名参数，用于设置color与图像混合的模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.colorBlendMode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//BoxFit类型可选命名参数，用于设置图像的填充模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//AlignmentGeometry类型可选命名参数，设置图像的对齐模式，其为抽象类，使用其子类Alignment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//ImageRepeat类型可选命名参数，用于设置布局中图像的重复模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Rect类型可选命名参数，用于设置当一个图片被拉伸时的范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.centerSlice,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，用于设置是否以TextDirection相同的方向来绘制图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，用于设置在图像提供者更改时，是否继续显示旧图像。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//true为显示旧图像，false为暂时不显示任何图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FilterQuality类型可选命名参数，用于设置图片的过滤质量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Image()</code> 构造方法的必传参数类型为 <code>ImageProvider</code> ，是一个抽象类，不能直接实例化。其有5个直接子类分别为：<code>AssetBundleImageProvider</code> ， <code>FileImage</code> ，<code>MemoryImage</code> ，<code>NetworkImage</code> ，<code>ResizeImage</code> ，可以直接使用。这几个类，是根据不同的图片源选择对应的加载方式，使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Widget基础"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: studyWidget(context),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码只修改此函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Image(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image: NetworkImage(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="2-Image-network-构造方法"><a href="#2-Image-network-构造方法" class="headerlink" title="2. Image.network() 构造方法"></a>2. Image.network() 构造方法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.network(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型必传参数，用于设置图片的网络URL地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> src, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，图像的缩放级别，值越大图片越小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> scale = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.frameBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.loadingBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.colorBlendMode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.centerSlice,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Map&lt;String, String&gt;类型可选命名参数，用于发送带有图像请求的自定义的HTTP头  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，用于减少ImageCache的内存使用量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型可选命名参数，用于减少ImageCache的内存使用量  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;) </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以上未注释的参数与Image()构造方法含义相同</span></span></pre></td></tr></table></figure>

<p>本构造方法是当从网络加载图片时使用，使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Image.network(<span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在创建 <code>Image</code> Widget 时，最好指定其大小，或者放在能严格限制其布局的上下文中，否则图像尺寸会随时图像的加载而改变。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Image.network(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/f0eb3e6d/202035639.jpg" alt="202035639"></p>
<p>一般一个 <code>Image</code> Widget 都是放在特定的 Widget 中的，这样可以限制其展示范围，也可以有良好的布局。其很多属性也依赖于外围 Widget。这里使用 <code>Container</code> Widget ，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.network(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      width: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      height: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/f0eb3e6d/202035649.jpg" alt="202035649"></p>
<p>从上图可以发现，当 <code>Image</code> Widget 放在一个布局组件中以后，其 <code>width</code> 和 <code>height</code> 属性就不起作用了，其在保持原图比例的情况下会尽量占满其父级 Widget ，且位于中间显示。我们可以设置其填充属性做更改，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.network(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      fit: BoxFit.fill,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>BoxFit</code> 是一个枚举类型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> BoxFit &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/// <span class="markdown">完全填充目标容器，如目标容器比例与图比例不同，图会被拉伸</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">![](https://flutter.github.io/assets-for-api-docs/assets/painting/box<span class="emphasis">_fit_</span>fill.png)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  fill,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/// <span class="markdown">尽可能大的展示完整图片并且会保持原图比例，所以对于矩形来说，总会有对应的面被对齐容器边缘，上下、左右</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">![](https://flutter.github.io/assets-for-api-docs/assets/painting/box<span class="emphasis">_fit_</span>contain.png)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  contain,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">保持原图比例的情况下尽可能小的展示图片，但是会在覆盖整个容器的情况下尽可能小</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">![](https://flutter.github.io/assets-for-api-docs/assets/painting/box<span class="emphasis">_fit_</span>cover.png)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cover,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">保持原图比例的情况下填充目标容器宽度，上下如果溢出会被裁掉</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">![](https://flutter.github.io/assets-for-api-docs/assets/painting/box<span class="emphasis">_fit_</span>fitWidth.png)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  fitWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">保持原图比例的情况下填充目标容器高度，左右如果溢出会被裁掉</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">![](https://flutter.github.io/assets-for-api-docs/assets/painting/box<span class="emphasis">_fit_</span>fitHeight.png)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  fitHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">在目标荣内展示原图，不对宽高做更改。以原图的大小居中显示，溢出部分被裁掉</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">![](https://flutter.github.io/assets-for-api-docs/assets/painting/box<span class="emphasis">_fit_</span>none.png)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  none,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">在目标容器居中对齐原图。如果需要，将源文件向下缩放，以确保源文件适合该框</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">![](https://flutter.github.io/assets-for-api-docs/assets/painting/box<span class="emphasis">_fit_</span>scaleDown.png)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  scaleDown,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面对应的都有官方的样式图片地址，可自行查看。</p>
<p>图像的对齐模式是相对于父级容器来说的，实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.network(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      alignment: Alignment.centerRight,  <span class="comment">//中心靠右对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="/content/f0eb3e6d/202035836.jpg" alt="202035836"></p>
<p>也可以设置其他对齐方式，可自行查看，都比较简单，选择对应的选项就可以。</p>
<p>图像的重复模式，就是当一个图像并不能完全占满父级容器时，以什么样的模式进行填充， 如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.network(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      repeat: ImageRepeat.repeatY,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上是按照Y轴重复的模式填充，效果如下：</p>
<p><img src="/content/f0eb3e6d/202035846.jpg" alt="202035846"></p>
<p>也可以按照X轴填充，同时按照X，Y轴填充等。</p>
<p>填充颜色，其中的 <code>color</code> 属性，当单独设置颜色属性时，就是绘制图片的颜色，图片内容将被覆盖。可以选择颜色与原图的混合模式进行设置，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.network(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"http://www.mwpush.com/uploads/avatar.png"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      color: Colors.red,   <span class="comment">//设置源颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      colorBlendMode: BlendMode.difference,   <span class="comment">//设置混合模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/f0eb3e6d/202035922.jpg" alt="202035922"></p>
<p>更多混合效果及方法，官网查看地址：<a href="https://api.flutter.dev/flutter/dart-ui/BlendMode-class.html" target="_blank" rel="noopener">https://api.flutter.dev/flutter/dart-ui/BlendMode-class.html</a></p>
<p>对于图片拉伸属性 <code>centerSlice</code> ，其值为一个 <code>Rect</code> ，我们通过一张图片的设置来说明这个参数的设置。这里准备了一张原图，如下：</p>
<p><img src="/content/f0eb3e6d/centerSlice.jpg" alt="centerSlice"></p>
<p>这张图被分割线分成了9个矩形，<code>centerSlice</code> 设置的矩形区域为标记为5的矩形区域。这里的图片宽度为1000 ，高度为500 ，区域 1，3，7，9 的宽高均为100 ，所以可以得出区域 5 的左上角的起始坐标为100，100，宽度为800 ，高度为 300 。 这里使用了加载本地 AssetBundle 的文件方式加载的图片，下面会进行讲解。这里先展示原图的代码，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.asset(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"images/centerSlice.jpg"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      scale: <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/f0eb3e6d/2020351025.jpg" alt="2020351025"></p>
<p>由于图片太大，为了在 <code>Container</code> 边缘留有空间，使用了缩放属性 <code>scale</code> 。</p>
<p>设置拉伸属性代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.asset(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"images/centerSlice.jpg"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      scale: <span class="number">3</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      centerSlice: Rect.fromLTWH(<span class="number">100</span>, <span class="number">100</span>, <span class="number">800</span>, <span class="number">300</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/content/f0eb3e6d/2020351027.jpg" alt="2020351027"></p>
<p>这里我们使用了 <code>Rect.fromLTWH()</code> 构造方法创建 <code>Rect</code> 。其参数依次分别为距离左侧的距离，距离顶部的距离，宽度，高度。通过前两个属性，我们可以得知，在本图中，L和T属性能确定矩形的起始点就是图中区域 1 的 右下角，跨度高度分别为上面计算的800和300，所以可以看出，除了区域 1，3，7，9 外，都会被拉伸。区域 2 和 区域 8 是横向拉伸，区域 4 和 区域 6 是纵向拉伸，区域 5 是横向纵向都拉伸。</p>
<h5 id="3-Image-file-构造方法"><a href="#3-Image-file-构造方法" class="headerlink" title="3. Image.file() 构造方法"></a>3. Image.file() 构造方法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.file(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//File类型必传参数，从File获取ImageStream</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  File file, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> scale = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.frameBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.colorBlendMode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.centerSlice,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以上未注释的参数与Image()构造方法含义相同</span></span></pre></td></tr></table></figure>

<p><code>Image.file()</code> 是加载本地文件时使用，必传为 <code>File</code> 类型，使用 <code>File</code> 需要引入 <code>dart:io</code> 。使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.file(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      File(<span class="string">"/path/images/avatar.png"</span>),   <span class="comment">//path 为您的图片本地路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="4-Image-asset-构造方法"><a href="#4-Image-asset-构造方法" class="headerlink" title="4. Image.asset() 构造方法"></a>4. Image.asset() 构造方法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.asset(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型必传参数，从</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  AssetBundle bundle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.frameBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> scale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.colorBlendMode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.centerSlice,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> package,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以上未注释的参数与Image()构造方法含义相同</span></span></pre></td></tr></table></figure>

<p><code>Image.asset()</code> 用来加载应用本身的资源图片。使用此方式时，需要在 <code>pubspec.yaml</code> 配置文件中对资源做配置。比如，在项目的根目录中新建 images 文件夹，并在其中添加图片 avatar.png ，需要在 <code>pubspec.yaml</code> 文件中有如下配置： </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">assets:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">images/avatar.png</span></span></pre></td></tr></table></figure>

<p>在默认创建的 <code>pubspec.yaml</code> 中有 <code>assets</code> 的配置示例，为被注释状态，在42行左右，进行修改即可。</p>
<p>使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.asset(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"images/avatar.png"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在配置 <code>pubspec.yaml</code> 时，要注意 YAML 的语法规则，对齐方式很重要。</p>
<p>为了应对不同设备分辨率，可以同时配备一张图片的多张不同分辨率图片来对不同的显示做匹配。在 Flutter 中做如下处理。如提供2倍图与3倍图：</p>
<ol>
<li><p>创建不同比例文件夹，在 images文件夹中新建名为 <code>2x</code> 和 <code>3x</code> 的文件夹。其他比例同样操作。</p>
</li>
<li><p>将对应的2倍图放入 <code>2x</code> 文件，3倍图放入 <code>3x</code> 文件夹，同一图片的不同分辨率的图片名称格式要相同。如下图：</p>
<p><img src="/content/f0eb3e6d/202036542.jpg" alt="202036542"></p>
</li>
<li><p>在 <code>pubspec.yaml</code> 配置文件中配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">assets:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">images/avatar.png</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">images/2x/avatar.png</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">images/3x/avatar.png</span></span></pre></td></tr></table></figure>
</li>
<li><p>实现代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.asset(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">"images/avatar.png"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ol>
<p>在像素比例为2.0的屏幕上，将自动加载渲染 images/2x/avatar.png 图片。可以不提供1倍图，但是 <code>pubspec.yaml</code> 中的配置 <code>- images/avatar.png</code> 必须存在，此时在需要1倍图的设备是上会使用2倍图代替。</p>
<h5 id="5-Image-memory-构造方法"><a href="#5-Image-memory-构造方法" class="headerlink" title="5. Image.memory() 构造方法"></a>5. Image.memory() 构造方法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.memory(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Uint8List类型必传参数，为图片的字节数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Uint8List bytes, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> scale = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.frameBuilder,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.excludeFromSemantics = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.width,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.colorBlendMode,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.centerSlice,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.gaplessPlayback = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.filterQuality = FilterQuality.low,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheWidth,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> cacheHeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以上未注释的参数与Image()构造方法含义相同</span></span></pre></td></tr></table></figure>

<p>当通过网络或本地获取图片的字节数据进行图片渲染时，可以使用 <code>Image.memory()</code> 构造方法进行处理。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:typed_data'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Widget基础"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: studyWidget(context),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> imgString = <span class="string">"iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAYAAAB5fY51AAAgAElEQVR4nO3db2xT190H8J+dkAUShSEYbKyjCimu0JawAhlaEgpzKYRS1FGWzFBAlJhASKbn0R5te/MkL8b2plOYHqlsEBxgLUPgCFpE/yQsTcsgTtvAUJKhgUuMhLq0zqCgyGEpJL7PC3o9+/ravveca8fn+vuRLIjjc+7JH39zz7nnnGuRJEkiAAABWCe7AQAAWiGwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAgsAhIHAAgBhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAgsAhIHAAgBhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAgsAhIHAAgBhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABBG9mQ3wKwePnxI9+7dS/lxc3JyaPr06Sk/brr617/+NSnHnTp1KuXn50/Ksc0MgZUkXq+Xvve976X8uEuXLqWPPvqIrFacPN+6dYsef/zxSTn2/v37ac+ePZNybDNDYJnMpUuX6OrVq1RcXJzwtRM9PSQNDWmu22qzkTWs3vFTp3S1Lauykix5eYa0J1FdRETnz5/X1T5IfwgsE+rs7NQUWMGPPqKJ//1fzfVm/+lPEYE14XKRdOGC5vJZPh9RnJDR055EdRERndIZqJD+0G8woSNHjlAwGEz4uin//d+UGwjQlNOnyfLEE6qvsTqdlNPTQ7mBAGVv3Bjxua+9+y7lBgKUMzBAVqdTtXz2n/5EuYEA5QYCZJk9W1N7vubzkXXDhojPWZ54QlddQ0NDdObMmbivAfEgsExoYGCABgYGNL8+a/Vqyjl3jizLl0d9bspvfxtxVqXGWlhIU37726jy1g0bokJOC8vs2ZQVNv5jeeIJyjl3TlddH3zwge7jQvpDYJlUR0eHrtdbZs+mKX/4A/PxLHl5lBXjLIupvrArbNmvvJLwjErpzTffNKwtkD4QWCbV2tpKExMTuspYCwsp6xe/iHgu2N+vuXxWZWVE1zL4xhskjY7qakOorNdLRESW5cspa/VqXWX9fj+1tbUxHRfSGwLLpLxeL/XrCBtZ1osvRnwcPHdOc1lLXl7U2NNEe7vuNhARBb8azGc5a8PVQfNCYJnY22+/rbuMtbg44ixp4ne/03WWZFWcDQV1XEWUSaOjFHS5HtW3eLHu8m+88YbuMiAGBJaJHT58mMbHx3WXy/qv/4r4WM9ZUtYPfxjZLXS5SBoe1nV8+XjWDRvIWlioq+zt27fpxIkTusqAOBBYJnbz5k26cuWK7nLWlSsjPtZ7lmTdvj3i4wmd5YNfDZhbf/xjXeWIiP7617/qLgPiQGCZ3DvvvKO7jLWwMGKKgt6zpKDiCuXEV907LaThYQp+1aXLqqzUXE6G7qC5IbBMrqWlhR48eKC7nHKwW+tZUnBgIGr2u3ThAgU1zguTj2N1OhMuvVH64osv6NixY7rKgFgQWCY3NDREly9f1l0uSzEJNKhxXlPw0iXV5yfee09TeflsLOu55zS9Plx3d7fuMiAWBFaaczgc3DsvtDNMLbDMnh0xRSH4xhsUvHkzYbmJ//s/Inq0JCdc8OjRhGWDN2+Gzs6s5eU6WvsI72TRp556isrKyrjqgORCYKU5h8NBO3bs4KrjwIEDNDY2prucctA7mGC5y0RPD0k3bpDliScoq7IyIvCkGzdooqcnbnm5/qxf/EJ3d/DevXt0VEMoxlNbW0vLVZYnQfpAYAlgI8N6vHDDw8PU29uru5xy0HvC7Y77enmSqXX79keTSJWBl2ASqnx2ppzLpUVPT4+mBd/xlDOc1UFqIbAEUFFRQQUFBVx1MHUL8/IidmGIN3gujY7SxO9+R0REWc888+hfZeDFmYQaHBgInZ1ZS0p0t/Xs2bO6y4R77LHHaOHChVx1QPIhsASQn59PdXV1XHUcPHiQ/v3vf+supxz8jjV4Lk/2tCxfHtrdwZKXF7U2MdYkVLle+exMj5GREWppadFVRumll16i7GxsD5fuEFiCWL9+PVf5O3fu0EcffaS7nHLwO9bguXwVMau6OrK8cqmOysC4NDoaqlc+O9Ojp6dH90JvpVWrVnGVh9RAYAmitLSUCnUuU1F66623dJdRniWpDZ4Hb94MTfZUzpK3lpRE7eCgvNoY7O//T3dQw06pSiyTY8NlZWXRD37wA646IDUQWILIycmh2tparjoOHTpE9+/f110u6ixJMXguX91TW/tnycuLWqqjvNoo16dcw6hFIBDg7g5u376de4wQUgOBJZC1a9dylR8ZGSGPx6O7XNSCZsU+V/LVw1hr/5TdvPCrjeGD9cqzMy0+/PBDpikb4Z5//nmu8pA6CCyBFBcX09KlS7nqYL2aFn6WJN24QcGvZpWHL8WJtfbPWlwcsTYx/GqjXI9l+XLdOzMQsV39VMJ0BnEgsARitVqppqaGq46WlhYKBAK6y0WdJX01biRf3Us02TNqbeJX5eR6WDbqu3//Ph06dEh3uXA/+clP6Bvf+AZXHZA6CCzBPPvss1zlx8bGmLqFyo395B0c5Kt7iSZ7KjfiCx49+miwnmOjvo8//phGRkZ0lwv3Y4YtbGDyILAEU1RURJUM266EY11zpxwUf/g//6N5sqe1sDBqqc54U9OjzzFs1EdkTHcQS3HEgsAS0NatW7nKt7S0MJ2ZRG3sJ09l0DjZM2qpjlye4SxnbGyMXDr22VJTWVlJ8+bN46oDUguBJaBnGCZXhpuYmGDaikV5liTTOtkz1qC8cisbLXp7e+nOnTu6y4VzOBxc5SH1EFgCmjNnDm3bto2rjtOnTzOVU54NhS/FSURtqY7V6dR9z0EiY7qDP/rRj7jrgNRCYAmqqqqKq/zhw4fp7t27usspz4b0Xt2z/vCHkeUZNup78OAB91Yy6A6KCYElqKeffppyc3OZyweDQbp48aLucsqN/fR256zl5RFXG1k26rt8+TINDQ3pLhcO3UExIbAEVVBQQLt37+aqg/VqodwtZOnOhS/VYdmojwjdwUyGwBIY7xyiw4cP0+3bt3WXkwfPrYxTAuRBepaN+sbHx3F1MIMhsAS2bNkymjt3LlcdLPfxkwfPWW7DRfSfpTosG/VduXIF3cEMhsASWG5uLu3atYurDtb7+GXX1TF152RT/vAHpvIdinseskB3UFwILMHx7jRw7NgxGtZ5K3kiYpqKEI5lZvv4+DgdPnyY67joDooNgSW4RYsWUTHDpnfhPkhwN5x00d/fTzc13GosHnQHxYbAElxWVhY5GXY6CHfq1CmDWpNcnZ2d3HWgOyg2BJYJ8C6Gdrvd5Pf7DWpNckxMTFBraytXHegOig+BZQILFiwgu93OVUdXV5dBrUmOv//97+T1ernqQHdQfAgsE7BYLNxrC0+ePGlQa5LDiEBFd1B8CCyT4N3Y78yZM9zzm5IlGAzSkSNHuOpAd9AcEFgmMXfuXO4uT7p2C69evUoDMe44rRW6g+aAwDKRasVNTPX685//bFBLjPX+++9z14HuoDkgsExk5cqVlJWVxVy+vb2dbt26ZWCL+EmSRK+//jpXHegOmgcCy0RmzJjBvYODEWczRrp27RpdunSJqw50B80DgWUyvDs4HDt2zKCWGANXByEcAstkysrKaObMmczlOzs7yefzGdgidpIk0fHjx7nqQHfQXBBYJjNt2jTas2cPVx3p0i28ceMG0z0Uw7300ksGtQbSAQLLhNatW8dV/vjx4yRJkkGtYffeV3eH5sG7AgDSCwLLhJYsWUI2m425fFdXF924ccPAFrE5ceIEV/mNGzdyb3AI6QWBZULZ2dncG/sZcXbDw+fz0fnz57nq4J2XBukHgWVSvDs4vP7665PaLTRiHG2l4k7VID4ElkktXLiQysrKmMt7PB66fv26gS3Sh/fq4JYtW2g2566okH4QWCZlsVhox44dXHX85S9/Mag1+ty6dYt7/tXGjRsNag2kEwSWifHu4PDaa69NSreQtztotVppxYoVBrUG0gkCy8TmzZvHNfP90qVLdO3aNQNbpA3v1cGXX36ZZsyYYVBrIJ0gsExu06ZNXOWNuMuyHp9++in3MdEdNC8ElsnZ7XayWtl/zEeOHKFgMGhgi+JjubFruClTplB5eblBrYF0g8AyuVmzZnENvg8MDNDVq1cNbFF8brebq3xdXR0VFBQY1BpINwisDMDbRTp37pxBLYlvaGiIzpw5w1UH741lIb0hsDJARUUF11lHS0sLTUxMGNgidRcvXuQqX1BQgO6gySGwMkB+fj7V1dUxl/d6vdTf329gi9Tx3tB1586dNG3aNINaA+kIgZUh1q9fz1U+2ZNI/X4/9/jVCy+8YFBrIF0hsDJEaWkpFRYWMpdvaWmh8fFxA1sUibc7OHPmTCotLTWoNZCuEFgZIicnh2pra5nLDw4O0pUrVwxsUaQ333yTq/yePXsoNzfXoNZAukJgZZC1a9dyle/o6DCoJZFu377NvZc879cGYkBgZZDi4mJaunQpc/nDhw/Tw4cPDWzRI7yTRQsLC2nJkiUGtQbSGQIrg1itVqqpqWEuf/PmTe5bbql5++23ucrv2LGDcnJyDGoNpDMEVobh3cHB6LWFd+/epaNHj3LVge5g5kBgZZiioiKu3UhdLhc9ePDAsPZcvHiRa62izWaj73//+4a1B9IbAisDbd26lbns0NAQ9fb2GtaWt956i6v8zp07KSsry6DWQLpDYGWgZ555hqv8O++8Y0g7RkZGqLW1lauONWvWGNIWEAMCKwPNmTOHtm3bxlz+4MGDNDY2xt2O7u5urjWKixYtou9+97vc7QBxILAyVFVVFXPZO3fuGNItPHv2LFf5mpoarr2+QDz4aWeop59+mmtmOO82MIFAgFwuF1cdvFc8QTwIrAxVUFBAu3fvZi5/6NAhun//PnP5np4erkmoZWVl9OSTTzKXBzEhsDIYzw0qRkZG6OOPP2Yuz3t1cOvWrWSxWLjqAPEgsDLYsmXLaO7cuczlWbuFo6Oj1NLSwnxcIqLVq1dzlQcxIbAyWG5uLu3atYu5/IEDBygQCOgu19vby3WVcfXq1TR//nzm8iAuBFaG49kDfWxsjHp6enSX4+0Obtmyhas8iAuBleEWLVpExcXFzOX1hs/9+/fp0KFDzMcj4p/4CuJCYGW4rKwscjqdzOX/+Mc/0sjIiObXX758WdfrlaqqqrjG3UBsCCzgWgz98OFD6u7u1vx63t0eqqurucqD2BBYQAsWLCC73c5cXuuM9bGxMTp48CDzcaxWK61cuZK5PIgPgQVksVi41ha2tLTQvXv3Er7u0qVLdOfOHebjbN++nWbNmsVcHsSHwAIi4lvmMjExQRcuXEj4Ot5bhfHewRrEh8ACIiKaO3cuORwO5vKJ7nrz4MEDrrWDubm5VFFRwVwezAGBBSE8A9pHjx6lu3fvxvz85cuXaWhoiLn+2tpaKigoYC4P5oDAgpCVK1cy794ZDAbp/PnzMT/f2dnJ2iwiItqwYQNXeTAHBBaEzJgxg2sHh1OnTqk+Pz4+TkeOHGGud+bMmbRs2TLm8mAeCCyIwLODw7Fjx+j27dtRz1+5coVu3rzJXG9dXR1NnTqVuTyYBwILIpSVldHMmTOZy6t1C8+dO8fTJHruuee4yoN5ILAgwrRp02jPnj3M5d1ud8THExMT9NprrzHXV1hYSKWlpczlwVwQWBBl3bp1zGXdbjf5/f7Qx/39/eT1epnr27lzJ2VnZzOXB3NBYEGUJUuWkM1mYy4f3i3knSyKuzpDOAQWRMnOzuba2O/kyZNE9GiqA8/VweLiYiopKWEuD+aDwAJVPDs4nD59moaGhujq1at07do15nqcTidu4wUR8NsAqhYuXEhlZWXM5T/44APuyaLYtx2UMJoJqiwWC+3YsYM8Hg9T+ZqaGq67OldUVOA2XhAFgQUx8ezgwHsr++3bt+M2XhAFXUKIad68eVwz33msWrVqUo4L6Q2BBXFt2rQp5cdct24dPf744yk/LqQ/BBbEZbfbU36lbvPmzSk9HogDgQVxzZo1i3bs2JHSY+I2XhALAgsSSuXWxJs3b6Y5c+ak7HggFgQWJFRRUZGy3T6rqqpSchwQEwILEsrPz6e6urqkH8dqtdKKFSuSfhwQFwILNFm/fn3Sj1FbW0szZsxI+nFAXAgs0KS0tJQKCwuTeozJmvMF4kBggSY5OTlUW1ubtPrz8vKovLw8afWDOSCwQLNk7k21e/duys/PT1r9YA4ILNCsuLiYli5dmpS6X3jhhaTUC+aCwALNrFYr1dTUGF7v3LlzsW87aILAAl14dnCIxel0Um5uruH1gvkgsECXoqIirt1I1Tz//POG1gfmhcAC3bZu3WpYXTabjZ566inD6gNzQ2CBbkYuTsZtvEAPBBboNmfOHNq2bZshda1Zs8aQeiAzWCRJkia7EWY0MTFBX375JXc9OTk5aXkG8uDBAxofH+euZ+rUqWm1FfKXX37JtRe9LDs7m3JycgxoEYRDYAGAMNAlBABhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAgsAhIHAAgBhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEEb63d3AIOl0YwOAVDPrrRpwhgUAwkBgAYAwEFgAIAwEFgAIA4EFAMJAYAGAMBBYACAMBBYACAOBBQDCQGABgDAQWAAgDNOuJTTrWiqATIYzLAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAiuN+Xw+6u/vn+xmZDR8/9MLAstgHR0d1NbWFvp4dHSUhoeHmer6/PPPadGiRWSxWEKPTZs2GdVUww0PD0e01WKx0L59+ya1TT6fj9ra2qIeWnV2dkZ8Pa2trdTR0aH6Wo/Hw/yzBm0QWAYbGRmh6urq0C/44sWLafbs2Ux1ffOb34x67mc/+xlvE5MmLy8v6rlVq1ZNQkv+45NPPqHq6uqIx7e//W3m+pxOZ9RzPp+PmpqaqLy8nF599VWe5kICCCyDFRQURHz805/+lLmu/Px8Tc+lC7XAKikpifl6j8dDTz75JPl8vqS16Vvf+lbExzabjcrKyjSXnz59etRzFRUVof/v27ePioqKaO/evUREtHfvXvJ4PIythUQQWEn29a9/fbKbMGnsdrvq8/39/dTQ0EDl5eXk9Xpp7dq1KetKPfvss7per/wD5HA4IoJ5165dUV9nY2MjjY6OsjcSYkJgQUp5PB5atGgR7d+/P/Sc1+ulTZs2pSS05s+fz1V+5syZER/n5eXR73//+4jnurq66MSJE1zHAXUILEipsrIy6uvrI5vNFvF8V1cXbdq0Ke3OTJRnWGqBV1JSQs3NzRHPOZ3OpHZ1MxUCC1KupKSE3n33XdXQcjqdaRdaWuzatSvq69m5c+cktca8EFgwKebPn686veDEiRPkdDqFmx6Ql5dHv/nNbyKe2717t3BfR7pDYE0S5XwltcecOXOiyinnZWl5pOtVq5KSEnK73VHPL1iwgG7cuDEJLYqmvMoYz3PPPUdERC6XiyRJoqqqKuYpLaDOtHu6pzu73U5dXV0pOVY6T4WoqqqixsZG2rt3LzU2NlJDQ0Nav8njjUvl5eVRIBCImt7h8Xjoww8/pOnTp1NNTU2ym2hqCCyYdL/61a+osrJS1/yodCWHVUdHB3366acRE00bGxsnq1mmgcCaJKk6uyIiCgQCcT/f0NAQMc3AKF1dXWSxWAyrLx3uhPSPf/xD9Xmfz0eXL1+m8+fPx/xefvLJJ8lsWmaQQDebzSYREfMjEAhoOo7f748q29fXp6utfX190uDgYNzXNDY2cn09qXjY7faY7Xe73dz1+/1+TT8Dm80mSZIktbe3S263W6qvr0/Kzx7U4QyLweLFi8nr9TKXV1vCkizxlsaYhXKuFAutPxOv16v7rNHhcNCLL75IRI8Ww6fy5282CCwGytnOovviiy8muwkJpaIL7fF46J///Gfo4+rqat111NfX04oVK4jo0QUFMBYCi8GdO3cmuwmGevXVV5l3GWhrawu9sZVXPm02W8SZaHd3d1IG1kdGRrjrGB0dpfb29tAiZq3kaRkrVqxI66ubZoF5WAz+9re/cZUXcSZ3LKdPnw79f/PmzRGfe+yxx8jhcIQ+jjVgzauqqookSVJ9KK/MNTc3q75u9uzZVFxcrOl4brc7VK6qqgrzrVIIgcXg+vXrMd8g7e3tEa9Ve4OYZQxjeHg4YpFvaWlp1GvksRsiouPHj6ekXeFOnjyp+bXyPlnNzc3kdrspEAiQJElRuzHIXT4WPBs6AgILOJw/fz70f5vNpjrAv2TJktD/u7q6UroguL+/X9fFkbKyMpIkiX7+859TVVVV6A/LwoULI173+eef625LR0cHNTU1UX5+ftrM4hcRAmsSdXR0JGVpTkNDQ0raf+DAgdD/f/nLX6q+Zv78+RGLgt9///2kt0vW29sb83M+n49aW1s11aPcoeH69esJy4yOjlJbWxs1NTWRxWKhysrK0PhY+MA+6IPAmkR61qnpwdNl0aqjoyNigF2tOygL33X1lVdeSWq7wqkdq7e3lxoaGqioqIicTqemdZbf+c53Ij6ONcgv7xdvsVgoPz+fqqurVQfxw89MQR9cJTSh8G5Yspw9ezb0f7vdHne+V3l5eej/Xq+XOjo6aM2aNUltn8fjUe0OKjfWa2xspPfeey9uXcp5Xp2dnaHnBgYGdF9Z3L9/P/Z+Z4QzrBRra2sL7a752WefGV6/3W7n3lUzEY/HE7H8ZPfu3XFfH74HOlFk2CWL8uKHrL6+PuLjrq4uzV1D2YkTJ0I3tNASVo2NjeR2u6m7uzt04QUYpWhGfcZob2+PWIpRX18ftYRDXt7R19cXc0mIVg6HI+J4LpfLiC8jLrvdHnO5Sfjz4ctplEtY9C4x0kNtSZP8aG5uVl3KIy9f8vv9ktvtltxud9T3VsvDZrOFymMZjvEQWAZTBpbaI966OD3U3piJ1g3yUr7Zm5ubIz4f6+tUC/JkcblcEW1QtjcQCEQ9b7fbmdaINjY2Sm63W+ru7o5oQyAQSGooZyoElgHkv6haf+FjBdbg4KDqL3+84yYjCGPx+/1RX6PyDDFWewKBQFTZ9vb2pLQx/BixAlbLH5ZEQRWPfFy3223415jJEFg6yV0G1h0OXC5X1C9x+BmBljeDTHmWkOw3h7KLpDy7kqTYgSVJktTc3BzVfTK62xR+DLvdLvX19cVsc3g31e12S4ODgzG7eWptj0UZmg6HA2dbBkFgMdDTdXA4HJLb7Y47VqV8o8R7M8i6u7ujjpXMMRNlqNpsNtWvKV5gqQWC1nDWQlm/2+2OG1h9fX1SfX19xPdN/tkqf26BQCCq7bG632pjXzabLend9UyAwGKgZw8ktbMQLXUm+ousfL3W47BQC8dYZ3PxAkut3fJZpxGUQeH3++MGlpp43VRl/WrfA2Wwa/15gjaY1sBAOW1Avmwtqawl1Gr9+vURH3d2dsZ8rXJaARHRli1bmI6biM/no5dffjniOYfDwbx1Sm1tbdRzTqdT9Q46erS2tkbMsaqvr2dakBxvflj4ukiiyIXfRI+mrIRviSxrb2/PiH3JUmKyE1NE8jQFtb+wysFcPWc+yjEptS6X2hWuZJ1dqQ2yx+oKysJfG+sigHI8SH6wdg/VzgDlCxd6z7DiUevSyt+LWIP4ybiwkMkQWAbjCaxEUwYkSftYEi+/3x8VjOFBEIuWwFILXfnhcDh0jfUMDg5GhWr4cY0MLElS7xYqj4GwSh4ElsF4AkvtjRz+5lV7YyTjyqBaCJDGsSYtgSUfQ+1Nrvfr8vv9cceWjA4s5c83VvAirJIDgWUwnsBSKy+/6dW6Zw6Hw/D29/X1qYaV1u6a1sCSJPWunPLsUUtwhX9vlFMljA4stflkes9CgR0Cy2C8gSVJ0d2OxsZG1UvlRl8mj3X3GT3BqCewJEnbBE45uOJN25DDTxlwRgeWJMX+PtlsNlwNTDIElsGMCKxE3SWju4KBQCDmVA2Hw6FrfpfewJKkxGdaWruljY2NUW1NdpdQazfQiHWjgGkNaWn+/Pnkcrlift7lchl2RxaPx0OLFy9Wvfmnw+Egl8uV9C2dy8rKqK+vL2KjPzUOhyNij3ilX//610lrq8/no4aGBqqsrIz5mldeeSXmfv2fffYZLV++XNP+WxAbAitNxXtjGnEfvtHRUWpqaqLy8nLVfaNSFVaykpISunDhQsyvO9XtkQ0PD9O+ffuoqKgo4d2xu7q6yOl0qobWyMgIeb1eKi8vp6amJurv709Wk81tsk/xzMaoLmGsq0/yw+FwcA/uBgIB1TlReruB4cLrYV2MrWyT3W5n7k6xdgkHBwdjzheTH93d3apji2rfv3hb2oB2CCyD8QaW3tuuaxmQ1tNmnrCSJGMCS5IejWvJV+N4BrL1BJa8sD3RPlj19fWhAI01X83hcESErJ7F0xAbAstgrIHV3t4e86zK5XJJg4ODCd9IWhZaxyLP3uddQG1UYEnSozDgnc8UL7C6u7t17bxhs9lU2xNr3prNZpO6u7tVp0IYueg7kyCwDKR2tS1eYAUCgbj7aMm/8OH0nIHJu2umcvdLIwPLCInOsLQuZJc3/tN6nEQP7JPFBoHFQcscIuUbRO52JHqjhHc7lGKNPcU7M0jVJXXRAkuS1LeDCT8T0vq9izXpVu2BKQ5sEFicEnUn5HlD4WMyiR5au0F+v19TcKVy5rWIgaW2iqC5uZkpVLRcMEnm9tBmh8DiFO+GB0SRA8axBmi1djtikbuWWs7wkkm5yV06DCwrAytWWMiD7UZ11eL9IcHVQd/ua00AAAEnSURBVHYILAPE6lKozcqO9dfcqF/i9vb20FlfMrYgjkctvCdbKm9+oSR3/8PXOWLpDp/J/40ygfAtX+RB7njkK4LJHgxP9ZsjHQMr1TfqgOSySBLu6ggAYsDSHAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAgsAhIHAAgBhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAgsAhIHAAgBhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGEgsABAGAgsABAGAgsAhIHAAgBhILAAQBgILAAQBgILAISBwAIAYSCwAEAYCCwAEAYCCwCEgcACAGH8Pxr4AJHefOdSAAAAAElFTkSuQmCC"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Uint8List bytes = base64.decode(imgString);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Image.memory(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      bytes,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="二、Icon-Widget"><a href="#二、Icon-Widget" class="headerlink" title="二、Icon Widget"></a>二、Icon Widget</h4><p><code>Icon</code> 为一个图标 Widget ，是一个无状态组件，不可交互。Flutter 默认所有的 <code>Icon</code> Widget 都为正方形，如果使用其他形状可能会出错。 其构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Icon(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IconData类型必传参数，为要显示的图标，可以为null，为null将显示指定大小的空白区域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.icon, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选命名参数，绘制图标的大小，单位为像素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.size,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选命名参数，绘制图标时使用的颜色，默认为黑色  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，图标的语义标签  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型可选命名参数，图标绘制的方向  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>



<h5 id="1-系统的-Icon"><a href="#1-系统的-Icon" class="headerlink" title="1. 系统的 Icon"></a>1. 系统的 Icon</h5><p>Flutter 为开发者提供了很多 Icon ，可以通过 <code>Icons.图标名称</code> 直接使用，方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Icon(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      Icons.ac_unit,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      color: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      size: <span class="number">24.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>更多 Icon ，可以参考官方。 <a href="https://api.flutter.dev/flutter/material/Icons-class.html#constants" target="_blank" rel="noopener">https://api.flutter.dev/flutter/material/Icons-class.html#constants</a></p>
<h5 id="2-自定义的-Icon"><a href="#2-自定义的-Icon" class="headerlink" title="2. 自定义的 Icon"></a>2. 自定义的 Icon</h5><p>在 <code>Icon</code> 的构造函数中，必传参数 <code>icon</code> 为 <code>IconData</code> 类型，其构造方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> IconData(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型必传参数，图标字体中存储该图标的Unicode代码点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.codePoint, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可命名选参数，字体名称  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontFamily,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选命名参数，包含字体的包的名称  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontPackage,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型可选命名参数，图标绘制方法是否与环境中的文本绘制方向相同  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.matchTextDirection = <span class="keyword">false</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>可以通过创建 <code>IconData</code> 的实例来自定义 <code>Icon</code> 。首先要准备素材，可以到阿里图标库下载，<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a> 。这里随便下载一个为例。选择一个图标加入购物车，在购物车中选择下载代码。下载后内容如下图：</p>
<p><img src="/content/f0eb3e6d/2020361109.jpg" alt="2020361109"></p>
<p>在项目工程根目录新建 fonts 文件夹，并将 iconfont.ttf 文件加入到文件夹中，将文件重新命名为 my_shoes.ttf 。打开工程的 <code>pubspec.yaml</code> 配置文件，找到如下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fonts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   - family: Schyler</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#     fonts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#       - asset: fonts/Schyler-Regular.ttf</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#       - asset: fonts/Schyler-Italic.ttf</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#         style: italic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   - family: Trajan Pro</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#     fonts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#       - asset: fonts/TrajanPro.ttf</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#       - asset: fonts/TrajanPro_Bold.ttf</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#         weight: 700</span></span></pre></td></tr></table></figure>

<p>修改如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fonts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="bullet">-</span> <span class="attr">family:</span> <span class="string">MyCustomFont</span>  </span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="attr">fonts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="bullet">-</span> <span class="attr">asset:</span> <span class="string">fonts/my_shoes.ttf</span></span></pre></td></tr></table></figure>

<p>关于 family 对应的名字可以自定义，如果有确定的不会与其他混淆可以直接使用提供的，如果内有可以自己定义字体名字，这里我们自定义为 MyCustomFont 。</p>
<p>然后打开下载的文件中的名字为 demo_index.html (使用浏览器打开即可)。如下图：</p>
<p><img src="/content/f0eb3e6d/2020361135.jpg" alt="2020361135"></p>
<p><code>&amp;#xe70c</code> ，<code>&amp;#x</code> 是字符引用，后面接的是十六进制数字，我们要获取的就是<code>&amp;#x</code> 后面的数字。</p>
<p>实现代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> IconData iData = <span class="keyword">const</span> IconData(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">0xe70c</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fontFamily: <span class="string">"MyCustomFont"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">400</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">600</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Icon(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      iData,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      color: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      size: <span class="number">50.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实现效果如下：</p>
<p><img src="/content/f0eb3e6d/2020361139.jpg" alt="2020361139"></p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(二)</title>
    <url>/content/8e181e46.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>在 Flutter 开发中，开发者几乎都在与 Widget 打交道。Flutter 本身为开发者提供了很多内置的 Widget，开发者也可以自定义自己的 Widget，下面就开始对 Flutter 内置的 Widget 做一些基础的说明。以下的介绍中尽量使所有的示例代码直接可以运行，所以我们将上一篇文章中的默认代码( <code>main.dart</code> 中的)全部删除，然后重新添加 <code>main</code> 函数如下：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(app);  <span class="comment">//将在 Widget 说明的过程中，替换app</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="二、Text-Widget"><a href="#二、Text-Widget" class="headerlink" title="二、Text Widget"></a>二、Text Widget</h4><p>Flutter 中提供了两种显示文本的 Widget ，<code>Text</code> 和 <code>RichText</code> 。实际上，<code>Text</code> 内部就是使用 <code>RichText</code> 实现的，<code>Text</code> 的 <code>build</code> 方法返回的是 <code>RichText</code> 的实例。<code>Text</code> 与 <code>RichText</code> 的区别在于 <code>Text</code> 使用最接近封闭 <code>DefaultTextStyle</code> 对象的样式，<code>RichText</code> 需要显式样式。这里先讲解 <code>Text</code> ，<code>RichText</code> 将在稍后讲解。</p>
<p>文本 Widget 用于显示单一样式的文本字符串，可以显示单行文本，也可以显示多行文本。</p>
<p>其继承关系如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Text &lt; StatelessWidget &lt; Widget &lt; DiagnosticableTree &lt; Diagnosticable &lt; <span class="built_in">Object</span></span></pre></td></tr></table></figure>

<p>可见其为无状态 Widget，它有两个构造方法，第一个是 <code>Text()</code> ，第二个是 <code>Text.rich()</code> 。</p>
<h5 id="1-Text-构造方法"><a href="#1-Text-构造方法" class="headerlink" title="1. Text() 构造方法"></a>1. Text() 构造方法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型必传参数，为要显示的文本字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.data, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//以下为可选命名参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选参数，用于设置文本的样式  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//StrutStyle类型可选参数，用于设置文本支撑样式  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.strutStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextAlign类型可选参数，用于设置文本水平方向如何对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textAlign,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDirection类型参数，用于设置文本的显示方向(从左到右或从右到左)  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Locale类型参数，用于设置多语言，可以根据不同的区域设置以不同的方式呈现相同的 Unicode 字符。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.locale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//bool类型参数，用于设置文本是否自动换行，如果为 `true` ，自动换行显示，`false` 则不换行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在一行显示，超出屏幕部分不显示。默认为 `true`   </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.softWrap,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextOverflow类型参数，用于设置文本溢出时如何显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.overflow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型参数，用于设置文本的缩放倍数  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textScaleFactor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//int类型参数，用于设置最大显示行数，如果超出限制则会根据 overflow 设置的溢出样式显示   </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型参数，于设置显示文本的替代语义标签 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticsLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextWidthBasis类型参数 ，用于设置如何测量渲染文本的宽度  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textWidthBasis,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Text</code> 是一个比较特殊的组件，特殊在于其 <code>textDirection</code> 属性，它是一个命名可选参数，但是却是需要必须提供的参数，如果在应用的 Widget 树环境中其他的父级 Widget 有可以确定环境方向性，<code>Text</code> 便会默认使用环境中的方向，如果没有方向性的设置，则要在 <code>Text()</code> 构造函数中显式设置，否则会抛出异常，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Text cText = Text(<span class="string">"Hello world!"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(cText);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>因为创建的 <code>Text</code> 实例为一个单独的 Widget ，并且直接使用 <code>runApp()</code> 运行，所以此 <code>Text</code> 便是此程序 Widget 树的根，并没有父级 Widget，也就无法使用其他 Widget 的方向性，且没有提供方向属性， 会抛出如下异常：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">════════ Exception caught by widgets <span class="keyword">library</span> ═══════════════════════════════════════════════════════</span></pre></td></tr><tr><td class="code"><pre><span class="line">The following assertion was thrown building Text(<span class="string">"Hello world!"</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">No Directionality widget found.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">RichText widgets require a Directionality widget ancestor.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">The specific widget that could <span class="keyword">not</span> find a Directionality ancestor was: RichText</span></pre></td></tr><tr><td class="code"><pre><span class="line">  softWrap: wrapping at box width</span></pre></td></tr><tr><td class="code"><pre><span class="line">  maxLines: unlimited</span></pre></td></tr><tr><td class="code"><pre><span class="line">  text: <span class="string">"Hello world!"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  dirty</span></pre></td></tr><tr><td class="code"><pre><span class="line">The ownership chain <span class="keyword">for</span> the affected widget is: <span class="string">"RichText ← Text ← [root]"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Typically, the Directionality widget is introduced by the MaterialApp <span class="keyword">or</span> WidgetsApp widget at the top of your application widget tree. It determines the ambient reading direction <span class="keyword">and</span> is used, <span class="keyword">for</span> example, to determine how to lay out text, how to interpret <span class="string">"start"</span> <span class="keyword">and</span> <span class="string">"end"</span> values, <span class="keyword">and</span> to resolve EdgeInsetsDirectional, AlignmentDirectional, <span class="keyword">and</span> other *Directional objects.</span></pre></td></tr></table></figure>

<p>正确的使用方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Text cText = Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"Hello world!"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    textDirection: TextDirection.ltr,   <span class="comment">//设置方向 从左往右</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(cText);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>TextDirection</code> 为枚举类型，值为 <code>ltr</code>  或 <code>rtl</code> ，意思是从左到右 或 从右到左。</p>
<p>上述代码是为了让大家看的明白如果进行创建对象，可以对其进行代码简化，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"Hello world!"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    textDirection: TextDirection.ltr,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行结果如下图：</p>
<p><img src="/content/8e181e46/2020229344.jpg" alt="2020229344"></p>
<p>因为没有导航等布局组件，所以直接加载的 Widget 从左上角开始布局。为了使创建的程序看起来更像一个应用，对代码做如下更改：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          title: Text(<span class="string">"Widget基础"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        body: studyWidget(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Widget studyWidget() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"Hello world!"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里自定义了一个 Widget 为 MyApp，它是继承自 <code>StatelessWidget</code> 的无状态组件，前面文章对 <code>StatelessWidget</code> 做过说明。重写了抽象方法 <code>build</code> ，并返回了一个 <code>MaterialApp</code> Widget ，在这里，大家要知道 <code>MaterialApp</code> 是在创建 Material 设计风格的移动应用程序中，作为 Widget 树的根使用。<code>home</code> 属性用来设置应用启动后要显示的首页 Widget 。<code>Scaffold</code> 为脚手架 Widget ，在这里用来设置应用程序的顶部导航和主体显示内容。其中，<code>body</code> 接收一个 Widget 参数，我们通过创建返回一个 Widget 的函数进行了设置。对于 <code>MaterialApp</code> 和 <code>Scaffold</code> 都还有各自的其他很多功能，后续文章会做详细说明。在这里只是使应用看起来更美观而使用。我们把 <code>Text</code> Widget 放在了函数 <code>studyWidget()</code> 中。在更改后的代码中，我们在创建 <code>Text</code> 的时候并没有指定方向，因为使用了 <code>MaterialApp</code> ，它默认有方向性的设置为 LTR ，从上面抛出的异常提示中也有说明。</p>
<p>执行效果如下：</p>
<p><img src="/content/8e181e46/202022857.jpg" alt="202022857"></p>
<h5 id="2-Text-rich-构造方法"><a href="#2-Text-rich-构造方法" class="headerlink" title="2. Text.rich() 构造方法"></a>2. Text.rich() 构造方法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text.rich(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InlineSpan类型必传参数，应使用TextSpan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textSpan, &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//...省略可选参数，可选参数与上述Text()相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>InlineSpan</code> 是一个抽象类，其有三个直接或间接子类，分别为：<code>TextSpan</code> 、<code>PlaceholderSpan</code> 、<code>WidgetSpan</code> ，其中 <code>WidgetSpan</code> 继承自 <code>PlaceholderSpan</code> 。</p>
<p><strong>TextSpan</strong></p>
<p>表示一个不变的文本范围，构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextSpan(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选参数，为要显示的文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.text,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;InlineSpan&gt;类型可选参数，子Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.children,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型可选参数，文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextStyle style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//GestureRecognizer类型可选参数，手势识别器，用于接收手势事件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.recognizer,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选参数，用于定义替代的语义标签</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.semanticsLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Text.rich(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TextSpan(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      text: <span class="string">"Hooray! "</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      style: TextStyle(color: Colors.black, fontSize: <span class="number">24</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也可以定义多个范围的文本，使用 <code>children</code> 属性设置，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextSpan cSpan1 = TextSpan(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    text: <span class="string">"Hooray! "</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    style: TextStyle(color: Colors.black, fontSize: <span class="number">24</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextSpan cSpan2 = TextSpan(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    text: <span class="string">"It's snowing! It's time to make a snowman.James runs out."</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    style: TextStyle(color: Colors.green, fontSize: <span class="number">18</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextSpan cSpan3 = TextSpan(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    text: <span class="string">"He adds a scarf and a hat."</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    style: TextStyle(color: Colors.blue, fontSize: <span class="number">30</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Text.rich(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TextSpan(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      children: [cSpan1, cSpan2, cSpan3],</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行效果：</p>
<p><img src="/content/8e181e46/202022948.jpg" alt="202022948"></p>
<p><strong>PlaceholderSpan</strong> </p>
<p><code>PlaceholderSpan</code> 也是一个抽象类，不能直接被实例化，必须对此类进行扩展才能使用。作用是作为嵌入在文本中不可变的占位符。可使用其子类 <code>WidgetSpan</code> 。</p>
<p><strong>WidgetSpan</strong></p>
<p><code>WidgetSpan</code> 用于嵌入在文本中不可变的 Widget 。 构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WidgetSpan(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Widget类型必传参数，为内嵌在文本的中的Widget</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.child,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//PlaceholderAlignment类型参数，用于设置内嵌的Widget与文本数据如何对齐，默认基线对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ui.PlaceholderAlignment alignment = ui.PlaceholderAlignment.bottom,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextBaseline类型参数，用于在设置alignment参数时的基线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextBaseline baseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextStyle类型参数，设置文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  TextStyle style,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Text.rich(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TextSpan(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      children: &lt;InlineSpan&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TextSpan(text: <span class="string">"开始"</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        WidgetSpan(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          child: Text(<span class="string">"HHHHHH"</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TextSpan(text: <span class="string">"结束"</span>,),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>child</code> 属性可以设置任何占位 Widget 。</p>
<h5 id="3-TextStyle"><a href="#3-TextStyle" class="headerlink" title="3. TextStyle"></a>3. TextStyle</h5><p><code>TextStyle</code> 是文本中的属性，用于设置文本样式，其构造函数如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextStyle(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//是否将空值替换为父级Widget文本样式中的值，也就是子Widget在没有定义样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//的情况下是否继承父级Widget中的文本样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.inherit = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型对象，用于设置文本字体颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型对象，用于设置文本背景色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.backgroundColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选参数，字体大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontSize,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FontWeight类型参数，粗体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontWeight,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//FontStyle类型参数，设置字体样式，如斜体等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选参数，设置字母间距(空格)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.letterSpacing,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选参数，设置单词之间的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.wordSpacing,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextBaseline类型可选参数，用于设置不同范围文本间的对齐基线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textBaseline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选参数，设置文本跨度的高度。当height为null或省略时，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//行高将直接由字体的度量标准确定，这可能与fontSize不同。当height</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//为非空时，文本范围的行高将是fontSize的倍数，并且正好是fontSize * height逻辑像素高</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.height,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Locale类型可选参数，多语言</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.locale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Paint类型可选参数，绘制文本的前景样式，比如描边文字等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.foreground,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Paint类型可选参数，绘制文本的背景样式，可以设置填充，描边，画笔宽度等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.background,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;ui.Shadow&gt;类型可选参数，用于在文字下方绘制阴影</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.shadows,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//List&lt;FontFeature&gt;类型可选参数，用于设置影响显示字体样式的列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.fontFeatures,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDecoration类型可选参数，用于设置文字附近的装饰，例如下划线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decoration,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//Color类型可选参数，用于设置文字装饰的颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decorationColor,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//TextDecorationStyle类型参数，用于设置文字装饰的样式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decorationStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//double类型可选参数，设置文字装饰的笔触的粗细诚意字体定义的粗细</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.decorationThickness,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选参数，文本风格调式，调试版本可用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.debugLabel,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选参数，用于设置绘制文本时使用的字体名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> fontFamily,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//list&lt;String&gt;类型可选参数，当在较高优先级的字体系列中找不到字形时，字体系列的有序列表将重新出现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; fontFamilyFallback,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//String类型可选参数，要使用包中定义的字体系列，必须提供package参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> package,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>下面对上面的样式做个例子如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"Hooray! It's snowing! It's time to make a snowman.James runs out. He makes a big pile of snow. He puts a big snowball on top. He adds a scarf and a hat"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontSize: <span class="number">16</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxLines: <span class="number">2</span>,   <span class="comment">//最多显示2行文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        overflow: TextOverflow.ellipsis, <span class="comment">//超出部分以...表示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        textScaleFactor: <span class="number">1.2</span>,  <span class="comment">//字体放大1.2倍</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(         <span class="comment">//设置字体颜色和背景颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"Text Color And backgroundColor"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          color: Colors.yellow,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundColor: Color(<span class="number">0xFF00FF00</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(       <span class="comment">//设置字体大小 粗体 斜体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"Font Size And FontWeight"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontSize: <span class="number">30.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontWeight: FontWeight.bold,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontStyle: FontStyle.italic,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(       <span class="comment">//设置字母和单词直接的间距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"hello world! 这是一句中文!"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          letterSpacing: <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          wordSpacing: <span class="number">10.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"文本的height跨越高度"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          height: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontSize: <span class="number">30</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          backgroundColor: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"文本前景"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          foreground: Paint()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ..color = Colors.blue</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ..strokeWidth = <span class="number">1.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            ..style = PaintingStyle.stroke</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontSize: <span class="number">40</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"文本背景"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          background: Paint()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ..color = Colors.blue</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ..strokeWidth = <span class="number">1.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            ..style = PaintingStyle.stroke</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontSize: <span class="number">40</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"文本的阴影"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontSize: <span class="number">30</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          shadows: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Shadow(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              color: Colors.cyan,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              offset: Offset(<span class="number">2</span>, <span class="number">2</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">              blurRadius: <span class="number">2</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"文本装饰，这是文本装饰样式"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fontSize: <span class="number">30</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          decoration: TextDecoration.underline,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          decorationColor: Colors.purpleAccent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          decorationStyle: TextDecorationStyle.dashed,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行效果如下：</p>
<p><img src="/content/8e181e46/2020341127.jpg" alt="2020341127"></p>
<p>上面用到了纵向布局的 <code>Column</code> ，它的 <code>children</code> 属性可以接收多个子 Widget ，并且纵向排列，这里只是用一下，后续会详细介绍。</p>
<h4 id="三、RichText"><a href="#三、RichText" class="headerlink" title="三、RichText"></a>三、RichText</h4><p><code>RichText</code> 是 Flutter 中的富文本，没有提供必传参数，但是在可选命名参数中，<code>InlineSpan</code> 类型的 <code>text</code> 使用 <code>@required</code> 关键字修饰了，<code>@required</code> 修饰的属性也是必传属性，否则会报警告。其他可选参数在 <code>Text</code> 中也存在，功能相同，部分属性提供了默认值。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RichText(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Key key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//InlineSpan类型必传参数，使用 TextSpan 进行设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@required</span> <span class="keyword">this</span>.text,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textAlign = TextAlign.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textDirection,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.softWrap = <span class="keyword">true</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.overflow = TextOverflow.clip,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textScaleFactor = <span class="number">1.0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.maxLines,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.locale,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.strutStyle,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span>.textWidthBasis = TextWidthBasis.parent,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>上述属性在 <code>Text</code> 中有作说明，这里不再赘述，可以参考以上同名参数。使用方式也与 <code>Text.rich()</code> 相同。</p>
<h4 id="四、其他说明"><a href="#四、其他说明" class="headerlink" title="四、其他说明"></a>四、其他说明</h4><h5 id="1-TextAlgin"><a href="#1-TextAlgin" class="headerlink" title="1. TextAlgin"></a>1. TextAlgin</h5><p>在对文本对齐进行设置中，需要使用 <code>TextAlign</code> ，它是一个枚举类型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> TextAlign &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在容器的左侧对齐文本，与ltr或rtl无关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  left,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在容器的右侧对齐文本，与ltr或rtl无关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  right,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在容器的中心对齐文本，与ltr或rtl无关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//以自动换行的当前行文本自动拉伸以填充容器宽度，对于没有换行的文本，进行边缘对齐。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  justify,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在容器的尾部对齐。对于ltr的文本，在容器的左侧对齐，对于rtl的文本在容器右侧对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//在容器的前端对齐。对于ltr的文本，在容器的右侧对齐，对于rtl的文本在容器的左侧对齐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  end,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>设置方式如下代码:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget studyWidget(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> textString = <span class="string">"Hooray! It's snowing! It's time to make a snowman.James runs out. He makes a big pile of snow. He puts a big snowball on top. He adds a scarf and a hat"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> Container(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    child: Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      textString,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      textAlign: TextAlign.start,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      style: TextStyle(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fontSize: <span class="number">24</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      textDirection: TextDirection.ltr,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    width: <span class="number">300</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    height: <span class="number">200</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    color: Colors.red,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  );</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Container</code> 是容器组件，后续会讲解。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之组件基础(一)</title>
    <url>/content/21298524.html</url>
    <content><![CDATA[<h4 id="一、从-main-函数开始"><a href="#一、从-main-函数开始" class="headerlink" title="一、从 main 函数开始"></a>一、从 main 函数开始</h4><p>在前面的文章中，我们了解了 Dart 的基础语法部分，而 Flutter 就是 Dart 语言的移动应用框架。Flutter 应用程序使用 Dart 语言编写代码，而 Dart 语言中函数的执行入口就是 <code>main</code> 函数。而通过上一篇文章我们创建的默认 Flutter 工程我们知道，在 lib 文件夹下有一个名为 <code>main.dart</code> 的文件，在此文件中就有一个 <code>main</code> 函数的存在，如下：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span></pre></td></tr></table></figure>

<p>也可以写为如下形式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  runApp(MyApp());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这个函数只有一行代码，执行了一个 <code>runApp()</code> 函数，Mac 系统，可以按住 <code>command</code> 键点击鼠标左键，可以进入函数的定义查看该函数，函数有一个类型为 <code>Widget</code> 的参数，<code>Widget</code> 可以理解为 “小部件” 的意思，以下统称 <code>Widget</code> 。在 Flutter 中，<code>runApp()</code> 函数就是应用的入口函数，调用此函数传入 <code>Widget</code> 参数才能正常执行一个应用程序，否则只是一个控制台程序，所有的 Flutter 项目都从 <code>runApp()</code> 函数开始执行。此函数的原型为 <code>void runApp(Widget app)</code> ，这个函数会将给定 <code>Widget</code> 作为 <code>Widget</code> 树的根节点。如果是布局 <code>Widget</code> ，将会填充整个屏幕。</p>
<p>通过 <code>main</code> 函数我们知道，运行一个 Flutter 应用程序，只需要在 <code>runApp()</code> 函数中传入一个 <code>Widget</code> 即可。那么 <code>Widget</code> 又表示什么？ </p>
<h4 id="二、Widgets"><a href="#二、Widgets" class="headerlink" title="二、Widgets"></a>二、Widgets</h4><p><code>Widget</code> 是用于在 Flutter 中构建用户界面的可重用的构建基块，是一个 Dart 类。在 Flutter 中，几乎所有东西都是 <code>Widget</code> ，从界面布局到图像、图标、文本等都是 <code>Widget</code> ，包括从界面看到的和看不到的。Flutter 应用程序中的 <code>Widget</code> 以树状层次结构分布，称为 “小部件树”。  <code>Widget</code> 类中所有的字段都是最终字段( <code>final</code> 修饰 )，通过构造函数进行设置。</p>
<p>在我们创建的默认工程的 <code>runApp()</code> 函数中，传入的是名为 <code>MyApp</code> 的 <code>Widget</code> ，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// This widget is the root of your application.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MaterialApp(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      title: <span class="string">'Flutter Demo'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      theme: ThemeData(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        primarySwatch: Colors.blue,</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      home: MyHomePage(title: <span class="string">'Flutter Demo Home Page'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到 <code>MyApp</code> 是一个继承自 <code>StatelessWidget</code> 的类，类中重写了父类的 <code>build</code> 方法，<code>build</code> 方法接收一个 <code>BuildContext</code> 类型参数，返回值为一个 <code>Widget</code> 类型。点击进入 <code>StatelessWidget</code> 类定义可以看到其为一个抽象类，前面基础部分说过，对于继承的抽象类，需要实现其中的全部抽象方法，在 <code>StatelessWidget</code> 抽象类中，<code>build</code> 方法的声明为：<code>Widget build(BuildContext context);</code> 是一个抽象方法，所以继承自 <code>StatelessWidget</code> 的类必须实现 <code>build</code> 方法。<code>Widget build(BuildContext context)</code> 方法用来实现定义的 <code>Widget</code> 的用户界面部分，当创建的 <code>Widget</code> 添加到现有的小部件树，并且此小部件的依赖项发生变化时会调用此方法。现在只要知道，对于创建的继承自 <code>StatelessWidget</code> 类，需要实现重写<code>build</code> 方法，要创建的界面部分在 <code>build</code> 中实现即可。</p>
<p>在 <code>build</code> 方法中，返回了一个 <code>MaterialApp</code> 类型的 <code>Widget</code> ，而 <code>MaterialApp</code> 的定义在 <code>src/material/app.dart</code> 中，所以在 <code>main.dart</code> 的第一行便是包的导入代码 <code>import &#39;package:flutter/material.dart&#39;;</code> ，这个包是 Flutter 实现 Material Design 设计风格的基础包，里面包含了布局，文本，图片等小部件。Material Design 为谷歌推出的一套视觉设计语言，开发中一般使用此包即可。说白了，<code>MaterialApp</code> 也是一个类，代码中对其属性进行了设置，其中 <code>home</code> 属性，使用到了下面代码定义的类 <code>MyHomePage</code> , 继续看默认工程的下两个函数，如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  MyHomePage(&#123;Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _counter++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Scaffold(</span></pre></td></tr><tr><td class="code"><pre><span class="line">      appBar: AppBar(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        title: Text(widget.title),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      body: Center(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Column(</span></pre></td></tr><tr><td class="code"><pre><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          children: &lt;Widget&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="string">'You have pushed the button this many times:'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Text(</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="string">'<span class="subst">$_counter</span>'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              style: Theme.of(context).textTheme.display1,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      floatingActionButton: FloatingActionButton(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        onPressed: _incrementCounter,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tooltip: <span class="string">'Increment'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child: Icon(Icons.add),</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ), <span class="comment">// This trailing comma makes auto-formatting nicer for build methods.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    );</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>MyHomePage</code> 类继承自 <code>StatefulWidget</code> ，其中重写了 <code>createState()</code> 方法，它也是一个抽象方法，为必须实现的方法，声明为：<code>State createState();</code> 。在上述代码中，<code>createState()</code> 方法调用了 <code>_MyHomePageState()</code> 构造方法，该构造方法的类定义也在上述代码中，<code>_MyHomePageState</code> 类为一个包内可见类，继承自 <code>State</code> 。而 <code>State</code> 也是一个抽象类，其中也有一个未实现的 <code>Widget build(BuildContext context);</code> 方法，所以 <code>_MyHomePageState</code> 类需要实现 <code>build</code> 方法，我们知道 <code>build</code> 主要用来实现用户界面，这里主要用来实现点击按钮，按钮有一个回调函数为 <code>_incrementCounter</code> ， 点击按钮时调用此方法并执行 <code>setState</code> 方法实现 <code>_counter++</code> 。其中 <code>setState()</code> 方法用来实现通知框架触发更新操作。</p>
<h4 id="三、StatelessWidget-与-StatefulWidget"><a href="#三、StatelessWidget-与-StatefulWidget" class="headerlink" title="三、StatelessWidget 与 StatefulWidget"></a>三、StatelessWidget 与 StatefulWidget</h4><p>通过上面的默认工程的例子可以看到，创建的小部件类继承自两个类： <code>StatelessWidget</code> 和 <code>StatefulWidget</code> 。在 Flutter 中，<code>StatelessWidget</code> 称为无状态 Widget，<code>StatefulWidget</code> 称为有状态 Widget，在开发中，自定义的小部件99%的情况都会继承自这两个中的一种。因为对于开发者来说，创建的都是小部件，所以创建 Widget 的过程首先就是继承自系统提供的 Widget 来实现自己的功能，从这两个类的名字便可以看出，他们都是 Widget 。那么什么是有状态和无状态？首先来看下这两个类的继承关系：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StatelessWidget &lt; Widget &lt; DiagnosticableTree &lt; Diagnosticable &lt; <span class="built_in">Object</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">StatefulWidget  &lt; Widget &lt; DiagnosticableTree &lt; Diagnosticable &lt; <span class="built_in">Object</span></span></pre></td></tr></table></figure>

<p>从上述的继承链可以看出，他们有着同样的继承关系，他们的父类都是 <code>Widget</code> 。而上面也说过，<code>Widget</code> 类中的字段都是最终字段(使用 <code>final</code> 修饰)，为何如此？先来看下 <code>Widget</code> 的定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">Initializes [key] for subclasses.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> Key key;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Element</span> createElement();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">A short, textual description of this widget.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> toStringShort() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="string">'<span class="subst">$runtimeType</span>'</span> : <span class="string">'<span class="subst">$runtimeType</span>-<span class="subst">$key</span>'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可见，<code>Widget</code> 是一个抽象类，并且使用了 <code>@immutable</code> 注解做了注释，<code>@immutable</code> 的作用是表示此标注标注的类和其子类的类型必须为不可变的(不可变的意思就是该类的所有实例字段，无论是直接定义还是继承的，都是最终字段，则该类不可变)，而且 <code>Widget</code> 类的构造函数也是常量构造函数(关于常量构造函数的使用规则可以查看 Dart 基础部分文章)，所以继承自 <code>Widget</code> 的类中的实例属性也必须为不可变的。这也就是上面说的无状态，无状态指的就是 <code>Widget</code> 中的内容定义以后不可以改变。既然如此，我们会发现，无论是 <code>StatelessWidget</code> 或者 <code>StatefulWidget</code> 都是继承自 <code>Widget</code> ，那么也就意味着，他们的实例属性也都是不可变的。既然如此，又如何有有状态与无状态之分呢？再来看下 <code>StatelessWidget</code> 与 <code>StatefulWidget</code> 的源码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatelessWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">Initializes [key] for subclasses.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> StatelessWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  StatelessElement createElement() =&gt; StatelessElement(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">/// <span class="markdown">Initializes [key] for subclasses.</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  StatefulElement createElement() =&gt; StatefulElement(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State createState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这两个类的源码都比较简单，这里我们只需要关注这两个类中的最后一个方法，即使用 <code>@protected</code> 注解注释的方法。<code>@protected</code> 也就是受保护的意思，指示被标注的方法只能在其子类中访问，其他类不可访问。在 <code>StatelessWidget</code> 类中，方法为 <code>Widget build(BuildContext context);</code> ，为继承类必须实现的方法，方法返回的是 <code>Widget</code> ，也就是要直接实现定义的 Widget ，即用户界面，所以继承自 <code>StatelessWidget</code> 类中的实例属性一旦定义便无法进行更改。而 <code>StatefulWidget</code> 类中的方法为 <code>State createState();</code> ，它并非直接返回一个 <code>Widget</code> ，而是返回一个状态 <code>State</code> 类型。以下为 <code>State</code> 类的定义：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@optionalTypeArgs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>&gt; <span class="keyword">extends</span> <span class="title">Diagnosticable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  T <span class="keyword">get</span> widget =&gt; _widget;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  T _widget;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  _StateLifecycle _debugLifecycleState = _StateLifecycle.created;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> _debugTypesAreRight(Widget widget) =&gt; widget <span class="keyword">is</span> T;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BuildContext <span class="keyword">get</span> context =&gt; _element;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  StatefulElement _element;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> mounted =&gt; _element != <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@mustCallSuper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> initState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(_debugLifecycleState == _StateLifecycle.created);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@mustCallSuper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> didUpdateWidget(<span class="keyword">covariant</span> T oldWidget) &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@mustCallSuper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> reassemble() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> setState(VoidCallback fn) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(fn != <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.defunct) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorSummary(<span class="string">'setState() called after dispose(): <span class="subst">$this</span>'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorDescription(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'This error happens if you call setState() on a State object for a widget that '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'no longer appears in the widget tree (e.g., whose parent widget no longer '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'includes the widget in its build). This error can occur when code calls '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'setState() from a timer or an animation callback.'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorHint(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'The preferred solution is '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'to cancel the timer or stop listening to the animation in the dispose() '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'callback. Another solution is to check the "mounted" property of this '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'object before calling setState() to ensure the object is still in the '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'tree.'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorHint(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'This error might indicate a memory leak if setState() is being called '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'because another object is retaining a reference to this State object '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'after it has been removed from the tree. To avoid memory leaks, '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'consider breaking the reference to this object during dispose().'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.created &amp;&amp; !mounted) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorSummary(<span class="string">'setState() called in constructor: <span class="subst">$this</span>'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorHint(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'This happens when you call setState() on a State object for a widget that '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'hasn\'t been inserted into the widget tree yet. It is not necessary to call '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'setState() in the constructor, since the state is already assumed to be dirty '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'when it is initially created.'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (result <span class="keyword">is</span> Future) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorSummary(<span class="string">'setState() callback argument returned a Future.'</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorDescription(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'The setState() method on <span class="subst">$this</span> was called with a closure or method that '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'returned a Future. Maybe it is marked as "async".'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ErrorHint(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'Instead of performing asynchronous work inside a call to setState(), first '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">'execute the work (without updating the widget state), and then synchronously '</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="string">'update the state inside a call to setState().'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          ),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// We ignore other types of return values so that you can do things like:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//   setState(() =&gt; x = 3);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _element.markNeedsBuild();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@mustCallSuper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> deactivate() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@mustCallSuper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> dispose() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(_debugLifecycleState == _StateLifecycle.ready);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _debugLifecycleState = _StateLifecycle.defunct;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@protected</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@mustCallSuper</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">assert</span>(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      properties.add(EnumProperty&lt;_StateLifecycle&gt;(<span class="string">'lifecycle state'</span>, _debugLifecycleState, defaultValue: _StateLifecycle.ready));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    properties.add(ObjectFlagProperty&lt;T&gt;(<span class="string">'_widget'</span>, _widget, ifNull: <span class="string">'no widget'</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    properties.add(ObjectFlagProperty&lt;StatefulElement&gt;(<span class="string">'_element'</span>, _element, ifNull: <span class="string">'not mounted'</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>这个类的代码比较多，但并不复杂，可以发现 <code>State</code> 为一个抽象类，我们知道抽象类不能直接被实例化，所以需要开发者自定义一个类来继承 <code>State</code> 类，类中也只有一个抽象方法，是我们熟知的 <code>Widget build(BuildContext context);</code> ，所以开发者只需要定义一个类并继承 <code>State</code> 类，实现 <code>build</code> 方法，然后在 <code>createState()</code> 方法中实例化自定义类即可。类似如下方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyState</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//省略代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> widget;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后在自定义的 Widget 中通过 <code>createState()</code> 方法调用即可，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MyState();   <span class="comment">//构造返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>一般情况下，如此定义即可，但是我们发现在 <code>State</code> 类定义中，有一个泛型的约束条件 <code>&lt;T extends StatefulWidget&gt;</code> , 在类中也有一个 <code>widget</code> 实例属性 ，其具体类型是由约束条件限定的，也就是传递的是哪个 <code>Widget</code> ，类中就会是对应的 <code>Widget</code> ，且这个 <code>Widget</code> 必须是继承自 <code>StatefulWidget</code> 的。当我们不设置此泛型参数时，在通过 <code>createState()</code> 参数调用自定义的类 <code>MyState</code> 后，Flutter 会自动将 <code>MyCustomWidget</code> 与 <code>MyState</code> 做关联，也就是说此时 <code>MyState</code> 类中的 <code>widget</code> 就是 <code>MyCustomWidget</code> 的实例。但是如果在<code>MyCustomWidget</code> 中有属性需要在 <code>MyState</code> 中调用时，就需要显式指明是哪个 Widget ，否则无法在对应的 <code>State</code> 类中调用属性。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name = <span class="string">"custom"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> MyState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyCustomWidget</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  MyState() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    widget.name;   <span class="comment">//如不指明具体Widget类型，无法调用属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Widget build(BuildContext context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//省略代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> widget;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>说到这里，大家应该发现，虽然继承自 <code>StatelessWidget</code> 和 <code>StatefulWidget</code> 的类中必须使用 <code>final</code> 修饰实例属性，但是继承自 <code>StatefulWidget</code> 的类中 <code>createState()</code> 方法返回的 <code>State</code> 类却并非要定义成 <code>final</code> 实例属性。所以如果有需要变换的量可以在自定义的继承自 <code>State</code> 的类中实现。</p>
<p>在默认工程的例子中，实现点击数量增加是通过 <code>_counter</code> 属性实现的，可以发现在点击的回调方法中，实现如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setState(() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  _counter++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>setState()</code> 用来在 Widget 状态发生变化时通知框架，以实现界面数据的更新，如果不调用此方法，界面数据不会更新。所以当 <code>State</code> 对象内部状态发生改变时，应在 <code>setState()</code> 内进行更改操作。</p>
<p>摘录以上例子，并非要对源码做分析，而是说明有状态 Widget 与 无状态 Widget 的区别。可见，当要实现有状态 Widget 时，需要实现两个类，一个继承自 <code>StatefulWidget</code> 和一个继承自 <code>State</code> ，他们是互相关联的。</p>
<p>根据官方文档的说明，使用 <code>StatelessWidget</code> 的情况如下：</p>
<ol>
<li>当 Widget 第一次被插入到小部件树时；</li>
<li>小部件的父类更改其配置时；</li>
<li><code>InheritedWidget</code> 依赖于改动时。</li>
</ol>
<p>总结就是：<code>StatelessWidget</code> 用于在特定配置和环境状态下始终以相同的方式构建 Widget ，也就是定义后数据不做改动时。<code>StatefulWidget</code> 在其生命周期内可以多次构建的 Widget 。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础工程创建及结构介绍</title>
    <url>/content/6f88633a.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>关于 Flutter SDK的下载及安装、环境配置等这里不做说明，有需要的朋友可以在网上找或直接在 Flutter 的官网查看即可，说的都很详细明白。从本章起，将介绍 Flutter 的基础组件知识，对每个部件做详细的使用说明，从 <code>main</code> 入口函数开始讲解，在学习的过程中理解如何使用。以后代码所使用的开发工具为 Android Studio ，模拟器使用的是 Iphone 模拟器，操作系统为 Mac 。</p>
<a id="more"></a>

<h4 id="二、-Flutter-项目创建及工程目录结构"><a href="#二、-Flutter-项目创建及工程目录结构" class="headerlink" title="二、 Flutter 项目创建及工程目录结构"></a>二、 Flutter 项目创建及工程目录结构</h4><p>当开发环境配置好以后，可以通过在命令行(终端)中输入 <code>flutter --version</code> 命令查看 Flutter 版本，正常显示则 Flutter SDK 环境配置完成。可以使用 <code>flutter doctor</code> 命令查看开发环境是否配置完成，此命令会检查当前设备上安装的可用开发工具是否完成了对 Flutter 开发的配置支持。配置完成输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Flutter (Channel stable, v1<span class="variable">.12</span><span class="variable">.13</span>+hotfix<span class="variable">.8</span>, on Mac OS X <span class="number">10</span><span class="variable">.15</span><span class="variable">.3</span> <span class="number">19</span>D76, locale zh-Hans-CN)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">29</span><span class="variable">.0</span><span class="variable">.3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Xcode - develop <span class="keyword">for</span> iOS <span class="keyword">and</span> macOS (Xcode <span class="number">11</span><span class="variable">.3</span><span class="variable">.1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Android Studio (version <span class="number">3</span><span class="variable">.5</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] VS Code (version <span class="number">1</span><span class="variable">.42</span><span class="variable">.1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Connected device (<span class="number">1</span> available)</span></pre></td></tr></table></figure>

<p>然后可以通过两种方式创建 Flutter 项目：命令行方式创建和开发工具创建。</p>
<h5 id="1-命令行方式创建"><a href="#1-命令行方式创建" class="headerlink" title="1. 命令行方式创建"></a>1. 命令行方式创建</h5><p>首先 <code>cd</code> 到项目需要创建的位置，比如桌面的 <code>project</code> 文件夹，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> desktop/project</span></pre></td></tr></table></figure>

<p>使用 <code>flutter create 项目名称</code> 创建项目。其中项目名称可以使用英文、数字、下划线，英文必须全部为小写，如有多个英文单词组成，可以使用下划线分隔，不可以以数字开头，不可使用单纯的 Dart 保留字。 正确使用如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter create study_flutter_demo</span></pre></td></tr></table></figure>

<p>成功创建工程最后会有如下输出：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">All done!</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Flutter: is fully installed. (Channel stable, v1<span class="variable">.12</span><span class="variable">.13</span>+hotfix<span class="variable">.8</span>, on Mac OS X <span class="number">10</span><span class="variable">.15</span><span class="variable">.3</span> <span class="number">19</span>D76, locale zh-Hans-CN)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Android toolchain - develop <span class="keyword">for</span> Android devices: is fully installed. (Android SDK version <span class="number">29</span><span class="variable">.0</span><span class="variable">.3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Xcode - develop <span class="keyword">for</span> iOS <span class="keyword">and</span> macOS: is fully installed. (Xcode <span class="number">11</span><span class="variable">.3</span><span class="variable">.1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Android Studio: is fully installed. (version <span class="number">3</span><span class="variable">.5</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] VS Code: is fully installed. (version <span class="number">1</span><span class="variable">.42</span><span class="variable">.1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[✓] Connected device: is fully installed. (<span class="number">1</span> available)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">In order to run your application, <span class="keyword">type</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  $ cd study_flutter_demo</span></pre></td></tr><tr><td class="code"><pre><span class="line">  $ flutter run</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Your application code is in study_flutter_demo/lib/main<span class="variable">.dart</span>.</span></pre></td></tr></table></figure>

<p>根据提示，可以 <code>cd</code> 到项目文件夹，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd study_flutter_demo</span></pre></td></tr></table></figure>

<p>使用 <code>flutter run</code> 命令运行工程。在使用此命令运行工程时，设备中应有连接的真机或打开的模拟器，可以使用 <code>flutter devices</code> 命令查看当前可用的运行设备，当没有可用运行设备时，输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">No devices detected.</span></pre></td></tr></table></figure>

<p>可以通过数据线连接真机设备，也可以通过如下命令打开 ios 模拟器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -a Simulator</span></pre></td></tr></table></figure>

<p>Android 模拟器及真机等配置可以在官网查看：<a href="https://flutter.dev/docs/get-started/install/macos#install-android-studio" target="_blank" rel="noopener">https://flutter.dev/docs/get-started/install/macos#install-android-studio</a> 。ios 真机运行需要配置开发者证书，可以在官网查看具体步骤，这里只对模拟器测试进行说明。</p>
<p>当有多个移动设备(包括真机和模拟器)处于可用状态时，使用 <code>flutter run</code> 命令会提示需要指定设备，有如下提示输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">More than one device connected; please specify a device with the '-d &lt;deviceId&gt;' flag, or use '-d all' to act on all devices.</span></pre></td></tr></table></figure>

<p>在此输出下面会列出可用的设备信息(设备名称，设备id，系统，版本)，此时可以使用如下命令指定运行设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter run -d 设备id</span></pre></td></tr></table></figure>

<p>也使用使用 <code>flutter run -d all</code> 命令在所有可用设备上同时运行。以下以ios模拟器运行为例，成功运行后有如下输出：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Launching lib/main<span class="variable">.dart</span> on iPhone <span class="number">11</span> in debug mode...</span></pre></td></tr><tr><td class="code"><pre><span class="line">Running Xcode build...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> ├─Assembling Flutter resources...                           <span class="number">2</span><span class="variable">.8s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> └─Compiling, linking <span class="keyword">and</span> signing...                         <span class="number">6</span><span class="variable">.6s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Xcode build done.                                           <span class="number">11</span><span class="variable">.9s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Syncing files to device iPhone <span class="number">11</span>...</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="number">5</span>,<span class="number">788</span>ms (!)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">🔥  To hot reload changes <span class="keyword">while</span> running, press <span class="string">"r"</span>. To hot restart (<span class="keyword">and</span> rebuild state), press <span class="string">"R"</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line">An Observatory debugger <span class="keyword">and</span> profiler on iPhone <span class="number">11</span> is available at: http:<span class="comment">//127.0.0.1:61603/oHZEjqUKaf0=/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">For a more detailed help message, press <span class="string">"h"</span>. To detach, press <span class="string">"d"</span>; to quit, press <span class="string">"q"</span>.</span></pre></td></tr></table></figure>

<p>根据提示，可以使用小写 “r” 键进行热重载，大写 “R” 进行热重启。可以根据提示的网址在浏览器中打开，查看调试器和分析信息。 “q” 键退出。</p>
<p>通过命令行创建的工程成功创建后，可以通过 Android Studio 开发工具的 “Open an existing Android Studio project” 选项打开即可进行代表编辑，或将工程文件夹直接拖动到相对应的开发工具即可打开。</p>
<h5 id="2-开发工具创建"><a href="#2-开发工具创建" class="headerlink" title="2. 开发工具创建"></a>2. 开发工具创建</h5><p>Android Studio 开发工具安装并配置好后，打开界面如下，选择 “Start a new Flutter project” :</p>
<p><img src="/content/6f88633a/2020226810.png" alt="2020226810"></p>
<p>选择创建 “Flutter Application” ，点击 “Next”：</p>
<p><img src="/content/6f88633a/2020226813.jpg" alt="2020226813"></p>
<p>然后填写项目名称，选择存放路径，Flutter SDK选项在Flutter SDK环境变量配置好的情况下自动填写，如下图：</p>
<p><img src="/content/6f88633a/2020226826.jpg" alt="2020226826"></p>
<p>设置公司反向域名和勾选是否支持 Kotlin 和 Swift 语言，如原生开发用到勾选即可，如下图：</p>
<p><img src="/content/6f88633a/2020226855.jpg" alt="2020226855"></p>
<p>最后点击 “Finish” 即可完成工程创建。运行结果如下图：</p>
<img src="/content/6f88633a/2020226910.jpg" alt="截屏2020-02-26下午9.07.25" style="zoom: 33%;">



<h5 id="3-工程目录结构"><a href="#3-工程目录结构" class="headerlink" title="3. 工程目录结构"></a>3. 工程目录结构</h5><p>新建的工程目录如下图：</p>
<p><img src="/content/6f88633a/2020226915.png" alt="2020226915"></p>
<p>其中，开发 Flutter 工程代码主要关心的文件为：lib文件夹和 pubspec.yaml 配置文件。</p>
<p>lib文件夹：工程代码文件夹，里面有一个 main.dart 文件，为工程的入口文件，默认创建的工程包含了默认的demo代码。我们自己创建的代码文件也存放在lib文件夹中。</p>
<p>pubspec.yaml：工程的配置文件，用来管理第三方依赖和静态资源配置。</p>
<p>android 文件夹：Flutter 工程在 Android 平台运行的相关代码。</p>
<p>ios 文件夹：Flutter 工程在 ios 平台运行的相关代码。</p>
<p>build 文件夹：编译后的 Android 或 iOS 包。</p>
<p>test 文件夹：存放测试代码。</p>
<p>以点 <code>.</code> 开头的文件或文件夹为隐藏文件夹，以下是隐藏文件的说明：</p>
<p>.idea 文件夹：存储了 Android Studio 的配置信息，因为 Android Studio 是基于 Intelli IDEA IDEA 开发，因此有名为这个的文件夹，可以忽略此文件夹。</p>
<p>.gitignore：里面说明了Git版本控制要忽略的文件。</p>
<p>.metadata：Android Studio 用来跟踪当前项目的数据，可以忽略。</p>
<p>.packages：Flutter 带有包管理器，用于管理项目中的依赖项，此文件用于跟踪项目中的依赖关系，可以忽略。</p>
<p>pubspec.lock：Pub内部使用的文件，与pubspec.yaml 相同，不能编辑此文件，忽略即可。</p>
<p>study_flutter_demo.iml：Android Studio 的项目配置文件，可以忽略。</p>
<p>README.md：自述文件。</p>
<p>有兴趣的可以参考官方文档：<a href="https://dart.dev/guides/libraries/private-files" target="_blank" rel="noopener">https://dart.dev/guides/libraries/private-files</a> 。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之Dart语言基础(四)</title>
    <url>/content/dc3f0782.html</url>
    <content><![CDATA[<h4 id="一、运算符重载"><a href="#一、运算符重载" class="headerlink" title="一、运算符重载"></a>一、运算符重载</h4><p>Dart 支持运算符重载，使用 <code>operator</code> 关键字，语法格式为：<code>operator 运算符</code> ，如下，重载加法运算符：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Vector v1 = Vector(<span class="number">1</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Vector v2 = Vector(<span class="number">2</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Vector v3 = v1    + v2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;v3.x&#125;</span> <span class="subst">$&#123;v3.y&#125;</span>"</span>);   <span class="comment">//输出 3 5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Vector(x+v.x, y+v.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="一、模块的使用"><a href="#一、模块的使用" class="headerlink" title="一、模块的使用"></a>一、模块的使用</h4><p>有点规模的工程一般都会有很多个文件和模块组成，甚至简单的程序也不会是单个文件组成的。在 Dart 中，每一个 <code>.dart</code> 文件就是一个模块，称为库。可以将不同的功能分装在不同的库中，以便在不同的文件中使用同一库的功能函数，减少代码量，可以使用 <code>import</code> 关键字进行文件导入。</p>
<p>在 Dart 中，库(模块)类型分为三种：自定义库、系统库(Dart 提供的库文件)、第三方库。</p>
<h5 id="1-引入自定义库"><a href="#1-引入自定义库" class="headerlink" title="1. 引入自定义库"></a>1. 引入自定义库</h5><p>引入自定义库(自己创建的 <code>.dart</code> 文件)的方式如下，如在当前文件夹新建一个 common 文件夹为公共类文件夹，在文件夹中新建 <code>common.dart</code> 文件，内容如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> description()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"描述内容"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 <code>main</code> 方法所在文件引入 <code>common.dart</code> 文件并使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'common/common.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  description();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过 <code>import</code> 导入文件后，即可使用文件中的方法等内容。当然也可以在自定义库内新建其他 <code>class</code> 等。引入的格式为 <code>import &#39;路径/文件名.dart&#39;</code> 。</p>
<h5 id="2-引入系统库"><a href="#2-引入系统库" class="headerlink" title="2. 引入系统库"></a>2. 引入系统库</h5><p>系统库是由 Dart 事先提供的库，包含了一些文件或其他内容的处理方法，如 <code>io</code> 、<code>math</code> 等文件，引入方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">num</span> maxNumber = max(<span class="number">10</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(maxNumber);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>max</code> 为 系统 <code>math</code> 库提供的比较两个数字并返回较大数字的函数，引入库后可直接使用。引入格式为：<code>import &#39;dart:文件名&#39;</code> 。</p>
<h5 id="3-引入第三方库"><a href="#3-引入第三方库" class="headerlink" title="3. 引入第三方库"></a>3. 引入第三方库</h5><p>第三方库为其他开发者或公司等写好的具有一定功能的函数库，可以在 Dart 提供的官方平台寻找需要的库，地址为：<a href="https://pub.dev" target="_blank" rel="noopener">https://pub.dev</a> 。比如我们前面使用过的 <code>meta.dart</code> 文件，可以在网站中直接搜 meta 即可。结果如下图：</p>
<p><img src="/content/dc3f0782/2020224_12_15.png" alt></p>
<p>点击 Installing ，进入安装说明页，如下图：</p>
<p><img src="/content/dc3f0782/2020224_12_15.jpg" alt></p>
<p>本页列出了包的安装方式，可以通过命令行和配置文件方式引入，这里介绍下配置文件引入的方法。对于 Flutter 项目，创建工程后在文件的顶层目录会存在一个名为 <code>pubspec.yaml</code> 的配置文件。在没有此文件的工程中可以手动在顶级目录添加此文件，里面包含一些包的依赖和其他信息，具体可以参考：<a href="https://dart.dev/tools/pub/pubspec" target="_blank" rel="noopener">https://dart.dev/tools/pub/pubspec</a> 。只需将按照上图的步骤1，将包名和对应的版本号添加到 <code>dependencies</code> 即可。编译器会自动下载所需依赖包，开发者只需在工程文件中，通过 <code>package</code> 方式引入即可，如没有自动下载依赖，可以查看官方的具体信息，进入项目所在文件目录，使用 <code>pub get</code>  命令下载即可。 使用如下方式导入:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:meta/meta.dart'</span>;</span></pre></td></tr></table></figure>



<h5 id="4-私有属性"><a href="#4-私有属性" class="headerlink" title="4. 私有属性"></a>4. 私有属性</h5><p>对于私有属性，前面文章简单介绍过。在 Dart 中，没有关键字 <code>public</code> 、<code>protected</code>  、<code>private</code> 。如果标识符以下划线(<code>_</code>)开头，则表示该标识符私有属性，只能在定义标识符的库中使用(定义标识符的当前<code>.dart</code> 文件)。</p>
<h5 id="5-指定库前缀"><a href="#5-指定库前缀" class="headerlink" title="5. 指定库前缀"></a>5. 指定库前缀</h5><p>当引入的不同库中存在相同的类名、方法名或其他相同名称时，有时会出现冲突的问题，在 Dart 中，通过指定一个或多个库前缀的方式解决，使用 <code>as</code> 关键字。如 <code>common.dart</code> 与 <code>common1.dart</code> 中同时存在名为 <code>description</code> 的方法，内容分别如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//common.dart</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> description()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"common的描述内容"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//common1.dart</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> description()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"common1的描述内容"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 <code>main</code> 方法所在文件进行引入：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'common/common.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'common/common1.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// description();  此时调用会抛出两个库文件存在同一方法的异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此时，需要至少指定其中一个库的前缀或部分引入的方式解决问题，使用前缀如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'common/common.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'common/common1.dart'</span> <span class="keyword">as</span> com1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  description();  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  com1.description();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里为 <code>common1.dart</code> 指定了 <code>com1</code> 前缀，调用方法或其他内容时，需要加上前缀进行调用即可。类似于其他语言的命名空间概念。</p>
<h5 id="6-部分引入库"><a href="#6-部分引入库" class="headerlink" title="6. 部分引入库"></a>6. 部分引入库</h5><p>当一个库中包含很多解决问题的方法时，引入库但只会用到其中很少一部分内容或不想用某些方法内容，可以使用 <code>show</code> 或 <code>hide</code> 关键字进行指定。在 <code>common.dart</code> 文件中添加方法 <code>printInfo</code> ，<code>common.dart</code> 内容如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> description()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"common的描述内容"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> printInfo() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"打印指定信息"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 <code>show</code> 关键字指定只导入 <code>printInfo</code> 方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'common/common.dart'</span> <span class="keyword">show</span> printInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// description();    //调用description会抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  printInfo();    <span class="comment">//输出 打印指定信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 <code>hide</code> 关键字指定不导入部分如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'common/common.dart'</span> <span class="keyword">hide</span> printInfo;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  description();   </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// printInfo();  //调用会报未定义错误 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>show</code> 多个可用逗号做分隔。另外，Dart 中还支持惰性加载库，使用关键字 <code>deferred</code> ，但是 Flutter 并不支持延迟，所以不多做介绍，有兴趣的朋友可以自行了解。</p>
<h4 id="二、泛型"><a href="#二、泛型" class="headerlink" title="二、泛型"></a>二、泛型</h4><p>第一篇文章介绍过泛型的基本使用，使用泛型是为了解决类型安全问题以及重复代码的问题。泛型，也就是通用类型，在前面的文章中使用过泛型。例如，当创建一个只能包含字符串的列表(<code>List</code>)时，如不通过泛型执行数据类型，则创建的列表为动态类型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> lst = <span class="built_in">List</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(lst.runtimeType);  <span class="comment">//输出 List&lt;dynamic&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果列表是为了特定的问题而创建的只能包含字符串的类型(可能需要对列表内的数据进行特定的字符串处理)，此时如果数组内添加了非字符串类型数据，调用字符串处理方法就会出现异常，所以需要使用泛型对添加的数据类型做限定，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> lst = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(lst.runtimeType);   <span class="comment">//输出 List&lt;String&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此时如果列表添加其他类型数据就会抛出异常，如法进行添加。</p>
<p>也可以使用泛型来减少重复代码，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student1 = StudentInt(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student2 = StudentString(<span class="string">"hike"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.study();				<span class="comment">//输出 1 号学生在学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student2.study();				<span class="comment">//输出 hike 在学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentInt</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> stuId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  StudentInt(<span class="keyword">this</span>.stuId);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$stuId</span> 号学生在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentString</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  StudentString(<span class="keyword">this</span>.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述代码，分别为通过学号和学生姓名来创建学生，创建了两个类，通过泛型修改如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student1 = Student(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student2 = Student(<span class="string">"hike"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.study();				<span class="comment">//输出 1 号学生在学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student2.study();				<span class="comment">//输出 hike 在学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  T stuIdentifier;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="keyword">this</span>.stuIdentifier);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(stuIdentifier <span class="keyword">is</span> <span class="built_in">num</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"<span class="subst">$stuIdentifier</span> 号学生在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stuIdentifier <span class="keyword">is</span> <span class="built_in">String</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"<span class="subst">$stuIdentifier</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过泛型 <code>&lt;T&gt;</code> 可以有效减少代码的重复量，通过传入不同的参数类型区分不同的执行结果。其中 <code>T</code> 为标识符，为类型占位，类型为传入数据的数据类型，在运行时确定。</p>
<p>泛型的另一个用途是用来约束范围，可以用来用在继承类类型的限制，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = Coach&lt;Student&gt;(<span class="keyword">new</span> Student(<span class="string">"学生 在讲话"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.coachMethod();								<span class="comment">//学生在讲话</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coach</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  T coachData;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Coach(<span class="keyword">this</span>.coachData);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  coachMethod() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    coachData.say();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="built_in">String</span> name) : <span class="keyword">super</span>(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Teacher(name) : <span class="keyword">super</span>(name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> profession;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Person(<span class="keyword">this</span>.profession);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> say()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$profession</span> 在讲话"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里定义了辅导类(<code>Coach</code>)，泛型约束了传入的类必须是继承自 <code>Person</code> 类，<code>main</code> 中的定义方法又约束了具体的类的类型，如果传入其他类进行初始化操作则会报错。</p>
<p>也可以在函数中使用泛型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(lastString([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">T lastString&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; lst) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(lst.length &lt;= <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"长度有误"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> lst.first;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>T lastString&lt;T&gt;(List&lt;T&gt; lst)</code> 中，第一个 <code>T</code> 代表返回值类型，第二个 <code>&lt;T&gt;</code> 表示可以在函数的多个地方使用类型为 <code>T</code> 的参数，如果不加此参数会报错，第三个为列表中的参数类型。</p>
<h4 id="三、异步编程"><a href="#三、异步编程" class="headerlink" title="三、异步编程"></a>三、异步编程</h4><p>在程序设计中，为了不影响用户的使用，都会对耗时的任务做异步处理，以防止对用户界面或功能造成假死、卡顿等现象。在 Dart 中， 使用 <code>async</code> 和 <code>await</code> 来做异步编程，也可以使用 <code>Future</code> API。</p>
<h5 id="1-async-与-await"><a href="#1-async-与-await" class="headerlink" title="1. async 与 await"></a>1. async 与 await</h5><p><code>await</code> 必须在 <code>async</code> 函数中使用。比如，定义如下函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">getNetworkData() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="comment">//  var data = await "获取的网络数据"; //次处代码会报错，await 必须使用在 async 函数中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>对上述代码做如下修改：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  getNetworkData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">getNetworkData() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> <span class="string">"获取的网络数据"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"数据:<span class="subst">$data</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">执行完毕</span></pre></td></tr><tr><td class="code"><pre><span class="line">数据:获取的网络数据</span></pre></td></tr></table></figure>

<p>如果去掉 <code>await</code> 关键字修饰，做如下修改：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  getNetworkData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">getNetworkData() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> data = <span class="string">"获取的网络数据"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"数据:<span class="subst">$data</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">数据:获取的网络数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">执行完毕</span></pre></td></tr></table></figure>

<p>可以发现当去掉 <code>await</code> 修饰后，函数的执行过程即为调用过程，顺序执行(即便在 <code>getNetworkData</code> 中有耗时操作 )。所以 <code>async</code> 与 <code>await</code> 需要一起使用，需要之后执行的处理使用 <code>await</code> 修饰。异步操作，不会等待操作执行完毕，而是继续执行后面的任务。</p>
<p>可以同时使用多个 <code>await</code> ，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">getNetworkData() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> data =  <span class="keyword">await</span> <span class="string">"获取的网络数据"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"数据:<span class="subst">$data</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> proData = <span class="keyword">await</span> <span class="string">"处理数据"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"处理:<span class="subst">$proData</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="2-回调"><a href="#2-回调" class="headerlink" title="2. 回调"></a>2. 回调</h5><p>当从网络获取到数据后，需要对数据进行本地处理后进行UI渲染，Dart 中可以使用回调函数的处理方式处理此问题，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  getNetworkData(renderUI);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">getNetworkData(methodCallBack) <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> data =  <span class="keyword">await</span> <span class="string">"获取的网络数据"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  methodCallBack(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">renderUI(<span class="keyword">var</span> data)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$data</span> 进行UI渲染"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="2-Future-API"><a href="#2-Future-API" class="headerlink" title="2. Future API"></a>2. Future API</h5><p>对于被 <code>async</code> 修饰的异步函数，其返回值类型为 <code>Future</code> ，无论是否显式执行返回值类型。对于没有返回值的异步函数，应使用 <code>Feture&lt;void&gt;</code> 作为返回值类型。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; getNetworkData() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> data =  <span class="keyword">await</span> <span class="string">"获取的网络数据"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"数据:<span class="subst">$data</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 <code>Future</code> 的 <code>then</code> 方式处理函数回调，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> future = getNetworkData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  future.then((data)&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    renderUI(data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">getNetworkData() <span class="keyword">async</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> data =  <span class="keyword">await</span> <span class="string">"获取的网络数据"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">renderUI(<span class="keyword">var</span> data)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$data</span> 进行UI渲染"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>官方建议，如果能使用 <code>await</code> 执行异步操作尽量使用此方式。Future 的 <code>then</code> 方法主要用于当有多个异步任务有依赖关系时使用。</p>
<p>关于更多 Future API的使用，可见官方文档：<a href="https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming" target="_blank" rel="noopener">https://dart.dev/guides/libraries/library-tour#dartasync---asynchronous-programming</a></p>
<h5 id="3-流处理"><a href="#3-流处理" class="headerlink" title="3. 流处理"></a>3. 流处理</h5><p>如果数据以流的方式进行处理，有两种方式，一种是使用 <code>async</code> 和 <code>await for</code> 处理，另外一种是使用 <code>stream</code> API。详细见官方文档：<a href="https://dart.dev/guides/libraries/library-tour#stream" target="_blank" rel="noopener">https://dart.dev/guides/libraries/library-tour#stream</a></p>
<h4 id="四、可调用类"><a href="#四、可调用类" class="headerlink" title="四、可调用类"></a>四、可调用类</h4><p>可调用类的作用是使类的实例可以像函数一样使用，需要在类中实现 <code>call()</code>方法，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> des = student(<span class="string">"hike"</span>, <span class="number">11</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(des);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  call(<span class="built_in">String</span> name, <span class="built_in">int</span> age) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">$age</span> 的学生 <span class="subst">$name</span> 在学习!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="五-Typedefs"><a href="#五-Typedefs" class="headerlink" title="五. Typedefs"></a>五. Typedefs</h4><p>在当前的 Dart 中，可以为函数指定别名(其他类型暂时不可以)，使用 <code>typedef</code> 关键字。Dart 中的此功能是一种函数匹配，就官网的例子来说看似有点鸡肋，看如下例子：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> mAdd = MethodAdd(addFunction);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> result= mAdd.func(<span class="number">1</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(result);     <span class="comment">//输出 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(mAdd.func <span class="keyword">is</span> <span class="built_in">Function</span>);  <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodAdd</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Function</span> func;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  MethodAdd(<span class="keyword">this</span>.func);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">num</span> addFunction(<span class="built_in">num</span> a, <span class="built_in">num</span> b)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>定义一个 <code>Function</code> 类型参数作为类 <code>MethodAdd</code> 的构造函数参数，传入 <code>addFunction</code> 方法做加法运算并得出结果。使用 <code>typedef</code> 定义别名方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Add = <span class="built_in">num</span> <span class="built_in">Function</span>(<span class="built_in">num</span> a, <span class="built_in">num</span> b);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> mAdd = MethodAdd(addFunction);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> result= mAdd.func(<span class="number">1</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(result);   							<span class="comment">//输出 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(mAdd.func <span class="keyword">is</span> <span class="built_in">Function</span>); <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(mAdd.func <span class="keyword">is</span> Add);			<span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodAdd</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Add func;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  MethodAdd(<span class="keyword">this</span>.func);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">num</span> addFunction(<span class="built_in">num</span> a, <span class="built_in">num</span> b)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述代码最终的区别就在于最后对类型的具体判断，未使用 <code>typedef</code> 定义别名时，仅能判断传入的是一个函数，使用别名后，因为定义了具体类型(这里是加法)，可以具体判断到加法，传入其他类型，也是如此，也就是提供了一种类型检查机制。</p>
<h4 id="六、Metadata"><a href="#六、Metadata" class="headerlink" title="六、Metadata"></a>六、Metadata</h4><p>Dart 中，使用元数据来提供有关代码的其他信息。元数据注解使用字符 <code>@</code> 开头，其后是对编译时常量的引用。Dart 中提供的批注有：<code>@deprecated</code> 、<code>@override</code> 、<code>@proxy</code> 。 </p>
<p><code>@override</code> 前面说过，用来指示其标识的代码为重写父类的代码。</p>
<p><code>@deprecated</code> 表示被标识的代码被弃用，应使用其他替代代码，但依然可以执行，直到下次版本更新。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.studyData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"学生吃"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@deprecated</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> studyData() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    study(); <span class="comment">//studyData 将被弃用，使用study方法代替</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"吃"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也可以自定义元数据注解，新建一个名为 <code>customAnnotation.dart</code> 的文件，创建自定义注解并不一定需要单独创建一个文件，这里只是个例子，如一个注解只在本类使用，在类中创建即可(不知道是否有意义，但是这样做是可以的)。如果需要创建一个共享的，在多个列中都使用的注解，则单独创建一个 <code>.dart</code> 文件。我们创建的文件内容如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> studyDescription;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>这是对学习的描述</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">*/</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> StudyDes stuDes = StudyDes();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyDes</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> StudyDes();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这是一个用来描述学习的注解(只是例子，没有任何意义，这是根据官方注解的样子仿写的)。第一行使用 <code>library</code> 指令声明这是一个正式的 Dart 库(无此声明也可以)，名字为 <code>studyDescription</code> 。注释格式为文档注释，创建的注解为 <code>stuDes</code> 。定义注解的类的构造函数必须为常量构造函数，关于常量构造函数的说明上文有过说明。 使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'customAnnotation.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@stuDes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在编译器中，当鼠标放在 <code>import &#39;customAnnotation.dart&#39;;</code> 上静止不动时，会显示 <code>library</code> 定义的正式库的名字，鼠标放在 <code>stuDes</code> 上会提示注解的注释信息。这个注解是无参数的，也可以定义有参数的，与定义类的方式没什么区别，这里不再赘述。</p>
<p>元数据可以出现在库(<code>library</code>)，类(<code>class</code>)，<code>typedef</code>，类型参数(<code>type parameter</code>)，构造函数(<code>constructor</code>)，工厂(<code>factory</code>)，函数(<code>function</code>)，字段(<code>field</code>)，参数(<code>parameter</code>)或变量声明(<code>variable declaration</code>)之前，也可以出现在导入或导出指令之前。您可以在运行时使用反射来检索元数据</p>
<p>至此，Dart 基础语法部分完毕。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之Dart语言基础(三)</title>
    <url>/content/267ce88d.html</url>
    <content><![CDATA[<h4 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h4><p>函数用于将代码结构化，将复杂的问题简单化，实现根据功能拆分程序，使得代码可以实现复用。</p>
<p>Dart 中的入口函数为 <code>main</code> ，无论 <code>main</code> 函数放在哪都会从此开始执行代码。关于 <code>main</code> 函数的结构在第一篇文章中已经做了说明，这里不再赘述。Dart 中一且皆对象，因此，函数也是对象，为 <code>Function</code> 类型对象。</p>
<p>Dart 中提供了很多常用的函数库，通过这些函数能很方便的实现一些通用功能，在开发过程中可以直接使用。但是很多功能还需要开发人员自己实现。</p>
<p>Dart 中函数可以嵌套定义。</p>
<a id="more"></a>

<h5 id="1-自定义基本函数"><a href="#1-自定义基本函数" class="headerlink" title="1. 自定义基本函数"></a>1. 自定义基本函数</h5><p>一个函数的完成格式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">返回值 函数名(参数列表) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	函数体</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>比如定义一个实现两个数相加的函数，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">num</span> addFunction(<span class="built_in">num</span> a, <span class="built_in">num</span> b) &#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中，第一个 <code>num</code> 为返回值类型，<code>addFunction</code> 为函数名，括号内为函数的参数列表，这里是两个 <code>num</code> 类型的 <code>a</code> 和 <code>b</code> 。因为 <code>num</code> 类型是 <code>int</code> 和 <code>double</code> 的父类，所以这个函数可以完成整型和浮点型的相加操作。函数定义好后，需要在 <code>main</code> 函数中调用才会执行，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">num</span> sum = addFunction(<span class="number">10</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(sum);  <span class="comment">//输出 30</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">num</span> addFunction(<span class="built_in">num</span> a, <span class="built_in">num</span> b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用函数并定义一个 <code>num</code> 类型的变量 <code>sum</code> 来接收函数的返回值。调用函数时，传入的参数类型应与函数的参数类型和数量相对应，否则会报错。</p>
<p>前面第一篇文章在介绍 <code>main</code> 函数时就说过，在 Dart 中，函数的返回值类型是可以省略的，其实，参数类型也是可以省略的，Dart 会根据调用时传入的参数类型来自动推断数据类型。而返回值类型，如果函数有返回值则根据返回值类型进行推断，如无返回值，则推断为 <code>Null</code> ，而非 <code>void</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> sum = addFunction(<span class="number">10</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(sum);  <span class="comment">//输出 30</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     </span></pre></td></tr><tr><td class="code"><pre><span class="line">addFunction(a, b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>需要注意的是，如不定义参数类型，需要在函数体内做好边缘处理，防止类型错误而抛出异常。也需要确定传入的参数在函数内是否有意义，如函数处理功能与参数类型无关，或无法处理，则没有任何意义。</p>
<p>Dart 中，如果函数体内只有一个表达式，可以写成如下形式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">num</span> sum = addFunction(<span class="number">10</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(sum);  <span class="comment">//输出 30</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//只有一个表达式，简写成如下形式，参数类型等依然是可以省略的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">addFunction(<span class="built_in">num</span> a, <span class="built_in">num</span> b)=&gt; a + b;</span></pre></td></tr></table></figure>

<p>其中 <code>=&gt; expr</code> 语法为 <code>{return expr;}</code>，此语法可称为箭头语法。</p>
<p>因为 Dart 中函数也是对象(<code>Function</code>)对象，所以可以将函数赋值给变量或作为参数进行传递。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> iSum = addFunction;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">num</span> sum = iSum(<span class="number">10</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     </span></pre></td></tr><tr><td class="code"><pre><span class="line">addFunction(<span class="built_in">num</span> a, <span class="built_in">num</span> b)=&gt; a + b;</span></pre></td></tr></table></figure>

<p>函数类型也可作为参数和返回值类型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> res = printFunction(printInfo);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(res.runtimeType);   <span class="comment">//输出  () =&gt; dynamic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">printInfo() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"这是一个函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span> printFunction(<span class="built_in">Function</span> s) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  s();    <span class="comment">//执行函数 输出 这是一个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="2-可选参数函数"><a href="#2-可选参数函数" class="headerlink" title="2.可选参数函数"></a>2.可选参数函数</h5><p>Dart 中，函数可以具有两种类型的参数：必须参数和可选参数。当两种类型的参数都存在时，应先列出必须参数，然后列出可选参数。可选参数又分为命名参数和位置参数。使用时，可以单独使用命名参数或位置参数，但是两者不能同时在一个函数参数中使用。</p>
<p>前面定义的函数中都为必须参数，在调用函数时必须传递。而可选参数是指，在进行函数调用时，可以传入此参数，也可以不传入此参数。</p>
<p><strong>命名参数</strong></p>
<p>命名参数是在定义函数时，将命名参数放在<code>{}</code>中，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">personInfo(&#123;<span class="built_in">String</span> sex, <span class="built_in">int</span> age&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"性别:<span class="subst">$sex</span> 年龄:<span class="subst">$age</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>调用方式为根据参数名传入参数，格式为：<code>paramName:value</code> ，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo();   <span class="comment">//不传参数 输出 性别:null 年龄:null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(sex:<span class="string">"男"</span>); <span class="comment">//传入性别 输出 性别:男 年龄:null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(age:<span class="number">20</span>);   <span class="comment">//传入年龄 输出 性别:null 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(sex:<span class="string">"男"</span>, age: <span class="number">20</span>); <span class="comment">//传入性别 年龄 输出 性别:男 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(age: <span class="number">20</span>, sex:<span class="string">"男"</span>); <span class="comment">//传入性别 年龄 输出 性别:男 年龄:20 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     </span></pre></td></tr><tr><td class="code"><pre><span class="line">personInfo(&#123;<span class="built_in">String</span> sex, <span class="built_in">int</span> age&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"性别:<span class="subst">$sex</span> 年龄:<span class="subst">$age</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>命名参数是根据指定的参数名称寻找对应的参数，确定其类型，所以传入的顺序可以不定。</p>
<p>虽然命名参数是可选参数，但是也可以强制提供该参数，使用关键字 <code>@required</code> 。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:meta/meta.dart'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(name: <span class="string">"张三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo();   <span class="comment">//此处调用会报警告</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">personInfo(&#123;<span class="built_in">String</span> sex, <span class="built_in">int</span> age, <span class="meta">@required</span> <span class="built_in">String</span> name&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"性别:<span class="subst">$sex</span> 年龄:<span class="subst">$age</span> 姓名:<span class="subst">$name</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用 <code>@required</code> 标注需要导入包 <code>package:meta/meta.dart</code> 。 <code>package</code> 并不是 Dart SDK 默认提供的，需要添加依赖或直接安装到，这在后面会讲到。有兴趣的可以参考：<a href="https://pub.dev/packages/meta#-installing-tab-" target="_blank" rel="noopener">https://pub.dev/packages/meta#-installing-tab-</a></p>
<p>根据官方文档的说明，使用 <code>@required</code> 注释的参数为必须提供的参数，这里也进行了测试，在 VSCode 环境下，<code>.dart</code> 文件运行的情况下，不提供也是可以的，但是会报警告信息，如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">The <span class="keyword">parameter</span> 'name' is required. <span class="variable">.dart</span>(missing_required_param)</span></pre></td></tr></table></figure>

<p>并且当使用 <code>@required</code> 标注以后，在调用函数时，会自动带上所修饰的关键字。</p>
<p><strong>位置参数</strong></p>
<p>位置参数是表示某个位置的参数是可选的，需将参数放在 <code>[]</code> 中，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(<span class="string">"张三"</span>);   <span class="comment">//输出 姓名:张三 性别:null 年龄:null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(<span class="string">"张三"</span>, <span class="keyword">null</span>, <span class="number">20</span>);  <span class="comment">//输出 姓名:张三 性别:男 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(<span class="string">"张三"</span>, <span class="string">"男"</span>, <span class="number">20</span>);  <span class="comment">//输出 姓名:张三 性别:null 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">personInfo(<span class="built_in">String</span> name, [<span class="built_in">String</span> sex, <span class="built_in">int</span> age]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">$name</span> 性别:<span class="subst">$sex</span> 年龄:<span class="subst">$age</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>sex</code> 和 <code>age</code> 为位置可选参数，<code>name</code> 为必须参数。当有多个位置参数时，如果想提供的参数不在位置参数的前面的位置，在 Dart 中并没有提供忽略参数的方法，可以将位置参数的排列顺序做改变或者提供 <code>null</code> 参数，并在函数体内做处理即可。</p>
<h5 id="3-可选参数的默认值"><a href="#3-可选参数的默认值" class="headerlink" title="3. 可选参数的默认值"></a>3. 可选参数的默认值</h5><p>因为在调用函数时，默认参数不是必须提供，所以当调用者未提供指定的可选参数时，Dart 可以为可选参数设置一个默认值，当调用函数时，未提供指定参数，则使用默认值做为指定值。默认值必须是编译时常量，如果不提供默认值，默认值为 <code>null</code> 。</p>
<p><strong>命名参数的默认值</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo();											<span class="comment">//输出 姓名:null 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(name: <span class="string">"张三"</span>);					 <span class="comment">//输出 姓名:张三 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(name: <span class="string">"张三"</span>, age: <span class="number">28</span>); <span class="comment">//输出 姓名:张三 年龄:28</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">personInfo(&#123;<span class="built_in">String</span> name, <span class="built_in">int</span> age = <span class="number">20</span>&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">$name</span> 年龄:<span class="subst">$age</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>位置参数的默认值</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo();    		  	<span class="comment">//输出 姓名:null 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(<span class="string">"张三"</span>);		   <span class="comment">//输出 姓名:张三 年龄:20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  personInfo(<span class="string">"张三"</span>, <span class="number">28</span>);  <span class="comment">//输出 姓名:张三 年龄:28</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">personInfo([<span class="built_in">String</span> name, <span class="built_in">int</span> age = <span class="number">20</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">$name</span> 年龄:<span class="subst">$age</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：也可使用 <code>List</code> , <code>Map</code> , <code>Set</code> 等作为默认值，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">personInfo(&#123;<span class="built_in">List</span> a = <span class="keyword">const</span> [], <span class="built_in">Map</span> b = <span class="keyword">const</span> &#123;&#125;, <span class="built_in">Set</span> c = <span class="keyword">const</span> &#123;&#125;&#125;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">print</span>(<span class="string">"<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4. 匿名函数"></a>4. 匿名函数</h5><p>一般定义函数都是有函数名的，如上面所示的代码，但是并不是所有函数都有名字。Dart 中没有名字的函数称为匿名函数。匿名函数可以直接赋值给变量来通过变量进行函数调用，也可以创建自执行的函数和闭包。匿名函数也可以有参数或无参数。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"匿名无参函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>如上匿名函数如果定义在其他函数体内则相当于将匿名函数赋值给局部变量，定义在全局则相当于赋值给全局变量，如果如下匿名函数未赋值给变量，定义在其他函数体内不会出现问题，但是无法进行调用，定义在全局则会报错：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">print</span>(<span class="string">"匿名函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>但可以创建自执行匿名函数，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"匿名函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;();  <span class="comment">//输出 匿名函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>带参数的自执行匿名函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (<span class="built_in">int</span> a)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"匿名函数 <span class="subst">$a</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;(<span class="number">10</span>);  <span class="comment">//输出 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>当在全局区定义匿名函数并赋值给一个变量时，会报警告，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = ()&#123;      <span class="comment">//()处报警告</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"匿名无参函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//警告内容如下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//The type of the function literal can't be inferred because the literal has a block as its body.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Try adding an explicit type to the variable.dart(top_level_function_literal_block)</span></span></pre></td></tr></table></figure>

<p>警告的意思是无法推断出变量的类型，此时可以做如下修改即可消除警告：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> fun = ()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"匿名无参函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>使用 <code>dynamic</code> 或 <code>Object</code> 修饰变量。正常使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> sum = addFunction(<span class="number">10</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(sum);   <span class="comment">//输出 30</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> addFunction = (<span class="built_in">num</span> a, <span class="built_in">num</span> b) =&gt; a + b;</span></pre></td></tr></table></figure>

<p>在函数体内定义匿名函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">dynamic</span> addFunction = (<span class="built_in">num</span> a, <span class="built_in">num</span> b) =&gt; a + b; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> sum = addFunction(<span class="number">10</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此时，只能在函数体内使用，使用前需要定义，注意顺序。</p>
<h5 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h5><p>闭包也是函数对象，无论变量还是函数等都有其使用范围，也就是作用域，当出了作用域后将无法继续使用对象或函数等。而闭包会对其使用的变量进行拷贝，即使出了其作用域依然可以被函数内部访问。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> fun1 = addFunction(<span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> result = fun1(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(result);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//闭包函数，函数内嵌套函数，并且内部函数作为外部函数的返回值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">addFunction(<span class="built_in">num</span> a) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> b) =&gt; a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述实现了闭包，如果在闭包函数内定义一个变量，相对于函数内部的函数来说，在外层函数定义的变量对于内部函数来说就类似全局的概念，内部函数会对外部变量做一次拷贝，所以对于闭包函数，变量是一直存在的。</p>
<h4 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h4><p>Dart 是一种有类和基于 <code>Mixin</code> 的继承的面向对象的语言，一切皆对象。每个对象都是一个类的实例，所有类都继承自 <code>Object</code> 。Dart 只支持单继承，不支持多重继承，但是可以通过混合 <code>Mixin</code> 实现多重继承的特性。支持扩展方法，扩展方法可以在不更改类或创建子类的情况下向类中添加功能的方法。类中封装了属性和方法，属性用来存储类数据，方法用来描述类行为。</p>
<h5 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1. 定义类"></a>1. 定义类</h5><p>Dart 中使用关键字 <code>class</code> 定义类，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述定义了一个学生类，并在其中定义了姓名和年级属性，姓名和年级属于实例属性(实例变量)，可以在类内部使用，也可以将类实例化出的对象使用点语法来调用，未初始化的实例变量默认值为 <code>null</code>，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.name = <span class="string">"hike"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.grade = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">$&#123;student.name&#125;</span> 班级:<span class="subst">$&#123;student.grade&#125;</span>"</span>);  <span class="comment">//输出 姓名:hike 班级:1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中的 <code>new</code> 关键字是可以省略的。也可以使用级联运算符，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = Student()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ..name = <span class="string">"hike"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ..grade = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">$&#123;student.name&#125;</span> 班级:<span class="subst">$&#123;student.grade&#125;</span>"</span>); <span class="comment">//输出 姓名:hike 班级:1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h5><p>实例方法与上述实例属性一样，在类内定义好的实例方法需要实例化的类来调用，方法就是函数，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.name = <span class="string">"hike"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.grade = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student1 = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.running(<span class="string">"mach"</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"学生的名字为<span class="subst">$&#123;student1.name&#125;</span> <span class="subst">$&#123;student1.grade&#125;</span>年级"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的学生<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> running(<span class="built_in">String</span> name, <span class="built_in">int</span> grade) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.grade = grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>年级的学生<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面在学生类中定义了两个实例方法 <code>study</code> 和 <code>running</code> ，<code>study</code> 为无参数方法，<code>running</code> 为有参方法。在类内定义的方法可以直接使用类内定义的实例属性，但是如果方法的参数名称与类内的属性名称相同，在做赋值操作时，应在属性前通过 <code>this</code> 关键字使用点语法调用，<code>this</code> 代表当前类的实例对象，如方法<code>running</code> 。</p>
<h5 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3. 构造方法"></a>3. 构造方法</h5><p>类在进行实例化时候，会调用类的构造方法，这是大多数编程语言的特性，Dart 中也不列外。Dart 的类在实例化的时候也会调用构造方法，上述的代码都没有进行构造函数的定义，构造函数是一种特殊的函数，如果开发者没有提供构造函数(如上代码，都没有提供构造函数)，编译器会提供默认的构造函数，也就是说无论开发者是否书写构造函数，在类的创建时都会调用构造函数，只是如果没有提供构造函数，则会调用默认的构造函数，默认构造函数也属于常规构造函数。构造函数参数也支持可选参数方式。</p>
<p><strong>常规构造函数</strong></p>
<p>默认构造，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = <span class="keyword">new</span> Student();   <span class="comment">//输出 这是默认的构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"这是默认的构造函数"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的学生<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> running(<span class="built_in">String</span> name, <span class="built_in">int</span> grade) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.grade = grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>年级的学生<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>上述代码，我们只创建了 <code>Student</code> 类的对象，并没有调用任何方法，但是依然会打印函数 <code>Student</code> 中的内容，<code>Student</code> 就是默认的构造函数。构造函数的函数名必须和类名相同，所谓默认的构造函数就是与类名相同的无参函数，创建类的对象时会默认调用此函数。我们也可以改写默认的构造函数，给默认的构造函数添加参数，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.running();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="built_in">String</span> newName, <span class="built_in">int</span> newGrade)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name = newName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grade = newGrade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的学生<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> running() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>年级的学生<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>

<p>上述代码，将默认的构造函数添加了两个参数，分别为：<code>newName</code> 和 <code>newGrade</code> ，其实参数名和属性名可以完全相同，就如前面所写的 <code>running</code> 一样，只不过需要添加 <code>this</code> 关键字，指明所属对象。修改如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Student(<span class="built_in">String</span> name, <span class="built_in">int</span> grade)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">this</span>.grade = grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p>在 Dart 中有一种更为便捷的实现方法，可以完全省略构造函数体内的赋值过程，修改如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Student(<span class="keyword">this</span>.name, <span class="keyword">this</span>.grade);</span></pre></td></tr></table></figure>

<p>如此实现，同样是实现构造函数的赋值过程，提供构造函数的好处，可以在创建对象的时候就提供参数，省去了创建对象的赋值过程，当然也可以在构造函数内或非构造函数内对属性做默认赋值，但是如果不提供构造函数，赋的默认值就无法通过便捷的方式修改，不提供默认值则默认值为 <code>null</code> 。值得注意的是，一旦对默认的构造函数(与类同名无参的函数)做了修改，原本提供的默认构造函数(与类同名无参的函数)便无法继续使用，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// var student =  new Student();   //错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.running();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="keyword">this</span>.name, <span class="keyword">this</span>.grade);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的学生<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> running() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>年级的学生<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Dart 中不支持函数重载，构造函数也是如此。所以如果想创建多个提供不同参数的构造函数便无法实现。但是 Dart 中提供了其他的方式实现同样的功能，就是命名构造函数。</p>
<p><strong>命名构造函数</strong></p>
<p>命名构造函数就是通过为构造函数起一个别名的方式显示构造函数的功能，实现方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student1 = <span class="keyword">new</span> Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.running();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span> studentMap = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"name"</span> : <span class="string">"Mary"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"grade"</span> : <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student2 = <span class="keyword">new</span> Student.fromMap(studentMap);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student2.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student2.running();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student3 = <span class="keyword">new</span> Student.otherStudent(student1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student3.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student3.running();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="keyword">this</span>.name, <span class="keyword">this</span>.grade);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student.fromMap(<span class="built_in">Map</span> studentJson) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name = studentJson[<span class="string">"name"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grade = studentJson[<span class="string">"grade"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student.otherStudent(Student stu)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name = stu.name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grade = stu.grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的学生<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> running() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>年级的学生<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过以上可以看出，命名构造函数格式为 <code>构造函数名.别名(参数列表)</code> 。别名也称作标识符，只要不同就可以了，很简单，其他的语法规则都与以前介绍的相同。</p>
<p><strong>构造函数初始化列表</strong></p>
<p>构造函数的初始化列表用来在构造函数主体执行之前初始化实例变量，初始化列表可以进行赋值操作，也可以使用表达式，对于计算某个值的最终结果很方便。初始化列表使用 <code>:</code> 分隔。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student1 = <span class="keyword">new</span> Student(<span class="string">"hike"</span>, <span class="number">3</span>, <span class="number">89</span>, <span class="number">99.4</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.running();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> score;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> english;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> math;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="keyword">this</span>.name, <span class="keyword">this</span>.grade, english, math): score = english + math &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的<span class="subst">$&#123;name&#125;</span>的英语和数学的总分为:<span class="subst">$score</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的学生<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> running() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>年级的学生<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>代码中新增了总分数 <code>score</code> 、英语分数 <code>english</code> 和数学分数 <code>math</code> ，在构造函数中使用初始化列表在构造函数主体执行之前计算出了总分数。</p>
<p>初始化列表右侧(<code>:</code> 右侧)不能使用 <code>this</code> 关键字。在开发期间，可以在初始列表中加入 <code>assert</code> 来验证输入的正确性。</p>
<p><strong>重定向构造函数</strong></p>
<p>通常，在创建对象的时候会调用一个构造函数(无论是默认构造函数还是自定义的构造函数)，在这过程中，调用哪个构造函数就执行哪个构造函数的函数体(函数内容)。在 Dart 中，可以定义重定向构造函数，定义重定向构造函数的目的在于，当调用重定向构造函数时，会调用重定向函数指定的构造函数方法，以实现某种目的。在定义Dart 中的重定向函数时，重定向函数主题必须为空(不能有函数体)，目标函数放在 <code>:</code> 后面，使用如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student1 = <span class="keyword">new</span> Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student1.running();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student2 = Student.formGradeOne(<span class="string">"Lucy"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student2.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="keyword">this</span>.name, <span class="keyword">this</span>.grade);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//重定向构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student.formGradeOne(<span class="built_in">String</span> name):<span class="keyword">this</span>(name, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>年级的学生<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> running() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;<span class="keyword">this</span>.grade&#125;</span>年级的学生<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述代码定义了重定向构造函数 <code>Student.formGradeOne</code> ，目标构造函数为 <code>Student</code> ，这个重定向构造函数实现了一个定义班级为1的学生，只需要提供学生的姓名就可以直接创建班级为1的学生，这样定义提供了一种便捷的创建方式，实际调用的构造函数为目标构造函数(<code>Student</code>)。</p>
<p>PS：重定向函数的参数名称不用与目标函数的参数名称相同，但类型必须对应。</p>
<p><strong>常量构造函数</strong></p>
<p>如果希望通过同一个类实例化出来的对象为同一对象(对于无参构造函数创建的对象为同一对象，对于有参构造函数，当传入相同的数据时创造出的为同一对象)，就可以使用常量构造函数，Dart 中，使用 <code>const</code> 关键字修饰的构造函数为常量构造函数，在使用常量构造函数的类中，实例属性必须使用 <code>final</code> 修饰，且常量构造函数不能有函数体。非常量构造函数创建对象如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student1 = <span class="keyword">new</span> Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student2 = <span class="keyword">new</span> Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isSame = identical(student1, student2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(isSame);   <span class="comment">//输出 false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="keyword">this</span>.name, <span class="keyword">this</span>.grade);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述为非常量构造函数创建的对象，<code>identical</code> 方法用来检测两个对象是否指向同一对象。虽然参数都相同，且都是同一类的实例化对象，但是他们并不是同一个对象。</p>
<p>使用常量构造函数方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> student1 = Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> student2 = Student(<span class="string">"hike"</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(identical(student1, student2));   <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> Student(<span class="keyword">this</span>.name, <span class="keyword">this</span>.grade);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过常量构造函数实例化的对象，必须使用 <code>const</code> 做修饰，不能使用 <code>new</code> 关键字。</p>
<p><strong>工厂构造函数</strong></p>
<p>Dart 中支持工厂构造函数，工厂构造函数与普通构造函数的区别在于，工厂构造函数使用 <code>factory</code> 关键字修饰，并且有自己的返回值。以上使用的构造函数可以归纳为普通构造函数(默认构造与命名构造)，在普通构造函数内不能有明确返回值，即便返回当前对象类型，其操作是由 Dart 来完成的。而工厂构造需要开发者手动指定返回值类型，可以返回当前对象或其他类型。如不添加任何返回值，则会报警告(VSCode开发环境)。使用工厂构造创建单利的方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> bmwCar1 = <span class="keyword">new</span> BmwCar(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> bmwCar2 = <span class="keyword">new</span> BmwCar(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> isSame = identical(bmwCar1, bmwCar2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(isSame);   				<span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;bmwCar1.carId&#125;</span>  <span class="subst">$&#123;bmwCar2.carId&#125;</span>"</span>);   <span class="comment">//输出 2  2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BmwCar</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> carId;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> BmwCar student;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">factory</span> BmwCar(<span class="built_in">int</span> carId) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span>(student == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     student = <span class="keyword">new</span> BmwCar._fromCarId(carId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="keyword">return</span> student;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  BmwCar._fromCarId(<span class="keyword">this</span>.carId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的代码，无论传入的为何种参数，创建出的新对象都为同一对象。Dart 中下划线(<code>_</code>)开头的变量为私有变量，私有变量只能在定义它们的库中使用(一个 <code>.dart</code> 文件就是一个库文件)，关于此会在后续的关于库的文章中详细介绍。此外，工厂方法也可以从一个缓存返回实例，官方的例子就是如此，可以参考。</p>
<h5 id="4-类属性-静态属性-与-类方法-静态方法"><a href="#4-类属性-静态属性-与-类方法-静态方法" class="headerlink" title="4. 类属性(静态属性) 与 类方法(静态方法)"></a>4. 类属性(静态属性) 与 类方法(静态方法)</h5><p>以上定义的属性和方法都是实例属性和实例方法，即必须通过类实例化以后的对象来进行调用。Dart 中也提供了类属性和类方法，即不用实例化类，直接通过类名就可以直接调用的属性和方法。Dart 中使用 <code>static</code> 来修饰类属性和类方法，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student.name = <span class="string">"hike"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student.grade = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="built_in">int</span> grade;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;grade&#125;</span>班级的<span class="subst">$&#123;name&#125;</span>在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>类属性和类方法直接使用类来调用，不能使用实例化的对象来操作。因为类方法无法通过实例化的对象调用，所以<br>不能在类方法中使用 <code>this</code> 关键字。类属性(静态变量)在使用前不会被初始化。在类方法中无法访问非静态成员，非静态方法中可以访问静态成员。</p>
<p>您可以使用静态方法作为编译时常量。例如，您可以将静态方法作为参数传递给常量构造函数。</p>
<h5 id="5-setters-与-getters"><a href="#5-setters-与-getters" class="headerlink" title="5. setters 与 getters"></a>5. setters 与 getters</h5><p>所有的实例变量都会生成一个隐式的 getter 方法，非最终实例变量也会生成隐式的 setter 方法。getter 方法用来获取属性，setter 方法用来设置属性。当我们使用实例变量通过点运算符调用属性时，调用的就是getter或setter方法。如果一个属性值并非最终变量，就可以通过setter方法来进行定义，在其他语言中，有些也叫计算属性。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.calculate = <span class="number">60</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(student.calculate);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> baseCredit;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//获取总学分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> calculate &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> baseCredit + <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//输入平时得分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">set</span> calculate(<span class="built_in">int</span> value) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    baseCredit = value + <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述例子，设置了一个计算属性 (<code>calculate</code>) ，<code>set</code> 方法用来提供学生平时的表现得分，并在表现分基础上加10分，<code>get</code> 方法用来计算学生的最终得分，为在基础分基础上加20分为学生的最终得分。下面是一个更为直观的例子:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> network = Network();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  network.strURL = <span class="string">"http://www.baidu.com"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(network.strURL);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> _strURL;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> strURL &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> _strURL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> <span class="keyword">set</span> strURL(<span class="built_in">String</span> urlString) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _strURL = urlString;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="6-类的继承"><a href="#6-类的继承" class="headerlink" title="6. 类的继承"></a>6. 类的继承</h5><p>继承是类的重要特性，子类可以通过继承的方式对父类进行扩展和使用父类中定义的属性和方法，也可以对父类中的方法进行重写以实现自己需要的功能。Dart 中使用 <code>extends</code> 关键字实现继承: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.name = <span class="string">"hike"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.age = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.eat();   <span class="comment">//输出  hike 在吃面包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study(); <span class="comment">//输出  hike 在学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基类(父类)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在吃面包"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这里定义了一个基类 <code>Person</code> ，并定义了姓名和年龄属性，还有一个吃的方法，学生也是人类，<code>Person</code> 类定义的属性和方法学生类也同样应该有，所以通过直接继承 <code>Person</code> 类的方式，就可以直接使用 <code>Person</code> 类中的属性和方法，<code>Student</code> 类也有自己的学习方法。有一点值得注意，构造方法是无法继承的，如果父类中存在非默认构造方法，子类在继承时必须使用调用父类构造方法，否则会报错。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student(<span class="string">"hike"</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.eat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//必须实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="built_in">String</span> name, <span class="built_in">int</span> age) : <span class="keyword">super</span>(name, age);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基类(父类)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//非默认构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在吃面包"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Student(String name, int age) : super(name, age);</code> 调用父类构造方法的格式与重定向构造函数格式相同，只是将 <code>this</code> 关键字换成了 <code>super</code> 。 <code>super</code> 除了用在此处之外，主要用于在子类中调用父类的方法，修改 <code>study</code> 方法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">super</span>.eat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>子类除了能调用父类方法外，还可以对父类方法进行重写，如下，重写 <code>eat</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student(<span class="string">"hike"</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.eat();    <span class="comment">//输出 hike 在吃苹果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();  <span class="comment">//输出 hike 在学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//必须实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student(<span class="built_in">String</span> name, <span class="built_in">int</span> age) : <span class="keyword">super</span>(name, age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//重写父类方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在吃苹果"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基类(父类)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//非默认构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在吃面包"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过 <code>@override</code> 标注方法为重写方法，此标注可以省略。此刻，输出的为在吃苹果，而并非父类的吃面包，证明本类已经覆盖了父类的方法实现。如果想在覆盖父类方法的同时，保留父类方法的实现，可以在本类的覆盖实现中通过 <code>super</code> 调用父类的实现，<code>Student</code> 类 <code>eat</code> 方法修改如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> eat() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">super</span>.eat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在吃苹果"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样，父类与子类的实现会同时执行。</p>
<h5 id="7-抽象类-与-抽象方法"><a href="#7-抽象类-与-抽象方法" class="headerlink" title="7. 抽象类 与 抽象方法"></a>7. 抽象类 与 抽象方法</h5><p>抽象类是无法被实例化的类(无法直接通过抽象类创建对象)。抽象类常用于定义通用接口，通用接口用来提供给符合条件的类使用。所谓接口就是抽象类中只定义不实现的方法，这些方法被称为抽象方法。在非抽象类中是不能只定义不实现方法主体功能的。Dart 中使用 <code>abstract</code> 关键字定义抽象类，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">asStudent</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述代码定义了一个抽象学生类，类中定了 <code>study()</code> 和 <code>test()</code> 两个方法，这两个方法就是抽象方法，抽象方法只能在抽象类中定义。类 <code>asStudent</code> 为抽象类。这个类不能直接实例化，只能通过继承或实现接口的方式使用。</p>
<p>接口实现方式通过关键字 <code>implements</code> 实现，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">asStudent</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> test() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"考试"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">asStudent</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也可以同时实现多个接口抽象类，使用 <code>,</code> 分割即可。当一个类实现接口类时，类本身需要重写接口类中的所有声明的方法，否则会报错，实现多个接口，则需要将多个接口中声明的方法全部实现。</p>
<p>通过继承的方式实现，使用关键字 <code>extends</code> ，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">asStudent</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> test() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"考试"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">asStudent</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此方式也同样需要重写父类中所有的方法。</p>
<h5 id="8-Mixin"><a href="#8-Mixin" class="headerlink" title="8. Mixin"></a>8. Mixin</h5><p>Dart 中不支持多重继承，即一个子类只能继承一个父类。如果想要实现多继承的特性，就需要使用 <code>Mixin</code> 的特性，使用关键字 <code>with</code> ，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.name = <span class="string">"hike"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.eat();        <span class="comment">//输出 hike 在吃面包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.drinking();   <span class="comment">//输出 喝水</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();			<span class="comment">//输出 hike 在学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基类(父类)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在吃面包"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> drinking() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"喝水"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>增添了动物类(<code>Animal</code>)，并添加了一个喝水的方法，在 <code>Student</code> 继承的基础上使用 <code>with</code> 关键字后添加需要混合的类名，可以添加多个，使用逗号(<code>,</code>)进行分割，这样就可以使用新增添的类中的方法和属性。</p>
<p>也可以使用如下写法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">resStudent</span> = <span class="title">Student</span> <span class="title">with</span> <span class="title">Animal</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">main</span>()</span>&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  resStudent student = resStudent();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.name = <span class="string">"hike"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.eat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.drinking();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//基类(父类)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> eat()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$name</span> 在吃面包"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> drinking() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"喝水"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>需要注意的是，如果一个可做为 <code>Mixin</code> 类(使用在 <code>with</code> 后)，不能有构造方法，即便重写默认的构造方法也不行。但是在不提供构造方法的前提下，可以创建该类的对象。也就是说虽然 <code>Mixin</code> 类虽然不能有构造函数，但是可以被实例化。如果不想作为 <code>Mixin</code> 类被实例化，可以使用 <code>mixin</code> 关键字替换 <code>class</code> 关键字进行定义，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Animal &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> drinking() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"喝水"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此时在创建 <code>Animal</code> 类的实例则会报错，并且使用 <code>mixin</code> 定义的类也不能被继承(使用 <code>extends</code> 继承)。<code>mixin</code> 定义的类本身可以继承其他类，此时使用 <code>on</code> 关键字继承，如下: </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Description</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> des()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"描述"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">mixin</span> Animal <span class="keyword">on</span> Description &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> drinking() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"喝水"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="9-noSuchMethod"><a href="#9-noSuchMethod" class="headerlink" title="9. noSuchMethod"></a>9. noSuchMethod</h5><p>上面说过，在非抽象类中只声明不实现方法是不被允许的，会报错。当一个抽象类被继承或被实现接口后，也需要实现抽象类中的所有方法，否则也会报错。但是有时候在抽象类中定义的方法并不需要全部实现，此时，可以选择重写 <code>noSuchMethod</code> 方法。重写此方法后，在编译阶段就不会报错。而在运行阶段，如果调用了未实现的方法则会调用此方法，可以在此方法中做一些处理。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Student student = Student();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.study();     <span class="comment">//输出 学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  student.test();  		 <span class="comment">//此行调用将执行 noSuchMethod 方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">asStudent</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"学习"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="meta">@override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  noSuchMethod(Invocation invocation) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"调用了未实现方法:<span class="subst">$&#123;invocation.memberName&#125;</span>"</span>);  <span class="comment">//输出 调用了未实现方法:Symbol("test")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// return super.noSuchMethod(invocation);  //注释掉此行代码，否则依然会抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">asStudent</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> study();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">void</span> test();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之Dart语言基础(二)</title>
    <url>/content/588fc8a6.html</url>
    <content><![CDATA[<h4 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h4><p>Dart 中，支持各种类型运算符，且其中的一些操作符还支持重载操作。</p>
<h5 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1. 算数运算符"></a>1. 算数运算符</h5><p>Dart 中的算数运算符有以下几种：<code>+</code> 、<code>-</code> 、<code>*</code> 、<code>/</code> 、<code>%</code> 、<code>~/</code> ，通过以下示例说明：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="number">21</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a + b;  <span class="comment">//加法操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);   <span class="comment">//输出 31</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a - b;  <span class="comment">//减法操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);   <span class="comment">//输出 11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a * b;  <span class="comment">//乘法操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);   <span class="comment">//输出 210</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a / b;  <span class="comment">//除法操作，两个相除结果为double，即便两个整数相除也为double</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);   <span class="comment">//输出 2.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a % b;  <span class="comment">//取余操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);   <span class="comment">//输出 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a ~/ b; <span class="comment">//取整操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);   <span class="comment">//输出 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(-c);  <span class="comment">//负数操作，输出 -2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Dart 支持自增与自减操作，如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a, b, c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = <span class="number">21</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a++ + b;  <span class="comment">//a参与运算完毕后自增加1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);     <span class="comment">//输出 31</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = <span class="number">21</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = ++a + b;   <span class="comment">//a自增加1后参与运算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);      <span class="comment">//输出 32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = <span class="number">21</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = a-- + b;   <span class="comment">//a参与运算完毕后自减1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);      <span class="comment">//输出 31</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = <span class="number">21</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c = --a + b;   <span class="comment">//a自减1后参与运算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);      <span class="comment">//输出 20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>另外 <code>+</code> 运算符也可用于字符串连接。</p>
<h5 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h5><p>比较运算符有：<code>==</code> 、<code>!=</code> 、<code>&gt;</code> 、<code>&lt;</code> 、<code>&gt;=</code>  、<code>&lt;=</code> 。使用例子如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = <span class="number">30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(a == b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a等于b"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a != b)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a不等于b"</span>);   <span class="comment">//输出 a不等于b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(a &gt; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a大于b"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a小于b"</span>);    <span class="comment">//输出 a小于b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(a &gt;= b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a大于等于b"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt;= b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a小于等于b"</span>);   <span class="comment">//输出 a小于等于b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="3-类型运算符"><a href="#3-类型运算符" class="headerlink" title="3. 类型运算符"></a>3. 类型运算符</h5><p>Dart 中类型运算符有三种：<code>is</code> 、<code>as</code> 、<code>is!</code> ，用于运行时检查类型。</p>
<p><code>is</code> 运算符用来判断数据是否属于某个类型，属于返回 <code>true</code> ，不属于返回 <code>false</code> 。如果<code>ojb</code> 实现了 <code>T</code> 定义的接口，则 <code>obj is T</code> 为 <code>true</code> 。<br><code>is!</code> 运算符用来判断数据是否不属于某个类型，不属于返回 <code>true</code> ， 属于返回 <code>false</code> 。<br><code>as</code> 运算符用来做类型转换，此转换并非真正的转换，而是把原对象当做目标对象使用，不会改变原对象。当使用 <code>as</code> 运算符时，应先确定原对象是否属于目标类型，如果不是目标类型的子类或实例不能使用 <code>as</code> 运算符。<code>as</code> 也可用于做指定库的前缀操作(后续会讲到)。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> str = <span class="string">"this is a string!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(str <span class="keyword">is</span> <span class="built_in">String</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"str 是字符串"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"str 不是字符串"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(a <span class="keyword">is</span>! <span class="built_in">String</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a 不是字符串"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"a 是字符串"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b =(a <span class="keyword">as</span> <span class="built_in">num</span>) + <span class="number">10</span>;  <span class="comment">//如不确定a是否为num的实例或子类，可以使用is操作符做先行判断。如无法转换会抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h5><p>逻辑运算符是针对布尔值进行运算的运算符，包括：<code>!</code> 、<code>||</code> 、<code>&amp;&amp;</code> 。</p>
<p><code>!</code> 逻辑非运算符，其只有一个操作数。当操作数布尔值为 <code>true</code> 时，运算结果为 <code>false</code> ，运算数布尔值为 <code>false</code>，运算结果为 <code>true</code> 。<br><code>||</code> 逻辑或运算符，有两个操作数。当操作数中至少有一个为 <code>true</code> 时，结果为 <code>true</code> ，操作数都为 <code>false</code> ，结果为 <code>false</code> 。<br><code>&amp;&amp;</code> 逻辑与运算符，有两个操作数。当操作数中至少有一个为 <code>false</code> 时，结果为 <code>false</code> ，操作数都为 <code>true</code> ，结果为 <code>true</code> 。 </p>
<p><code>||</code> 和 <code>&amp;&amp;</code> 均为短路运算符。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(!<span class="keyword">true</span>);         <span class="comment">//输出 flase</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(!<span class="keyword">false</span>);        <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">true</span> || <span class="keyword">false</span>); <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">false</span> || <span class="keyword">true</span>); <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">true</span> || <span class="keyword">true</span>);  <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">false</span> || <span class="keyword">false</span>);<span class="comment">//输出 false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">true</span> &amp;&amp; <span class="keyword">false</span>); <span class="comment">//输出 false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">false</span> &amp;&amp; <span class="keyword">true</span>); <span class="comment">//输出 false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">true</span> &amp;&amp; <span class="keyword">true</span>);  <span class="comment">//输出 true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">false</span> &amp;&amp; <span class="keyword">false</span>);<span class="comment">//输出 false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="5-条件运算符"><a href="#5-条件运算符" class="headerlink" title="5. 条件运算符"></a>5. 条件运算符</h5><p>条件运算符包括：<code>?:</code> 、<code>??</code> 或 <code>??=</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = a&gt;b ? a : b;  <span class="comment">//如果a大于b则返回a的值赋给c，否则返回b的值赋给c</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//?? 与 ??= 一样，为空运算符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a ?? <span class="number">100</span>); <span class="comment">//输出 10  如果a为null则将100赋值给a，如果a不为null则使用a的值 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(d ??= <span class="number">200</span>); <span class="comment">//输出200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="6-位运算符"><a href="#6-位运算符" class="headerlink" title="6. 位运算符"></a>6. 位运算符</h5><p>位运算符是针对二进制位进行操作的运算符。包括：<code>&amp;</code> 、<code>|</code> 、<code>^</code> 、<code>~</code> 、<code>&lt;&lt;</code> 、<code>&gt;&gt;</code> 。</p>
<p><code>&amp;</code> 按位与运算符，是将两个操作数的每一个二进制位分别做与运算，对应的两个二进制位都为1则结果为1，否则为0。<br><code>|</code> 按位或运算符，是将两个操作数的每一个二进制位分别做或运算，对应的两个二进制位至少有一个为1则结果为1，否则为0。<br><code>^</code> 按位异或运算符，是将两个操作数的每一个二进制位分别做异或运算，对应的两个二进制位相同(同为1或同为0)则结果为0，否则为1。<br><code>~</code> 按位取反运算符，只有一个操作数，是将操作数的每一个二进制位进行取反操作，即1取反为0，0取反为1。<br><code>&lt;&lt;</code> 按位左移运算符，是将操作数的每一个二进制位向左移动指定的位数。每左移一位相当于原数值乘2。<br><code>&gt;&gt;</code> 按位右移运算符，是将操作数的每一个二进制位向右移动指定的位数。每右移一位相当于原数值除以2。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> a = <span class="number">10</span>;  <span class="comment">//二进制为00001010</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> b = <span class="number">5</span>;   <span class="comment">//二进制为00000101  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a &amp; b);  <span class="comment">//运算后二进制为0000 0000，输出结果为 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a | b);  <span class="comment">//运算后二进制为0000 1111，输出结果为 15 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a ^ b);  <span class="comment">//运算后二进制为0000 1111，输出结果为 15</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(~a);     <span class="comment">//运算后二进制为1111 0101，输出结果为 -11  可以通过-(a+1)公式快速得出结果。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a &lt;&lt; <span class="number">2</span>); <span class="comment">//运算后二进制为0010 1000，输出结果为 40</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b &gt;&gt; <span class="number">2</span>); <span class="comment">//运算后二进制为0000 0001，输出结果为 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="7-复合运算符"><a href="#7-复合运算符" class="headerlink" title="7. 复合运算符"></a>7. 复合运算符</h5><p>复合运算符是多种简单运算的复合，包括：<code>+=</code> 、<code>-=</code> 、<code>*=</code> 、<code>/=</code> 、<code>~/=</code> 、<code>%=</code> 、<code>&lt;&lt;=</code> 、<code>&gt;&gt;=</code> 、<code>&amp;=</code> 、<code>^=</code> 、<code>|=</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> a = <span class="number">10.0</span>;  <span class="comment">//二进制为00001010</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> b = <span class="number">20</span>;   <span class="comment">//二进制为00000101  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a += <span class="number">10</span>);   <span class="comment">//输出(此时的a值) 20，0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a -= <span class="number">10</span>);   <span class="comment">//输出(此时的a值) 10，0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a *= <span class="number">10</span>);   <span class="comment">//输出(此时的a值) 100，0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a /= <span class="number">10</span>);   <span class="comment">//输出(此时的a值) 10，0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b ~/= <span class="number">10</span>);  <span class="comment">//输出(此时的b值) 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b %= <span class="number">10</span>);   <span class="comment">//输出(此时的b值) 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b &lt;&lt;= <span class="number">2</span>);      <span class="comment">//输出(此时的b值) 8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b &gt;&gt;= <span class="number">2</span>);      <span class="comment">//输出(此时的b值) 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b &amp;= <span class="number">5</span>);       <span class="comment">//输出(此时的b值) 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b ^= <span class="number">5</span>);       <span class="comment">//输出(此时的b值) 5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b |= <span class="number">5</span>);       <span class="comment">//输出(此时的b值) 5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="8-级联运算符"><a href="#8-级联运算符" class="headerlink" title="8. 级联运算符"></a>8. 级联运算符</h5><p>级联运算符是 Dart 中比较高级的运算符，用于对同一对象执行一系列操作，使用 <code>..</code> 表示。使用级联运算符可以减少中间变量的生成，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> lst = <span class="built_in">List</span>()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ..add(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ..add(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ..addAll([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(lst);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>级联运算符也可以嵌套使用。</p>
<h5 id="9-点运算符"><a href="#9-点运算符" class="headerlink" title="9. 点运算符"></a>9. 点运算符</h5><p>点运算符用来对对象的属性和方法进行操作。使用点运算符操作对象中不存在的属性或方法时会抛出异常，同样也不能操作 <code>null</code> 对象，如果不确定对象是否为空，则可使用条件访问运算符 <code>?.</code> 。如果需要操作的对象为空会返回 <code>null</code>，否则正常操作。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(lst.length);  <span class="comment">//输出 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  lst = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// print(lst.length);  //运行此行会抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(lst?.length); <span class="comment">//输出 null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="二、流程控制"><a href="#二、流程控制" class="headerlink" title="二、流程控制"></a>二、流程控制</h4><p>流程控制语句与其他语言没有什么区别，下面简单的只列出代码，不做过多讲解。需要注意在 Dart 中条件的真假只有 <code>true</code> 和 <code>false</code> ，或它能得出 <code>true</code> 和 <code>false</code> 的表达式。</p>
<h5 id="1-if-和-else"><a href="#1-if-和-else" class="headerlink" title="1. if 和 else"></a>1. if 和 else</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> score = <span class="number">80</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(score &gt;= <span class="number">100</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"满分"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"及格"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"不及格"</span>);</span></pre></td></tr></table></figure>



<h5 id="2-for-、while-、do-while"><a href="#2-for-、while-、do-while" class="headerlink" title="2. for 、while 、do while"></a>2. for 、while 、do while</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//第一种for</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"-----分割线-----"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//第二种for</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> x <span class="keyword">in</span> arr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"-----分割线-----"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span>(i &lt; <span class="number">5</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"-----分割线-----"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">do</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">while</span>(i &lt; <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="3-break-和-continue"><a href="#3-break-和-continue" class="headerlink" title="3. break 和 continue"></a>3. break 和 continue</h5><p><code>break</code> 用于跳出与 <code>break</code> 最近的循环，<code>continue</code> 用于跳出本次执行的循环。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//正常的循环，输出1，2，3，4，5，6，7，8，9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(arr[i][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//break，当j == 1时跳出里层for循环，所以最终只打印了数组的1，3，7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(j == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(arr[i][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//continue 当j==1时，跳出单次循环，继续下次循环 输出 1，3，5，7，9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(j == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(arr[i][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="4-switch-和-case"><a href="#4-switch-和-case" class="headerlink" title="4. switch 和 case"></a>4. switch 和 case</h5><p>Dart 中 <code>switch</code> 参数可以使用整型、字符串或编译时常量，<code>case</code> 后对象必须全部是同一类的实例。通常，每个非空 <code>case</code> 子句都以 <code>break</code> 结尾。结束非空 <code>case</code> 子句的其他有效方法为 <code>continue</code> 、<code>throw</code> 、<code>return</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> single = <span class="string">"e"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">switch</span>(single) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"h"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"h"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"e"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"e"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"l"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"l"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"o"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"o"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以使用 <code>continue</code> 来进行跳转执行，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> single = <span class="string">"e"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">switch</span>(single) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"h"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"h"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"e"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"e"</span>);         <span class="comment">//输出 e</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">continue</span> jumpOther;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"l"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"l"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    jumpOther:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">"o"</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"o"</span>);         <span class="comment">//输出 o</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(<span class="string">"error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述代码在 <code>case &quot;o&quot;:</code> 上添加了一个 <code>jumpOther</code> 标签，并在 <code>case &quot;e&quot;:</code> 处通过 <code>continue jumpOther</code> 进行了调用，输出e后继续执行o。</p>
<h4 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h4><p>异常是一种错误，在程序的运行过程中造成异常的情况有很多，如果不加以识别和控制将引发程序被挂起，造成程序崩溃而结束程序。Dart 中的异常都是未经检查的异常。Dart 中提供了 <code>Exception</code> 和 <code>Error</code> 类型，以及许多预定义的子类型，也可以自定义异常。Dart 程序可以抛出任何非 <code>null</code> 对象，而非仅限于  <code>Exception</code> 和 <code>Error</code> 。</p>
<p><strong>抛出异常</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">throw</span> FormatException(<span class="string">"这是一个FormatException"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// print("程序结束");  //此处不会被执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//抛出的异常 Unhandled exception: FormatException: 这是一个FormatException</span></span></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">throw</span> <span class="number">400</span>;  <span class="comment">//抛出自定义的任意非null异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// print("程序结束");  //此处不会被执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//抛出的异常 Unhandled exception: 400</span></span></pre></td></tr></table></figure>

<p><strong>捕获异常</strong></p>
<p>捕获异常的目的在于组织异常的传播，并进行一定的处理措施。可以将有可能发生异常的代码放在 <code>try</code> 代码块中并使用 <code>catch</code> 捕获。如果需要捕获的异常不止一种，可以使用多个 <code>catch</code> 。基本形式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="string">"抛出一个字符串提示异常"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> RangeError <span class="keyword">catch</span>(e) &#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// print(e);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> <span class="built_in">String</span> <span class="keyword">catch</span>(e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"字符串异常"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">catch</span>(e, s) &#123;  <span class="comment">//e为异常信息，s为异常的栈跟踪信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"其他异常:<span class="subst">$e</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"栈信息:<span class="subst">$s</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码主动抛出一个异常，是一句字符串的提示信息，所以下面将执行 <code>print(&quot;字符串异常&quot;)</code> ，<code>on</code> 后接一个异常的具体类型，因为我们抛出的是字符串异常信息，所以会进入 <code>on String catch(e)</code> ，当然可以定义其他具体异常类型。如果捕获的异常并非 <code>on</code> 后接的异常类型，则进入最后的未定义具体类型的异常。<code>catch</code> 方法可以有一个参数参数或两个参数，一个参数时，参数为异常提示信息，两个参数时，第一个参数为异常提示信息，第二个为异常的堆栈信息(<code>StackTrace</code> 对象)。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="built_in">List</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(arr[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> <span class="built_in">int</span> <span class="keyword">catch</span>(e) &#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> <span class="built_in">String</span> <span class="keyword">catch</span>(e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"字符异常"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">catch</span>(e, s) &#123;  <span class="comment">//e为异常信息，s为异常的栈跟踪信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"其他异常:<span class="subst">$e</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"栈信息:<span class="subst">$s</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>异常异常类型为 <code>RangeError</code> 类型，所以通过 <code>on</code> 捕获的 <code>int</code> 和 <code>String</code> 类型都不对，进入最后的 <code>catch</code> 。</p>
<p>即使捕获到了异常，开发者也可以根据具体情况决定是处理、忽略还是继续抛出异常，如果需要继续抛出，可使用   <code>rethrow</code> 关键字。 <code>rethrow</code> 允许部分处理异常或直接继续抛出异常给其他方法处理。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="built_in">List</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">print</span>(arr[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">rethrow</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> <span class="built_in">int</span> <span class="keyword">catch</span>(e) &#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> <span class="built_in">String</span> <span class="keyword">catch</span>(e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">catch</span>(e, s) &#123;  <span class="comment">//e为异常信息，s为异常的栈跟踪信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"其他异常:<span class="subst">$e</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"栈信息:<span class="subst">$s</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"善后处理或抛出异常后需要继续执行的代码"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此外有时需要无论是否抛出异常都执行指定的代码，则需要使用到 <code>finally</code> 关键字，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="built_in">List</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(arr[<span class="number">3</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> <span class="built_in">int</span> <span class="keyword">catch</span>(e) &#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">on</span> <span class="built_in">String</span> <span class="keyword">catch</span>(e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"字符异常"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">catch</span>(e, s) &#123;  <span class="comment">//e为异常信息，s为异常的栈跟踪信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"其他异常:<span class="subst">$e</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"栈信息:<span class="subst">$s</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"善后处理或抛出异常后需要继续执行的代码"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="四、断言"><a href="#四、断言" class="headerlink" title="四、断言"></a>四、断言</h4><p>Dart 中使用 <code>assert</code> 来调试程序的执行，使用 <code>assert</code> 如果布尔条件为假，则中断正常执行，并抛出异常。<code>assert</code> 中的条件是任何可以转化为布尔类型的对象，即使函数也可以。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"执行第一步"</span>); <span class="comment">//输出 执行第一步</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">assert</span>(<span class="number">1</span> == <span class="number">1</span>);    <span class="comment">//条件为真，继续执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"执行第二步"</span>); <span class="comment">//输出 执行第二步</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">assert</span>(<span class="number">1</span> == <span class="number">2</span>);    <span class="comment">//条件为假，抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"执行第三步"</span>); <span class="comment">//不执行此处</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以上会抛出如下异常：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//执行第一步</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//执行第二步</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Unhandled exception:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Failed assertion: line 5 pos 10: '1 == 2': is not true.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//#0      _AssertionError._doThrowNew  (dart:core-patch/errors_patch.dart:42:39)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//#1      _AssertionError._throwNew  (dart:core-patch/errors_patch.dart:38:5)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//#2      main </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Dart/demo1.dart:5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//#3      _startIsolate.&lt;anonymous closure&gt;  (dart:isolate-patch/isolate_patch.dart:307:19)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//#4      _RawReceivePortImpl._handleMessage  (dart:isolate-patch/isolate_patch.dart:174:12)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Exited (255)</span></span></pre></td></tr></table></figure>

<p>可以附加自己的说明在 <code>assert</code> 里，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">assert</span>(<span class="number">1</span> == <span class="number">2</span>, <span class="string">"这里的条件不成立，1不等2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"不会执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>assert</code> 可以有两个参数，第一个为任意可以解析为布尔值的表达式，第二个为附加说明信息。</p>
<p>在生产代码中，<code>assert</code> 将被忽略，并且不会评估断言的参数。</p>
<p>PS：如果您使用的是 VSCode 来运行 以上断言代码，如果安装有 Code Runner 插件并使用此插件来运行代码，则断言不会执行，需要通过 Debug -&gt; Start Debugging 或 Debug -&gt; Start Without Debugging 来运行代码才会执行断言代码。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
      </tags>
  </entry>
  <entry>
    <title>[Flutter]flutter基础之Dart语言基础(一)</title>
    <url>/content/f7be53c4.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>Dart 是 Google 公司在2011年10月发布的一种编程语言，主要是将其作为一种结构化的 Web 开发语言。可以用在Web、服务器、移动应用和物联网等领域的开发，是宽松开源许可证（修改的BSD证书）下的开源软件。官方网站：<a href="https://dart.dev/" target="_blank" rel="noopener">https://dart.dev/</a> 。</p>
<p>在 Dart 中，所有东西都是对象，变量，数字，函数等都是对象类型，都是类的实例，所有对象都继承自 <code>Object</code> 类。</p>
<a id="more"></a>

<p>在进行 Dart 开发前，需要安装 Dart SDK，安装方法官网网站有介绍，地址为：<a href="https://dart.dev/get-dart" target="_blank" rel="noopener">https://dart.dev/get-dart</a> 。如直接进行 Flutter 开发，也可不用下载此 SDK ，直接安装 Flutter 即可。Flutter开发工具包中包含 Dart。</p>
<h4 id="二、语法基础"><a href="#二、语法基础" class="headerlink" title="二、语法基础"></a>二、语法基础</h4><h5 id="1-入口方法"><a href="#1-入口方法" class="headerlink" title="1. 入口方法"></a>1. 入口方法</h5><p>Dart 语言文件格式为 <code>.dart</code> ，并以 <code>main</code> 方法作为程序的入口点，我们使用 VSCode 创建 <code>demo1.dart</code> 文件，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">'hello dart!'</span>);  <span class="comment">//输出结果：hello dart!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Dart 语言有很多简写形式，以上的 <code>main</code> 方法就是简写，完整的写法如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">'hello dart!'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>参数为泛型的写法，<code>List</code> 为列表，也就是其他语言中的数组。 <code>main</code> 方法可以接收由命令行输入的参数，可以通过 <code>args</code> 参数在程序中获取。如下代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">'hello dart!'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过命令行的方式运行 <code>dart</code> 文件，首先 <code>cd</code> 到目标文件夹，运行如下命令： <code>dart demo1.dart arg1,arg2</code> ，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hello dart!</span></pre></td></tr><tr><td class="code"><pre><span class="line">[arg1,arg2]</span></pre></td></tr></table></figure>

<p>一般情况下，使用省略方式即可。</p>
<p>在 Dart 中，<code>print</code> 方法不支持多参数打印，其函数原型如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">print</span>(<span class="built_in">Object</span> object);</span></pre></td></tr></table></figure>

<p>只支持单参数打印，但是可以利用字符串插值的方式进行多参数打印，使用 <code>$</code> 美元符号，比如打印 a, b两个变量，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$a</span> <span class="subst">$b</span>"</span>);</span></pre></td></tr></table></figure>

<p>以上是利用字符串插值进行多参数打印，但实质上依然是单参数，只不过利用了字符串的插值特性输出多个参数而已。当然依然可以利用多个 <code>print</code> 打印多个参数。</p>
<h5 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h5><p>Dart 中所有类型都是对象，基础数据类型也是对象，都有自己的方法和属性。Dart 支持自动类型推断，所以在定义数据类型的时候，可以通过两种方式进行定义，直接使用具体数据类型定义和使用 <code>var</code> 关键字进行定义。当使用 <code>var</code> 定义时，编译器会根据具体的赋值数据类型推断出定义的变量或常量的数据类型。</p>
<p> 可以使用 <code>runtimeType</code> 来查看对象的运行时类型。</p>
<p>因为 Dart 中所有的类型都是对象，所以定义一个数据类型以后，如果未对其进行初始化操作，则其默认值为<code>null</code> 。</p>
<p>Dart 中，变量是区分大小写的。</p>
<p>*<em>2.1.1 数值类型 (Numbers) *</em></p>
<p>Dart 中数值类型有两种，整数( <code>int</code> )和小数( <code>double</code>)，他们继承自 <code>num</code> 类。使用直接数据类型定义方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">int</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> b = <span class="number">20.1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a);  <span class="comment">//输出10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b);  <span class="comment">//输出20.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a+b);<span class="comment">////<span class="markdown">输出30.1</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也可以使用如下方式定义：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = <span class="number">20.1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a+b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a.runtimeType);  <span class="comment">//输出int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果与上面相同，下面的方式编译器会自动推断出具体的数据类型。</p>
<p>Dart 中可以使用十进制和十六进制进行整数的赋值，不能使用其他进制。</p>
<p><strong>2.1.2 字符串类型 (Strings)</strong> </p>
<p>使用关键字 <code>String</code> 来声明字符串类型，字符串使用单引号或双引号包起来，Dart 中字符串是UTF-16编码，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> str1 = <span class="string">'hello dart!'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> str2 = <span class="string">"hello world!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$str1</span> <span class="subst">$str2</span>'</span>);  <span class="comment">//输出 hello dart! hello world!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>也可以在定义一个变量的同时直接赋值多个字符串，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> str = <span class="string">'hello dart! '</span> <span class="string">'this is'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="string">" a string"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(str);  <span class="comment">//输出 hello dart! this is a string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到上面的代码，我们定义了一个变量，但是赋值了三个字符串，编译器会将三个字符串合并为一个字符串进行处理。但是虽然我们分两行书写的字符串，但是在输出时并没有分行，也就是定义与输出的格式并不一样，如果需要定义与输出一样，可以使用如下方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//1.通过转义字符\n进行换行操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> str = <span class="string">"hello dart! \nthis is a string "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//2.通过```或"""将字符串包裹起来为多行字符串，使用此方式时，需注意字符串的对齐方式，字符的前面的空格会包含在内，左边界为编译器的行头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> str1 = <span class="string">'''hello dart! </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">  this is a string'''</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(str1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hello dart! </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> is a <span class="keyword">string</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">hello dart! </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">this</span> is a <span class="keyword">string</span></span></pre></td></tr></table></figure>

<p>可以使用加号和插值的方式进行拼接，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> a = <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> b = <span class="string">" dart!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a + b);  <span class="comment">//输出 hello dart!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$a</span><span class="subst">$b</span>"</span>); <span class="comment">//输出 hello dart!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用字符串插值的方式进行拼接时，如果 <code>$</code> 后为一个标识符则可直接使用，如果为表达式则需要使用 <code>{}</code> 将表达式包含起来，如下:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> a = <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> b = <span class="string">" dart!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a + b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;a.runtimeType&#125;</span> <span class="subst">$&#123;b.runtimeType&#125;</span>"</span>); <span class="comment">//此处需要使用&#123;&#125;将表达式包含起来作为一个标识符使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在 Dart 中，字符串也是一种集合类型，可以通过如下方式获取字符串中的单个字符：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> str = <span class="string">"hello dart!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(str[<span class="number">0</span>]);  <span class="comment">//输出 h</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(str[<span class="number">4</span>]);  <span class="comment">//输出 o</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下标从0开始。</p>
<p>也可以通过 <code>*</code> 运算符对字符串进行拷贝操作，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> str = <span class="string">"hello dart!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(str*<span class="number">2</span>);  <span class="comment">//输出 hello dart!hello dart!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>使用如下方式原样输出字符串，包括里面的转义字符：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> str = <span class="string">r"this is a \n string!"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(str);  <span class="comment">//输出 this is a \n string!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>2.1.3 布尔类型 (Booleans)</strong></p>
<p>Dart 中，布尔类型只有两个字面量值：<code>true</code> 和 <code>false</code> 。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">bool</span> a = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$a</span> <span class="subst">$b</span>"</span>);  <span class="comment">//输出 true false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b.runtimeType);  <span class="comment">//输出 bool</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面说过，Dart中所有的类型都是对象，如果在定义 <code>bool</code> 类型时，没有进行初始化，则其默认值为 <code>null</code>，在进行条件判断时会报异常，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="built_in">bool</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span>(c) &#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="built_in">print</span>(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的代码编译不会报错，运行时会报如下异常：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Unhandled exception:</span></pre></td></tr><tr><td class="code"><pre><span class="line">Failed assertion: boolean expression must <span class="keyword">not</span> be <span class="literal">null</span></span></pre></td></tr></table></figure>

<p>所以在使用 <code>bool</code> 类型进行条件判断时，如果有为空的可能应先进行是否为 <code>null</code> 的判断，并且 Dart 中的条件判断必须使用 <code>bool</code> 类型，其他类型会编译错误。 </p>
<p><strong>2.1.4 集合类型</strong></p>
<p><strong>列表 (Lists)</strong></p>
<p>列表用来存放一组数据，在很多其他编程语言中，列表也被称为数组，所以与其他语言一样，下标从0开始，最后一个数据元素的下标为 <code>lenght-1</code> 。列表的具体数据类型由其中的元素类型决定，使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr  = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"string"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"string"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr</span> \t\t\t <span class="subst">$&#123;arr.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr1</span> \t <span class="subst">$&#123;arr1.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr2</span> \t\t\t <span class="subst">$&#123;arr2.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr3</span> \t <span class="subst">$&#123;arr3.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] 					 List&lt;<span class="keyword">int</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">string</span>] 	 List&lt;Object&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] 					 List&lt;dynamic&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">string</span>] 	 List&lt;dynamic&gt;</span></pre></td></tr></table></figure>

<p>以上方式直接创建 <code>List</code> 并进行初始化操作，定义空列表，使用 <code>var arr = [];</code> 即可。需要注意如果不进行初始化，其数据类型为 <code>null</code> ，即便使用 <code>List arr;</code> 定义，其 <code>runtimeType</code> 类型也为 <code>Null</code> 。</p>
<p>也可使用构造方法创建数组，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">List</span>();   <span class="comment">//创建空列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">List</span>(<span class="number">3</span>); <span class="comment">//创建长度为3的列表，使用null填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">//创建长度为3的列表，并使用整形数据1填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="string">"a"</span>); <span class="comment">//创建长度为3的列表，并使用字符串a填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr</span> \t <span class="subst">$&#123;arr.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr1</span> \t <span class="subst">$&#123;arr1.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr2</span> \t <span class="subst">$&#123;arr2.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr3</span> \t <span class="subst">$&#123;arr3.runtimeType&#125;</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">[] 	 									List&lt;dynamic&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>] 	  List&lt;dynamic&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>] 					  List&lt;<span class="keyword">int</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[a, a, a] 					  List&lt;String&gt;</span></pre></td></tr></table></figure>

<p>在 Dart 中，可是省略 <code>new</code> 关键字，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">List</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  arr[<span class="number">0</span>] = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  arr[<span class="number">1</span>] = <span class="string">"str"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$arr</span> \t <span class="subst">$&#123;arr.runtimeType&#125;</span>"</span>);   <span class="comment">//输出 [10, str] 	 List&lt;dynamic&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(arr.length);  <span class="comment">//输出 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上创建的列表都是可存放任意类型的数据的，如果想存放固定类型的数据，可以使用泛型进行数据类型约束，使用方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arr = [<span class="string">"str1"</span>, <span class="string">"str2"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(arr);  <span class="comment">//输出 [str1, str2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr1 = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  arr1.add(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  arr1.add(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(arr1);  <span class="comment">//输出 [1, 2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>创建固定数据类型的列表，如果添加其他数据类型数据编译器会报错。</p>
<p><strong>集合 (Sets)</strong></p>
<p><code>Set</code> 与 <code>List</code> 类似，但是 <code>Set</code> 为无序列表，所以不能通过下标的方式进行访问。 <code>Set</code> 中不能有重复数据，如果存在重复数据，只会保留一份数据。依靠此特性，一般使用 <code>Set</code> 来对列表进行去重处理。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Set</span> <span class="keyword">set</span> = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="keyword">set</span>);   <span class="comment">//输出 &#123;1, 2, 3, 4&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> set1 = &#123;<span class="string">"str1"</span>, <span class="string">"str2"</span>, <span class="string">"str1"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(set1);  <span class="comment">//输出 &#123;str1, str2, 1, 2, 3&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> set2 = <span class="built_in">Set</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  set2.add(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  set2.add(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  set2.add(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  set2.add(<span class="string">"str"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(set2);  <span class="comment">//输出 &#123;1, 2, str&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Set</span>&lt;<span class="built_in">int</span>&gt; set3 = <span class="built_in">Set</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  set3.add(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// set3.add("str");  //错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(set3);  <span class="comment">//输出 &#123;1&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Set</span> set4 = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(set4);  <span class="comment">//输出 &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>数组去重处理，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Set</span> <span class="keyword">set</span> = <span class="built_in">Set</span>.from(arr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr1 = <span class="built_in">List</span>.from(<span class="keyword">set</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(arr1);  <span class="comment">//输出 [1, 2, 3, 4, 5, 6]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>字典 (Maps)</strong></p>
<p>字典是一组键值对的集合，可以通过键完成对值的修改、查找、添加或删除操作，其中，键( key ) 必须是唯一的。创建 Map 类型，键 (key) 与值 (value) 要成对出现。一般情况下，键都是字符串类型，但是 Dart 中并没有严格约束键的数据类型，所以键可以为任意类型，值也可以为任意类型。如果需要创建固定类型的键值，可通过泛型进行约束。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> map1 = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"name"</span> : <span class="string">"zhangsan"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"age"</span> : <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> map2 = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">1</span> : <span class="number">20</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">2</span> : <span class="number">30.2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span> map3 = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"name"</span> : <span class="string">"lisi"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">1</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span> map4 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span> map5 = <span class="built_in">Map</span>.from(map1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; map6 = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"number"</span> : <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"age"</span> : <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Map</span> map7 = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  map7[<span class="string">"name"</span>] = <span class="string">"wanger"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  map7[<span class="string">"age"</span>] = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(map1);  <span class="comment">//输出 &#123;name: zhangsan, age: 20&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(map2);  <span class="comment">//输出 &#123;1: 20, 2: 30.2&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(map3);  <span class="comment">//输出 &#123;name: lisi, 1: [1, 2, 3]&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(map4);  <span class="comment">//输出 &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(map5);  <span class="comment">//输出 &#123;name: zhangsan, age: 20&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(map6);  <span class="comment">//输出 &#123;number: 1, age: 20&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(map7);  <span class="comment">//输出 &#123;name: wanger, age: 20&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>2.1.5 泛型</strong></p>
<p>泛型，即通用类型，使 Dart 中的类型更加动态，提高了代码的重用率。Dart 中使用 <code>&lt;T&gt;</code> 的方式来定义泛型，<code>T</code> 为标识符或关键字，一般用 <code>T</code> 表示。上面的例子中也使用了泛型来约束数据类型，例如列表：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  arr.addAll([<span class="string">"str1"</span>, <span class="string">"str2"</span>, <span class="string">"str3"</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(arr);  <span class="comment">//输出 [str1, str2, str3]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>2.1.6 符文 (Runes)</strong></p>
<p>符文(runes)是字符串的UTF-32编码点，要在字符串中表示32位的Unicode值，可使用 <code>\uxxxx</code> 形式，xxxx 为四位十六进制值，如多于或少于四位，则需要使用 <code>{}</code> 包装。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> value = <span class="string">'\u&#123;1F362&#125;'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(value);  <span class="comment">//输出 🍢</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>2.1.7 符号类型 (Symbols)</strong></p>
<p><code>Symbol</code> 表示运算符或标识符，使用相同名称创建的符号是相等的，有如下两种方式创建符号：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> symb = <span class="built_in">Symbol</span>(<span class="string">"s"</span>);  <span class="comment">//通过构造方法创建符号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> symb1 = #s;  				 <span class="comment">//通过#创建符号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(symb.runtimeType);  <span class="comment">//输出 Symbol</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(symb1.runtimeType); <span class="comment">//输出 Symbol</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(symb == symb1) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相同"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>2.1.8 常量</strong></p>
<p>以上声明的变量都是可变量，也就是变量，有时候需要一些数据是不可变的，称为常量。在 Dart 中，定义常量可以通过关键字 <code>const</code> 或 <code>final</code> 来定义，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> a = <span class="number">10</span>;  <span class="comment">//声明具体数据类型和var关键字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> b = <span class="string">'hello dart!'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$a</span> <span class="subst">$b</span>"</span>);  <span class="comment">//输出 hello world! hello dart!</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;a.runtimeType&#125;</span> <span class="subst">$&#123;b.runtimeType&#125;</span>"</span>);!  <span class="comment">//输出 String String</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看出，在声明常量时，可以省略其数据类型，编译器会自动进行推断。无论使用 <code>const</code> 还是 <code>final</code> 声明的常量都是不可以改变的，并且在定义常量时，在定义的同时就需要对其进行初始化操作，否则会报错。如果试图对常量进行重新复制，也会报错。</p>
<p>上面的代码中，使用 <code>const</code> 和 <code>final</code> 声明的常量，其输出的最终数据类型都为 <code>String</code> ，那么具体他们之间的区别是什么呢？</p>
<p><code>const</code> 定义的常量在定义时必须赋值为一个常量值，不可以通过表达式或函数进行赋值操作(常量表达式可以)，而 <code>final</code> 定义的常量则可以通过表达式或函数赋值，也就是说 <code>const</code> 常量为编译时常量，在编译阶段就必须是可知的，而 <code>final</code> 常量是只能对其进行一次赋值，但是可以在运行时进行设置。 如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> b = <span class="number">20.5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> c = a ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> d = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// const e = a+b;  //错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">final</span> f = a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> g = a * <span class="number">10</span>;  <span class="comment">//正确，因为a为常量，常量表达式在编译期就可以确定值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a);  <span class="comment">//输出 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b);  <span class="comment">//输出 20.5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(c);  <span class="comment">//输出 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(d);  <span class="comment">//输出 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(f);  <span class="comment">//输出30.5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(g);  <span class="comment">//输出 100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>const</code> 还可以用来创建常量值以及声明创建常量值的构造函数(后期文章会介绍到)，创建常量值如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> a = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> b = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(a == b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相同"</span>);   <span class="comment">//会输出 相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果不用 <code>const</code> 修饰，则a与b为不同，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(a == b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相同"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">"不同"</span>);  <span class="comment">//输出 不同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>并且 使用如下方式声明创建的常量值是可以改变的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">List</span> a = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//可改变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//不可改变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是对于 <code>const [1, 2, 3]</code> 中的单个数据元素是不可修改的，修改会抛出异常。对于 <code>a</code> 变量来说是可变的，因为未使用 <code>const</code> 修饰，所以对 <code>a</code> 重新赋值 <code>[4, 5, 6]</code> 以后，<code>a</code> 对象相当于如下定义：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span></pre></td></tr></table></figure>

<p>通过以下代码验证：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = <span class="keyword">const</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(a == b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相同"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"不同"</span>);   <span class="comment">//输出不同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以下代码为对 <code>const [1, 2, 3]</code> 单个元素修改抛出异常的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a[<span class="number">0</span>] = <span class="number">10</span>;   <span class="comment">//错误，不可修改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p><strong>2.1.9 动态数据类型</strong></p>
<p>在确定数据类型以后再赋值其他数据类型则会报错，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = <span class="number">20.1</span>;   <span class="comment">//错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的代码会报错如下错误：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">A value of <span class="keyword">type</span> 'double' can't be assigned to a variable of <span class="keyword">type</span> '<span class="keyword">int</span>'.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Try changing the <span class="keyword">type</span> of the variable, <span class="keyword">or</span> casting the right-hand <span class="keyword">type</span> to '<span class="keyword">int</span>'<span class="variable">.dart</span>(invalid_assignment)</span></pre></td></tr></table></figure>

<p>如果希望变量在赋值一个数据类型以后再赋值其他数据类型，可以使用关键字 <code>dynamic</code> 定义，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">dynamic</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a.runtimeType);  <span class="comment">//输出int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = <span class="number">20.1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a);  <span class="comment">//输出20.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a.runtimeType);  <span class="comment">//输出double</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>dynamic</code> 的最终数据类型为最后赋值的数据的类型。</p>
<p><strong>2.2.0 枚举 (enum)</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Monday,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Tuesday,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Wednesday</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> week = Week.Tuesday;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(week == Week.Monday)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"星期一"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(week == Week.Tuesday) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"星期二"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(week == Week.Wednesday) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"星期三"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(Week.values); <span class="comment">//输出所有枚举值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(Week.Monday.index);  <span class="comment">//输出索引值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(Week.Tuesday.index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(Week.Wednesday.index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">星期二</span></pre></td></tr><tr><td class="code"><pre><span class="line">[Week<span class="variable">.Monday</span>, Week<span class="variable">.Tuesday</span>, Week<span class="variable">.Wednesday</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr></table></figure>



<h5 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="3. 类型转换"></a>3. 类型转换</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> b = <span class="number">20.5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c = a + b.toInt();  <span class="comment">//浮点型转整型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> d = a.toDouble() + b;  <span class="comment">//整型转浮点型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">String</span> e = b.toString();  <span class="comment">//浮点型转字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">double</span> f = <span class="built_in">double</span>.parse(e);  <span class="comment">//字符串转浮点，使用此方法应确定字符串可转换为浮点型，否则会报异常，如不确定是否可以转换应使用tryParse方法，无法转换会返回null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$c</span> <span class="subst">$d</span> <span class="subst">$e</span> <span class="subst">$f</span>"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="4-Object-与-dynamic-的区别"><a href="#4-Object-与-dynamic-的区别" class="headerlink" title="4. Object 与 dynamic 的区别"></a>4. <code>Object</code> 与 <code>dynamic</code> 的区别</h5><p>因为在 Dart 中，所有内容都是从 <code>Object</code> 类扩展而来，所以可以使用如下方式定义数据：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> a = <span class="number">10</span>;</span></pre></td></tr></table></figure>

<p>与 <code>dynamic</code> 对比，他们都可以定义一种数据类型以后再次赋值其他数据类型，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Object</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  a = <span class="string">"string"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a);  <span class="comment">//输出 string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">dynamic</span> b = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  b = <span class="string">"string"</span>; <span class="comment">//输出 string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是 <code>Object</code> 定义的对象在调用方法或属性是，可以在编译时就判断是否存在指定的方法或属性，如不存在，编译阶段就会报错。而 <code>dynamic</code> 动态类型，调用不存在的方法或属性，在编译阶段不会报错，运行时才会抛出异常，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main()&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">Object</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">dynamic</span> b = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">print</span>(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// a.run; 调用不存在的属性run，编译时就会提示错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  b.run;  <span class="comment">//编译时不会提示错误，运行时才会抛出异常</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>PS：以上只是很小一部分内容，因为一切皆对象，所以每个类都有自己的很多属性与方法，具体可以参看代码文档。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>Flutter开发</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
        <tag>hybrid</tag>
        <tag>Native</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.Swift]Swift基础数据类型(一)</title>
    <url>/content/bc12b792.html</url>
    <content><![CDATA[<h4 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h4><p>在 <code>Swift</code> 中，常量(不可变的变量)使用 <code>let</code> 关键字定义，变量使用 <code>var</code> 关键字定义，并且 <code>Swift</code> 建议尽可能使用 <code>let</code> 关键字定义，因为常量要更安全一些，如果一个值不允许被改变，但在无意间做了修改则有可能造成一些Bug的出现。定义的常量如果进行了修改，则编译器会报错。</p>
<a id="more"></a>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法，正确写法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二种写法，错误写法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//var a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//let b</span></span></pre></td></tr></table></figure>

<p>为什么第一种写法是正确的，而第二种写法是错误的呢？因为在 <code>Swift</code> 中可以进行变量类型推断，当我们定义变量并初始化以后，编译器可以根据我们的初始化值对所定义的变量自动进行类型推断。而定义但不初始化编译器就无法做出类型推断。当然可以进行显示指出定义的数据类型，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Double</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//同时声明三个Double类型变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d, e, f:<span class="type">Double</span></span></pre></td></tr></table></figure>

<p>虽然这样写是正确的，但是未初始化的变量是无法使用的，使用编译器会报错，所以在定义时最好直接进行初始化工作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Double</span> = <span class="number">200.0</span></span></pre></td></tr></table></figure>

<p>建议使用第一种写法，让编译器自动进行类型推断。</p>
<p>以上代码可以发现，在每一个代码后并没有使用分号(<code>;</code>)，在 <code>Swift</code> 中，一行只有一条语句是可以不加分号的，加了也没有错，但是如果一行的语句大于1，则需要使用分号隔开，以下都是正确的写法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>, b = <span class="number">200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="keyword">var</span> y = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以下分行写也是正确的，但是不便于阅读</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">100</span></span></pre></td></tr></table></figure>

<p>建议每一行只定义一条语句。</p>
<p><code>Swift</code> 中不允许使用系统提供的关键字作为变量名，如果想使用，可以用如下方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确，需要使用``将关键字包起来</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> `<span class="class"><span class="keyword">class</span>` = 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">`<span class="title">class</span>` = 100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">//错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">var</span> <span class="title">class</span> = 10</span></span></pre></td></tr></table></figure>



<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><code>print</code> 对象打印提供的内容。</p>
<p><code>debugPrint</code> 将最适合调试的给定项的文本表示形式写入标准输出。</p>
<p>都是将要打印的内容输出到控制台，但是 <code>debugPrint</code> 的打印结果非常丰富，与打印内容相关的内容都会做输出，特别在复杂对象输出时，比较明显，比如网络。</p>
<p><code>Swift</code>使用字符串插值(string interpolation)的方式将常量名或变量名当做占位符插入到字符串中，<code>Swift</code> 会使用该变量或者常量的值替换这些占位符。使用方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式 \(变量名)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> world = <span class="string">"hello world"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"this is hello \(world)"</span>)</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> is hello hello world</span></pre></td></tr></table></figure>



<h4 id="Int-整型"><a href="#Int-整型" class="headerlink" title="Int 整型"></a><code>Int</code> 整型</h4><p><code>Swift</code> 中整型有如下几种：</p>
<p>有符号型：<code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>、<code>Int</code></p>
<p>无符号型：<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code>、<code>UInt</code></p>
<p>8、16、32、64代表位，比如：<code>Int8</code> 8位有符号整型，在内存中占8位，占位不同，数值大小范围不同。</p>
<p><code>Int</code> 所占内存空间与当前平台原生字长相同，32位平台，<code>Int</code> 与 <code>Int32</code> 长度相同，64位平台，<code>Int</code> 与 <code>Int64</code> 长度相同。相应的，<code>UInt</code> 也与平台原生字长相同，32位平台，<code>UInt</code> 与 <code>UInt32</code> 长度相同，64位平台，<code>UInt</code> 与 <code>UInt64</code> 长度相同。</p>
<p>整型可以有四种表示形式：十进制(无前缀)、二进制(<code>0b</code>前缀)、八进制(<code>0o</code>前缀)、十六进制(<code>0x</code>前缀)。</p>
<p>可以通过 <code>Int.max</code> 来获取 <code>Int</code> 的最大值，<code>Int.min</code> 获取最小值，其他整型也如此。</p>
<p><strong><em>尽量不要使用 <code>UInt</code> ，即便变量保存的总是非负的值，统一使用 <code>Int</code> 型可以提高代码的复用性，避免在不同数据类型之间进行转换，并可匹配数值的类型推断。非特殊要求内存优化等情况，应尽量使用<code>Int</code></em></strong></p>
<h4 id="Double-和-Float-字符型"><a href="#Double-和-Float-字符型" class="headerlink" title="Double 和 Float 字符型"></a><code>Double</code> 和 <code>Float</code> 字符型</h4><p>浮点数可以表示更大范围的数。</p>
<p><code>Float</code> 表示32位浮点数，当要求精度不高时可以使用此种类型，可以输出到小数点后6位。</p>
<p><code>Double</code> 表示64位浮点数，存储很大或高精度浮点数时使用，可以输出到小数点后15位。</p>
<p>浮点可以有十进制(无前缀)、十六进制(<code>0x</code>前缀)表示。两种都可以使用指数方式表示。</p>
<p>当声明浮点型变量时，如不指定数据类型，通过自动推断，那么 <code>Swift</code> 会自动推断其为 <code>Double</code> 类型。</p>
<p>在 <code>Swift</code> 中，正浮点数除以0.0，得到的结果表示正无穷大，负浮点数除以0.0，得到的结果表示负无穷大，0.0除以0.0或对一个负数开方的结果表示非数。所有的正无穷大都相等，所有的负无穷大都相等，非数与任何数都不相等，包括它自己。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="number">200</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a == a1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"不相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = -<span class="number">100</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b1 = -<span class="number">200</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b == b1)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="number">0.0</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="number">0.0</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">c</span> == c1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> a == <span class="built_in">c</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"不相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">相等</span></pre></td></tr><tr><td class="code"><pre><span class="line">true</span></pre></td></tr><tr><td class="code"><pre><span class="line">不相等</span></pre></td></tr></table></figure>

<p><strong><em>只有浮点数才能除以0.0，整数除以0编译器会报错。</em></strong></p>
<h4 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h4><p>在 <code>Swift</code> 中，为了增加可读性，数值类型数据可以使用以下表示方式，并不影响使用效果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1_000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="number">1_000.1_000</span></span></pre></td></tr></table></figure>

<p><code>Swift</code> 中不同数据类型之间不能进行隐式转换，即便都是整型的 <code>Int</code> 与 <code>Int64</code> 等也不能直接使用，必须显示转换，这样可以防止不同数据类型之间不能转换或取值范围不同等造成的问题。显示转换方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:Int = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:Int64 = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = Int64(a) + b</span></pre></td></tr></table></figure>

<p>浮点数与整数之间操作也要显示转换。</p>
<h4 id="Bool-布尔型"><a href="#Bool-布尔型" class="headerlink" title="Bool 布尔型"></a><code>Bool</code> 布尔型</h4><p><code>Swift</code> 中布尔类型只有两个值，<code>true</code> 、 <code>false</code> ，其他值并不能当做布尔类型使用，不能用于判断真假。比如，非0值并不能当做 <code>true</code> 使用。比如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"真"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"假"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//错误，b为整型，并非布尔类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> b &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"真"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"假"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是可以使用条件来判断真假，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> b &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"真"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"假"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a><code>tuple</code> 元组</h4><p>元组，使用圆括号把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求元组内的值具有相同的类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明但未初始化，不可使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user : (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Bool</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//初始化，可使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">user = (<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//声明并初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1:(<span class="type">Int</span>, <span class="type">Bool</span>)  = (<span class="number">10</span>, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user1)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用类型推断为(Int, Bool)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user3 = (<span class="number">10</span>, <span class="literal">true</span>)</span></pre></td></tr></table></figure>

<p>元组也可以嵌套使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user4 = (<span class="number">10</span>, (<span class="number">10</span>, <span class="number">20</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user5:(<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">String</span>)) = (<span class="number">10</span>, (<span class="number">20</span>, <span class="string">"hello"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user4)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"\(user5)"</span>)</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, (<span class="number">10</span>, <span class="number">20</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, (<span class="number">20</span>, <span class="string">"hello"</span>))</span></pre></td></tr></table></figure>

<p>获取元组元素的值可以通过下标来获取，与数组一样，下标从0开始。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1:(<span class="type">Int</span>, <span class="type">Bool</span>)  = (<span class="number">10</span>, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = (<span class="number">10</span>, (<span class="number">10</span>, <span class="number">20</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user3:(<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">String</span>)) = (<span class="number">10</span>, (<span class="number">20</span>, <span class="string">"hello"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user1.<span class="number">0</span>, user1.<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user2.<span class="number">0</span>, user2.<span class="number">1.0</span>, user2.<span class="number">1.1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user3.<span class="number">1</span>)</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> false</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">20</span>, <span class="string">"hello"</span>)</span></pre></td></tr></table></figure>

<p>可以对元组进行拆分，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (name, age) = user1</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (name1, (age1, sex)) = user2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(name, age)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(name1, age1, sex)</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">张三 <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">李四 <span class="number">22</span> m</span></pre></td></tr></table></figure>

<p>如果只需要部分元素，分解时，可是使用 <code>_</code> 下划线来作为被忽略部分的占位符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (name, <span class="number">_</span>) = user1</span></pre></td></tr></table></figure>

<p>也可以为元组的数据元素命名，可以通过名称来对元组元素进行访问。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = (name:<span class="string">"zhangsan"</span>, age:<span class="number">20</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user.name, user.age)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user1:(name:<span class="type">String</span>, age:<span class="type">Int</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//不指定元素名称则需要按照元素类型顺序进行复制</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">user1 = (<span class="string">"zhangsan"</span>, <span class="number">29</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//指定名称则可以不用按照顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">user1 = (age:<span class="number">20</span>, name: <span class="string">"张三"</span>)</span></pre></td></tr></table></figure>

<p>当元组中只有一个数据时，<code>Swift</code> 会将只有一个数据的元组当做其中数据的数据类型来处理，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时的age为Int类型，而非元组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = (<span class="number">20</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//所以如下方法是错误的，编译器会报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//let age:(num:Int)</span></span></pre></td></tr></table></figure>

<p>可以使用 <code>type(of: &lt;T&gt;)</code> 查看数据类型。</p>
<p>如果元组中数据类型相同，可以快速交换元组中数据元组的值，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(i, j) = (j, i)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(i, j)  <span class="comment">//输出 20 10</span></span></pre></td></tr></table></figure>

<p>可以定义空元组，但是不能赋值，无法使用，只能是空元组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无法再次进行赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = ()</span></pre></td></tr></table></figure>



<h4 id="Optional-可选类型"><a href="#Optional-可选类型" class="headerlink" title="Optional 可选类型"></a><code>Optional</code> 可选类型</h4><p>在 <code>Swift</code> 中，使用可选类型来表示一个变量或常量有可能有值，也可能没有值(<code>nil</code>)，也称为值缺失。非可选类型数据是不能为 <code>nil</code> 的。<code>Swift</code> 中 <code>nil</code> 代表一个确定的值，即值缺失，任何可选类型数据都可以设置为 <code>nil</code>。 如果一个变量或常量有可能被赋予空值(值缺失)，则要声明为可选类型，否则赋 <code>nil</code> 值时会报错。</p>
<p>非可选类型的变量或常量在未初始化之前是无法使用的，可选类型未初始化则会自动设置为 <code>nil</code> (可选类型常量使用前也必须初始化，否则编译会报错，但是可设置为 <code>nil</code> )。可选类型使用如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">c</span>:<span class="type">Int?</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d:<span class="type">Bool?</span> = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(d)</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Optional(<span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">nil</span></pre></td></tr><tr><td class="code"><pre><span class="line">Optional(true)</span></pre></td></tr></table></figure>

<p>下面的写法是错误的，因为e非可选值类型，不能为 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e:<span class="type">Int</span> = <span class="literal">nil</span>  <span class="comment">//错误</span></span></pre></td></tr></table></figure>

<p>通过上面的输出结果可以发现，输出的都是可选值类型，而非基本数据类型，所以不能直接进行基本类型的操作，需要进行强制解析操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Int?</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//c为Int类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a! + b!</span></pre></td></tr></table></figure>

<p><code>Int?</code> 与 <code>Int</code> 是不同的数据类型，在运算前需要先获取变量的实际存储值，就需要通过 <code>变量名!</code> 这种形式进行强制解析。<code>!</code> 表示已知该可选变量有值，提取其中的值。使用 <code>!</code> 的前提就是保证要解析的可选变量或常量必须有值，才能解析成功，否则会导致运行时错误。可以先做判断在进行解析：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Int?</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a != <span class="literal">nil</span> &amp;&amp; b != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> <span class="built_in">c</span> = a! + b!</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Swift</code> 提供了更为方便的解析方法，可选绑定(optional binding)， 如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Int?</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tmpa = a, <span class="keyword">let</span> tmpb = b &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(tmpa, tmpb)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过 <code>if let</code> 或 <code>if var</code> 结合使用，就是先判断可选类型变量是否为 <code>nil</code> ，如果不为 <code>nil</code> ，将会对可选变量进行强制解析，并将解析后的值赋给声明的变量或常量。</p>
<p>上面的代码，如果需要对<code>a</code>或<code>b</code>的值进行修改，则使用 <code>if var tmpa</code> , <code>if var tmpb</code> 定义即可。</p>
<p>上面的例子说的是变量或常量有可能没有值的情况下需要进行判断解析，但是如果在第一次赋值后能确保一个可选类型总是有值(不会重新被设置为 <code>nil</code> )，则每次解析比较低效，比如，定义一个常量可选值，并赋初值(非空, <code>nil</code>)，则常量不能被改变，可以使用隐式可选类型，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int!</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a + <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)</span></pre></td></tr></table></figure>

<p><code>Int?</code> 与 <code>Int!</code> 的区别在于：当需要获取 <code>Int?</code> 类型的值时，需要进行手动解析操作，如上面的例子。使用 <code>Int!</code> 时无需手动进行解析，<code>Swift</code> 会隐式执行自动解析。所以使用隐式解析可选类型要确保可选类型有值，否则也导致错误。当然隐式解析可选类型也可以进行判空和进行可选绑定操作。</p>
<h4 id="typealias-类型别名"><a href="#typealias-类型别名" class="headerlink" title="typealias 类型别名"></a><code>typealias</code> 类型别名</h4><p><code>Swift</code> 中使用 <code>typealias</code> (type aliases)来对现有类型定义别名，其他语言一般使用 <code>typedef</code> 来做此操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">MyInt</span> = <span class="type">Int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">MyInt</span> = <span class="number">10</span></span></pre></td></tr></table></figure>

<p>定义好后，<code>MyInt</code> 与 <code>Int</code> 完全相同。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Int</tag>
        <tag>Tuple</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]RunLoop详解</title>
    <url>/content/c598aae1.html</url>
    <content><![CDATA[<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p><code>RunLoop</code> 运行循环，是与线程相关的基础架构的一部分，它是一个对象，用来管理需要处理的事件和消息，并提供入口函数来执行事件循环时的逻辑。运行循环的目的是在有工作要做时让线程保持忙碌，没有工作时让线程休眠。</p>
<p>每个线程，包括应用程序的主线程，都有一个相关的运行循环对象。线程与 <code>RunLoop</code> 之间存在一对一的关系，该关系存储在一个全局的 <code>Dictionary</code> 中。主线程的运行循环作为应用程序启动过程的一部分，自动设置并在主线程上运行。非主线程的运行循环需要显示运行，在创建线程时，并没有 <code>Runloop</code> ，如果不主动获取，它永远不会存在。<code>Runloop</code> 在第一次获取时创建，除了主线程之外，只能在线程内部获取 <code>RunLoop</code>。</p>
<h4 id="二、RunLoop-存在的意义"><a href="#二、RunLoop-存在的意义" class="headerlink" title="二、RunLoop 存在的意义"></a>二、<code>RunLoop</code> 存在的意义</h4><p>通常一个线程一次只能执行一个任务，任务执行完毕时，退出线程。<code>RunLoop</code> 是一个运行循环，内部是一个 <code>do...while</code> 循环，它在线程中执行可以保持线程持续运行不退出，以”接收消息-&gt;等待-&gt;处理”的循环模式持续运行，直到循环结束。实现此模式的关键是管理事件/消息时，如果在不处理消息时，使线程休眠以免资源占用，在消息到达时唤醒线程。主要来说作用有以下几点：</p>
<ul>
<li>保持程序运行</li>
<li>接收用户输入</li>
<li>监听事件</li>
<li>节省CPU时间</li>
<li>调用解耦</li>
</ul>
<h4 id="三、事件源"><a href="#三、事件源" class="headerlink" title="三、事件源"></a>三、事件源</h4><p>在OS X和iOS系统中，提供了两种 <code>RunLoop</code> 对象 ：</p>
<p>CoreFoundation 框架内的 <code>CFRunLoopRef</code> ，该框架为纯C函数提供的API，所有API都是线程安全的。<br>Foundation 框架内的 <code>NSRunLoop</code> ，<code>NSRunLoop</code> 是基于 <code>CFRunLoopRef</code> 的封装，提供了面相对象的API，是非线程安全的。</p>
<p><code>NSRunLoop</code> 可以通过 <code>[[NSRunLoop currentRunLoop] getCFRunLoop]</code> 转换为  <code>CFRunLoopRef</code> 。</p>
<p><code>RunLoop</code> 从两种不同类型的事件源接收消息：输入源( Input Sources )：传递异步事件，通常是来自另一个线程或其他应用程序的消息。计时器源(Timer Sources)：传递同步事件，这些事件是在计划的时间或重复的时间间隔发生。此外，运行循环还会生成有关运行循环行为的通知，注册的运行循环观察者可以接收这些通知，并使用它们在线程中进行其他处理。</p>
<p><img src="/content/c598aae1/2020111233.jpg" alt="2020111233"></p>
<h5 id="1-输入源-Input-Sources"><a href="#1-输入源-Input-Sources" class="headerlink" title="1.输入源(Input Sources)"></a>1.输入源(Input Sources)</h5><p>输入源包括三种类型的源：</p>
<ul>
<li><p>基于端口的输入源：Cocoa 和 Core Foundation 提供了用于线程或进程间通信的 Mach Port ，只需创建一个端口对象，然后将该对象添加到运行循环即可。在 Core Foundation 中需要手动创建端口及运行循环。</p>
</li>
<li><p>选择器源：选择器源在执行后会将其自身从运行循环中删除。执行选择器源时，目标线程必须有活动的运行循环。每次循环时，运行循环都会将所有排队的选择器任务进行执行调用，而不是每次执行一个。选择器有以下几种：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait modes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)array <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)modes;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anArgument;</span></pre></td></tr><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)cancelPreviousPerformRequestsWithTarget:(<span class="keyword">id</span>)aTarget;</span></pre></td></tr></table></figure>

<p>最后两个用于取消当前线程中的 <code>aSelector</code> 调用。</p>
</li>
<li><p>自定义输入源：需要使用 Core Foundation 中的 <code>CFRunLoopSourceRef</code> 。</p>
</li>
</ul>
<h5 id="2-计时器源"><a href="#2-计时器源" class="headerlink" title="2.计时器源"></a>2.计时器源</h5><p>计时器源在将来的预设时间将事件同步传递到线程，是线程通知自己执行某事的一种方式。在 Cocoa 中，使用 <code>NSTimer</code> 创建计时器来加入 <code>RunLoop</code> ，在 Core Foundation 中使用 <code>CFRunLoopTimerRef</code> 类型。<code>NSTimer</code> 是 <code>CFRunLoopTimerRef</code> 的简单扩展。</p>
<p>虽然计时器基于时间创建，但是它并非实时机制，计时器与运行循环的特定模式相关联。如果计时器不在运行循环当前正在监视的模式下，则只有当以计时器支持的一种的模式运行循环后，才会触发。如果计时器添加到运行循环时，运行循环正在执行处理程序，则计时器将要等到下一次运行循环调用。如果没有运行循环，则计时器不会触发。</p>
<p>对于重复执行的计时器，会根据计划触发时间(而不是实际触发时间)自动重新计划自身。比如：如果计时器计划在特定时间触发，然后每隔5秒触发一次，则即使实际触发时间被延迟，计划触发时间也将始终落在原始的5秒时间间隔上。如果触发时间延迟太多，以致错过了一个或多个计划触发时间，则计时器将在错过的时间段内只执行一次。</p>
<h5 id="3-观察者"><a href="#3-观察者" class="headerlink" title="3.观察者"></a>3.观察者</h5><p>观察者在运行循环本身执行期间的特定位置触发。需要使用 Core Foundation 框架中的 <code>CFRunloopObserverRef</code> 创建，并通过 <code>CFRunLoopAddObserver</code> 将观察者添加到运行循环中。运行循环可以指定使用一次或多次使用。一次触发的观察者在触发后将自己从运行循环中删除，重复执行的观察者将处于连接状态。每个观察者都包含一个回调(函数指针)，当运行循环的状态改变时，观察者可以通过回调来接收改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="comment">//进入循环</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="comment">//即将处理计时器时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="comment">//即将处理输入源时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="comment">//即将进入睡眠状态时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="comment">//唤醒后</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="comment">//退出运行循环时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="comment">//所有激活的状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>



<h4 id="四、循环模式"><a href="#四、循环模式" class="headerlink" title="四、循环模式"></a>四、循环模式</h4><p>运行循环模式是要监视的输入源和计时器以及要通知的运行循环观察者的集合。每次运行循环，都可以显示或隐式指定特定的模式。在运行循环的整个过程中，仅监视与该模式相关的源，并允许其传递时间。</p>
<p>一个 <code>RunLoop</code> 包含多个模式，每个模式都包含多个 Source/Timer/Observer 模式项 (上面介绍的三种)。每次调用 <code>RunLoop</code> 只能指定一种模式，如果需要切换模式，则只能退出循环，然后重新指定需要的模式。一个模式项可以同时添加到多个模式，但重复添加到同一模式将不起作用。没有模式项(事件源)的 <code>RunLoop</code> 将不能进入循环。</p>
<p>模式根据事件的来源进行区分，而不是事件的类型。输入源将事件异步传递到线程，事件的来源取决于输入源的类型。基于端口的输入源监视应用程序的 Mach 端口，自定义输入源监视定制源。两种源唯一的区别是信号发送的方式。基于端口的源由系统内核自动发出信号，自定义源需要手动发出信号。</p>
<p>系统默认已注册5种模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用的默认模式，通常主线程在此模式下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//对应Foundation中的NSDefaultRunLoopMode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kCFRunLoopDefaultMode  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//ScrollView界面跟踪模式，为确保滑动时界面不受其他模式影响  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">UITrackingRunLoopMode</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//应用启动初始化模式，启动完成后不再使用  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">UIInitializationRunLoopMode</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//接收系统事件的内部模式，通常不用  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GSEventReceiveRunLoopMode  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//占位符模式 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//对应Foundation中的NSRunLoopCommonModes  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kCFRunLoopCommonModes</span></pre></td></tr></table></figure>

<p><code>kCFRunLoopDefaultMode</code> 是 <code>RunLoop</code> 启动时的默认模式。<code>UITrackingRunLoopMode</code> 跟踪 <code>ScrollView</code> 状态。当创建一个 <code>NSTimer</code> 并将其添加到默认模式时，<code>NSTimer</code> 将获得回调。但当滑动 <code>ScrollView</code> 相关控件时，<code>RunLoop</code> 会将模式切换为 <code>UITrackingRunLoopMode</code> ，此时 <code>NSTimer</code> 将不会再被调用，也不影响滑动操作。如果想在两种模式下都被回调，可以将 <code>NSTimer</code> 同时加入到两种模式之中，也可以将 <code>NSTimer</code> 添加到 <code>kCFRunLoopCommonModes</code> ，<code>CommonModes</code> 并不是一种实模式，而是 <code>kCFRunLoopDefaultMode</code> 与 <code>UITrackingRunLoopMode</code>，此两种模式均已标记为通用( Common )属性。当 <code>RunLoop</code> 内容发生更改时，<code>RunLoop</code> 会自动将 <code>CommonModes</code> 中的 Source/Timer/Observer 与带有 Common   标志的所有模式同步。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;&#125;];</span></pre></td></tr></table></figure>

<p>使用此种模式创建的 <code>NSTimer</code> 将加入到 <code>RunLoop</code> 的默认模式下(<code>kCFRunLoopDefaultMode</code>)。添加到非默认模式下需要使用如下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> * timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;&#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span></pre></td></tr></table></figure>



<p>事件源</p>
<h4 id="使用-RunLoop"><a href="#使用-RunLoop" class="headerlink" title="使用 RunLoop"></a>使用 <code>RunLoop</code></h4><p>何时使用运行循环：</p>
<p>使用端口或自定义输入源与其他线程进行通信；<br>在线程上使用计时器；<br>调用<code>PerformSelector...</code>方法；<br>保持线程执行周期性任务；</p>
<p>对于长时间存在且需要运行循环的线程，最好至少配置一个输入源来接收消息。虽然配置定期触发的计时器依然可以保持运行循环不退出，但定期触发的计时器会以轮训的方式定期唤醒线程。而配置输入源可以等待事件发生，事件未发生时可以使线程睡眠，直到事件发生唤醒线程。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取主运行循环</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Foundation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> * runLoop = [<span class="built_in">NSRunLoop</span> mainRunLoop];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Core Foundation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoopRef = <span class="built_in">CFRunLoopGetMain</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前运行循环</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Foundation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> * cRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Core Foundation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> cRunLoopRef = <span class="built_in">CFRunLoopGetCurrent</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前循环模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Foundation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSRunLoopMode</span> mode = [[<span class="built_in">NSRunLoop</span> currentRunLoop] currentMode];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Core Foundation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopMode</span> cMode = <span class="built_in">CFRunLoopCopyCurrentMode</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//NSRunLoop 转 CFRunLoopRef</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] getCFRunLoop];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有的循环模式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">CFArrayRef</span> array =  <span class="built_in">CFRunLoopCopyAllModes</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span></pre></td></tr></table></figure>



<p><strong>添加观察者</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//创建上下文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">CFRetain</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">CFRelease</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="literal">NULL</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//创建观察者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;runloopObserverCallBack, &amp;context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//添加观察者到当前的RunLoop</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(observer) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">CFRunLoopRef</span> cRunLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(cRunLoop, observer, kCFRunLoopDefaultMode);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFRelease</span>(observer);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//创建一个Timer 保持runloop有事做</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//回调方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> runloopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, (__bridge ViewController *)info);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>CFRunLoopObserverContext</code> 用来创建观察者的上下文环境，它是一个结构体，包含程序定义的数据和回调结构。<code>version</code> 为结构体版本号，必须为0；<code>info</code> 为任意指针，可通过此指针传递上下文中定义的所有回调；<code>retain</code> 保留任意指针，可以为NULL；<code>release</code> 释放任意指针，可以为NULL；<code>copyDescription</code> 任意指针的副本描述回调，也是一个函数指针，可以为NULL。</p>
<p><code>CFRunLoopObserverCreate</code> 创建观察者，有6个参数，<code>allocator</code> 为新对象的内存分配器，传递 <code>NULL</code> 或 <code>kCFAllocatorDefault</code> ; <code>activities</code> 为观察者要观察的运行循环标志，上面有介绍，可以看<a href="https://developer.apple.com/documentation/corefoundation/cfrunloopactivity?language=objc" target="_blank" rel="noopener"><code>CFRunLoopActivity</code></a> ，如需观察多个状态，可使用按位或进行组合；<code>repeats</code> 标志只调用一次还是每次都调用观察者；<code>order</code> 优先级，苹果建议使用0；<code>callout</code> 回调函数；<code>context</code>  上下文信息，可以为NULL。</p>
<p><code>CFRunLoopAddObserver</code> 添加观察者到指定 <code>RunLoop</code> ，三个参数，<code>rl</code> 为要添加到的运行循环；<code>observer</code> 要添加的观察者；<code>mode</code> 循环模式。</p>
<p><strong>自定义源</strong></p>
<p>自定义源 <code>CFRunLoopSourceRef</code> 有两个版本，<code>Source0</code> 和 <code>Source1</code>。</p>
<p><code>Source0</code> </p>
<p><code>Source1</code> </p>
<p><code>CFRunLoopSourceContext</code> 源上下文，为一个结构体，包含程序定义的数据和回调。<code>version</code> 为结构体版本号，必须为0；<code>info</code> 为任意指针，可通过此指针传递上下文中定义的所有回调；<code>retain</code> 保留任意指针，可以为NULL；<code>release</code> 释放任意指针，可以为NULL；<code>copyDescription</code> 任意指针的副本描述回调，也是一个函数指针，可以为NULL。<code>equal</code> 与任意指针相等的测试回调，可以为NULL；<code>hash</code> 任意指针的散列计算回调，可以为NULL；<code>schedule</code> 运行循环源的调度回调。当源被添加到运行循环模式时，调用该回调。可以为NULL；<code>cancel</code> 运行循环源的取消回调。当源从运行循环模式中移除时，调用此回调。可以为NULL；<code>perform</code> 运行循环源的执行回调。当源已激发时，调用此回调。</p>
<p><strong>端口通信</strong></p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>RunLoop</tag>
        <tag>NSTimer</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]线程锁</title>
    <url>/content/9ff26aaa.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制。主要是为了解决共享资源的安全问题。当不同的线程同时操作一块内存数据时，如果不加以限制，会发生数据错乱等异常问题。加锁，则每个线程在访问对应资源时，需要先获取锁信息，再根据信息决定是否可以访问。当一条线程访问特定资源时，使用锁会锁定该特定资源，此时其他线程无法访问该资源。当资源访问结束后，会恢复锁的状态，允许其他线程访问，这样就保证了在同一时间只有一个对象访问特定资源，实现数据安全。</p>
<a id="more"></a>

<h4 id="二、锁实现"><a href="#二、锁实现" class="headerlink" title="二、锁实现"></a>二、锁实现</h4><h5 id="1-atomic与nonatomic"><a href="#1-atomic与nonatomic" class="headerlink" title="1.atomic与nonatomic"></a>1.<code>atomic</code>与<code>nonatomic</code></h5><p>在说锁之前，先来看下原子与非原子：</p>
<p><code>atomic</code> 原子的，使用<code>atomic</code>属性标志表示的是无论多少个线程访问给定属性，其值的设置或获取都会获得一个完整的值，而不是部分值。并不是表示线程安全，只是表示值的完整性。当有多个线程对同一属性进行写入操作时，只能保证每次读的时候上一次写入操作已经完成。但是如果此时有读取操作，并不能保证读取到的值是哪次写入后的值，有可能是写入之前，也有可能是其中，某个写入后的值等。</p>
<p><code>nonatomic</code>非原子的，也就是与<code>atomic</code>相反，当多线程访问时，有可能会获取到一个不完整的结果，比如当一个线程在进行写入操作时，执行到<code>setter</code>方法中的某一部分，此时另外一个线程进行了写入操作，会造成数据错乱或崩溃等，具体看执行到什么位置。同样也非线程安全。</p>
<p>其部分源码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!atomic) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    oldValue = *slot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *slot = newValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    slotlock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    oldValue = *slot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *slot = newValue;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    slotlock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>atomic</code>属性时，内部使用自旋锁进行锁定操作，而<code>nonatomic</code>并没有此操作。定义属性时，如不指定默认为<code>atomic</code>。</p>
<p>有如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">self</span>.countIndex--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr></table></figure>

<p>也证明了<code>atomic</code>是非线程安全的。既然非线程安全，就需要手动添加锁来保证线程安全。</p>
<h5 id="2-POSIX-Mutex-Lock"><a href="#2-POSIX-Mutex-Lock" class="headerlink" title="2.POSIX Mutex Lock"></a>2.POSIX Mutex Lock</h5><p> C语言实现，是一套跨平台的多线程API。pthread是一套非常强大的多线程锁，可以创建互斥锁（普通锁）、递归锁、信号量、条件锁、读写锁、once锁等，基本上所有涉及的锁，都可以用pthread来实现。需要添加头文件<code>#import &lt;pthread.h&gt;</code>，在使用之前要先初始化，基本使用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义互斥锁变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//静态初始化锁，定义的时候就要初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动态初始化锁，使用默认属性，传NULL即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//销毁锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_destroy(&amp;mutex);</span></pre></td></tr></table></figure>

<p>互斥锁如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pthread_mutex_t mutex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//动态初始化锁，使用默认属性，传NULL即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pthread_mutex_lock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(_countIndex &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">self</span>.countIndex = <span class="keyword">self</span>.countIndex - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"执行结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//销毁锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            pthread_mutex_destroy(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pthread_mutex_unlock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>递归锁，更改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutexattr_t</span> attr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutexattr_init(&amp;attr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutexattr_destroy(&amp;attr);</span></pre></td></tr></table></figure>



<h5 id="3-synchronized-指令"><a href="#3-synchronized-指令" class="headerlink" title="3.synchronized 指令"></a>3.<code>synchronized</code> 指令</h5><p><code>@synchronized</code> 隐式的创建一种其他锁能实现的功能，通过不同线程共用同一标识符的方式来达到互斥的目的。传递给<code>@synchronized</code>指令的对象是一个唯一的标识符，用于区分受保护的块。如果在不同线程使用不同的对象标识符，则每个线程都会获得自己的锁，而不被其它锁阻塞。<code>@synchronized</code>块隐式地向受保护的代码添加了一个异常处理程序，这个处理程序在抛出异常时会自动释放互斥，这意味着为了使用@synchronized指令，您还必须在代码中启用Objective-C异常处理。所以会带来一定的额外开销，如果大量使用<code>@synchronized</code>指令则效率较低。</p>
<p>使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(_countIndex &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">self</span>.countIndex = <span class="keyword">self</span>.countIndex - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"执行结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：<code>synchronized</code>标识token 为任意<code>id</code>类型，一般使用<code>self</code>。</p>
<h5 id="4-NSLock"><a href="#4-NSLock" class="headerlink" title="4.NSLock"></a>4.<code>NSLock</code></h5><p><code>NSLock</code> 互斥锁，互斥锁是一种信号量，每一次只授权一个线程访问权限。如果正在使用互斥锁并且另一个线程尝试获取它，该线程将阻塞，直到互斥锁被其原始持有者释放为止。如果多个线程竞争相同的互斥锁，一次只能访问一个。<code>NSLock</code>类使用POSIX线程来实现其锁定行为，向<code>NSLock</code>对象发送解锁消息时，必须确保该消息是从发送初始锁定消息的同一线程发送的。从其他线程解锁锁可能导致未定义的行为。不应使用此类来实现递归锁。在同一线程上两次调用<code>lock</code>方法将永久锁定您的线程。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> * mlock;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.mlock = [[<span class="built_in">NSLock</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.mlock.name = <span class="string">@"my lock"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.mlock lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(_countIndex &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">self</span>.countIndex = <span class="keyword">self</span>.countIndex - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"执行结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.mlock unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此外<code>NSLock</code>中还定义了<code>tryLock</code>、<code>lockBeforeDate</code>。<code>tryLock</code>会尝试获取锁，并立即返回是否成功，不会阻塞线程。<code>lockBeforeDate</code>在指定时间之前获取锁，此方法会阻塞当前线程，直到时间结束，如果在指定时间内未获取到锁则返回NO。</p>
<h5 id="5-NSRecursiveLock-递归锁"><a href="#5-NSRecursiveLock-递归锁" class="headerlink" title="5.NSRecursiveLock 递归锁"></a>5.<code>NSRecursiveLock</code> 递归锁</h5><p>“递归锁” ，顾名思义，常用在递归函数中以防止递归阻塞线程。当然也可以在非递归函数中使用。<code>NSRecursiveLock</code>定义的锁，可以被同一线程多次获取，而不会导致死锁问题。递归锁会记录成功获取的次数。每个成功锁的获取必须通过相应的调用来平衡解锁g该锁。只有当锁和解锁调用彼此平衡时，锁才会被释放，其他线程才能获取。使用属性与<code>NSLock</code>相同。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSRecursiveLock</span> * recursiveLock;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.recursiveLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> recursiveMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> recursiveMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)recursiveMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.recursiveLock lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.countIndex != <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        --<span class="keyword">self</span>.countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"countIndex:%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> recursiveMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.recursiveLock unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：在递归函数中加锁，如不使用递归锁则会造成死锁，线程将会被锁死。</p>
<p>因为在获取锁与解锁平衡之前，递归锁不会被释放，所以会消耗一定的性能。长时间持有递归所会导致其他线程阻塞，直到递归完成。所以如果对性能需求较高，可以通过重写代码来消除递归，可获得更好的性能。</p>
<h5 id="6-OSSpinLock-与-os-unfair-lock-lock"><a href="#6-OSSpinLock-与-os-unfair-lock-lock" class="headerlink" title="6.OSSpinLock 与 os_unfair_lock_lock"></a>6.<code>OSSpinLock</code> 与 <code>os_unfair_lock_lock</code></h5><p><code>os_unfair_lock_lock</code>为<code>OSSpinLock</code>的替代品，<code>OSSpinLock</code>已废弃，如果需要使用自旋锁，要使用<code>os_unfair_lock_lock</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">os_unfair_lock_lock(&amp;lock);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">os_unfair_lock_unlock(&amp;lock);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//尝试加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  BOOL isLock = os_unfair_lock_trylock(&amp;lock);</span></span></pre></td></tr></table></figure>



<h5 id="7-NSCondition-条件"><a href="#7-NSCondition-条件" class="headerlink" title="7.NSCondition 条件"></a>7.<code>NSCondition</code> 条件</h5><p>条件对象既充当给定线程中的锁又充当检查点。锁在测试条件并执行条件触发的任务时保护您的代码。检查点行为要求条件在线程继续执行其任务之前为真。条件不成立时，线程将阻塞。它保持阻塞状态，直到另一个线程向条件对象发出信号为止。</p>
<p>每当您使用条件对象时，第一步就是锁定条件。锁定条件可确保您的谓词和任务代码免受使用相同条件的其他线程的干扰。完成任务后，您可以根据代码需求设置其他谓词或发出其他条件信号。按住条件对象的锁时，应始终设置谓词和信号条件。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSCondition</span> * condition = [[<span class="built_in">NSCondition</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!<span class="keyword">self</span>.countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"等待执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            [condition wait];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --<span class="keyword">self</span>.countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行:%ld"</span>,<span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">self</span>.countIndex += <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"发信号"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition signal];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">等待执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">发信号</span></pre></td></tr><tr><td class="code"><pre><span class="line">执行:<span class="number">9</span></span></pre></td></tr></table></figure>

<p>示例代码只用了两个并发演示，可能有多条线程访问数据，需要添加锁保证数据安全。其他方法：</p>
<p><code>waitUntilDate</code> 等待直到发出条件信号或达到指定的时间限制为止，阻塞当前线程。必须在调用此方法之前锁定接收器。<br><code>broadcast</code> 发出状态信号，唤醒所有等待该状态的线程。为避免出现竞争情况，仅应在接收器锁定时调用此方法。</p>
<h5 id="8-NSConditionLock条件锁"><a href="#8-NSConditionLock条件锁" class="headerlink" title="8.NSConditionLock条件锁"></a>8.<code>NSConditionLock</code>条件锁</h5><p>条件锁根据特定的条件进行锁或者解锁，通常，当应用程序中的线程需要以特定顺序执行时（例如，当一个线程产生另一个线程消耗的数据时），您可以使用<code>NSConditionLock</code>对象。在生产者执行过程中，消费者休眠等待获取一个以生产者完成其操作为条件的锁。一个应用程序可以具有多个<code>NSConditionLock</code>对象，每个对象都保护代码的不同部分。但是，必须在应用程序成为多线程之前创建这些对象。</p>
<p><code>NSConditionLock</code>对象响应的锁定和解锁方法可以任意组合使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSConditionLock</span> * conditionLock;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> * mutableArray;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.conditionLock = [[<span class="built_in">NSConditionLock</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.mutableArray = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"条件锁的条件:%ld"</span>, (<span class="keyword">long</span>)<span class="keyword">self</span>.conditionLock.condition);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> producersMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> consumersMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)producersMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始生产数据"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            [<span class="keyword">self</span>.mutableArray addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)consumersMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始消费数据"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.mutableArray[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            [<span class="keyword">self</span>.mutableArray removeObjectAtIndex:<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">条件锁的条件:<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">开始生产数据</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">开始消费数据</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr></table></figure>

<p><code>unlockWithCondition</code>方法为解锁并设置新的锁定条件。<code>lockWhenCondition</code>尝试获取锁，接收者的条件必须等于锁定操作成功之前的条件。此方法会阻塞线程的执行，直到可以获取锁为止。还有一些其他方法：</p>
<p><code>lockBeforeDate</code> 尝试在指定日期之前获取锁，此方法将阻塞线程的执行，直到接收者获得锁定或达到限制为止。<br><code>lockWhenCondition:beforeDate</code> 尝试在指定的时间之前获取指定锁。接收者的条件必须等于锁定操作成功之前的条件。此方法将阻止线程的执行，直到可以获取锁或达到限制为止。<br><code>tryLock</code>尝试获取锁而不考虑接收者的状况，不阻塞线程。<br><code>tryLockWhenCondition</code> 根据指定条件尝试获取锁。作为其实现的一部分，此方法将调用<code>lockWhenCondition：beforeDate</code>。此方法立即返回。</p>
<h5 id="9-dispatch-semaphore"><a href="#9-dispatch-semaphore" class="headerlink" title="9.dispatch_semaphore"></a>9.<code>dispatch_semaphore</code></h5><p>通过都信号计数的控制来控制并发数量，达到对资源的同步访问的目的，具体可以看 <a href="http://www.mwpush.com/content/d04bd655.html">[iOS.OC]GCD的使用精解(三)</a></p>
<h5 id="10-NSDistributedLock分布锁"><a href="#10-NSDistributedLock分布锁" class="headerlink" title="10.NSDistributedLock分布锁"></a>10.<code>NSDistributedLock</code>分布锁</h5><p>在多个主机上的多个应用程序中，可以使用<code>NSDistributedLock</code>类来限制对某些共享资源(文件)的访问。锁实际上是使用文件系统项(文件或目录)来实现锁的。所有使用<code>NSDistributedLock</code>对象的应用程序都必须可以写锁。这就意味着把它放在一个文件系统上，所有运行该应用程序的计算机都可以访问它。</p>
<p>上面也说过，<code>NSDistributedLock</code>是不遵循<code>NSLocking</code>协议的，所以没有锁方法。锁方法将阻塞线程的执行，并要求系统以预定的速度轮询锁定。当然这个决定权在开发者手中，可通过<code>tryLock</code>方法来决定是否轮询。<br>如果持有锁的进程在释放前挂掉，那么锁将一直得不到释放，可通过<code>breakLock</code>强行获取锁。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>线程锁</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]iOS中的多线程</title>
    <url>/content/436b03b3.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>OS X或iOS中的每个进程(应用程序)都由一个或多个线程组成，每个线程代表应用程序代码的单一执行路径。每个应用程序都从一个线程开始，这个线程运行应用程序的主要功能，称之为主线程。应用程序可以产生额外的线程，每个线程执行特定函数的代码。</p>
<p>关于线程等概念的介绍，可以看 <a href="http://www.mwpush.com/content/edab7fec.html">关于串行、并发、并行等的说明</a></p>
<p>实现多线程的方法主要有三种：<code>pthread</code>、<code>GCD</code>、<code>NSThread</code>、<code>NSOperation</code></p>
<a id="more"></a>

<h4 id="二、线程实现"><a href="#二、线程实现" class="headerlink" title="二、线程实现"></a>二、线程实现</h4><h5 id="1-线程开销"><a href="#1-线程开销" class="headerlink" title="1.线程开销"></a>1.线程开销</h5><p>内核数据结构，每个线程大约消耗1KB的内核内存空间。这块内存用于存储与线程有关的数据结构和属性，这块内存是联动内存，无法被分页。</p>
<p>栈空间，主线程的栈空间为1M，无法修改。子线程默认分配512KB的栈空间，会随时使用而增长。</p>
<p>线程启动前，可以通过<code>setStackSize</code>设置栈空间的大小。栈空间最小为16KB，且必须必须是4KB的整数倍。</p>
<p>大量开启线程会降低程序的性能，线程越多，CPU调度线程上的开销就越大。</p>
<h5 id="2-pthread"><a href="#2-pthread" class="headerlink" title="2.pthread"></a>2.<code>pthread</code></h5><p><code>OSIX</code>线程(<code>POSIX threads</code>)，简称<code>Pthreads</code>，是线程的POSIX标准，是基于C语言实现的跨平台的线程API。头文件为 ： <code>pthread.h</code>。由于<code>pthread</code>创建的线程是C语言实现的，生命周期由程序员管理，在OC中使用频率很低(几乎不用)。</p>
<p>用<code>pthread_create</code>创建，有四个参数，第一个为<code>pthread_t</code>线程ID(线程编号的地址)，第二个为<code>pthread_attr_t</code>线程属性，传<code>NULL</code>表示采用默认属性，第三个为<code>void * (*)(void *)</code>线程实现函数，第四个<code>void *restrict</code>实现函数的参数。返回值为<code>int</code>类型，表示线程创建成功或失败，0表示成功，非0表示失败，非0时返回错误码。</p>
<p>实现方式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runPthread</span><span class="params">(<span class="keyword">int</span> *param)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">pthread_t</span> pthreadID;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> result = pthread_create(&amp;pthreadID, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)runPthread, &amp;a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!result)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        NSLog(@<span class="string">"线程创建成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> NSLog(@<span class="string">"线程创建失败:%d"</span>, result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runPthread</span><span class="params">(<span class="keyword">int</span> *param)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@<span class="string">"%d"</span>, *param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>传OC对象参数，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * runPthread(<span class="keyword">void</span> *param);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    pthread_t pthreadID;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * param = <span class="string">@"我是参数"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> result = pthread_create(&amp;pthreadID, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)runPthread, (__bridge <span class="keyword">void</span> *)param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!result)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程创建成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"线程创建失败:%d"</span>, result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * runPthread(<span class="keyword">void</span> *param) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, (__bridge <span class="built_in">NSString</span> *)param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="3-NSThread"><a href="#3-NSThread" class="headerlink" title="3.NSThread"></a>3.<code>NSThread</code></h5><p>一个<code>NSThread</code>对象代表一条线程，可以使用类方法或实例方法创建。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用类方法创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(newThreadMethod) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  	使用block方式创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [NSThread detachNewThreadWithBlock:^&#123; /* 线程需要执行的内容 */ &#125;];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)newThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">线程:&lt;NSThread: <span class="number">0</span>x60000297b340&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>使用类方法创建，类方法无返回值，所以不能对线程做做操。创建后会直接启动线程执行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例方法创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(newThreadMethod:) object:<span class="string">@"创建新线程"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  	使用block方式创建    </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    NSThread * thread = [[NSThread alloc] initWithBlock:^&#123; /* 线程需要执行的内容 */&#125;];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)newThreadMethod:(<span class="built_in">NSString</span> *)str &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建新线程</span></pre></td></tr><tr><td class="code"><pre><span class="line">线程:&lt;NSThread: <span class="number">0</span>x6000038a3000&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>使用实例方法创建线程，返回线程的实例，可以设置一些属性。线程创建后，需手动开启执行。</p>
<p>属性设置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(newThreadMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//设置线程名称，方便debug</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thread.name = <span class="string">@"new thread"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//服务质量(优先级)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thread.qualityOfService = <span class="built_in">NSQualityOfServiceDefault</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//设置线程分配l空间，单位字节，不设置会使用默认值，为512*1024,512KB，这里我们设置为1024KB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread setStackSize:<span class="number">1024</span>*<span class="number">1024</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)newThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//返回当前线程对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * currentThread = [<span class="built_in">NSThread</span> currentThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//返回栈空间大小，单位为字节</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSUInteger</span> stackSize = [currentThread stackSize];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//判断currentThread是否是主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isMainThread = [currentThread isMainThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//线程是否处于执行状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isExecuting = [currentThread isExecuting];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//返回currentThread的优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> priority = [currentThread threadPriority];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//线程是否被取消</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isCancelled = [currentThread isCancelled];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//线程是否执行完毕</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isFinished = [currentThread isFinished];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//输出线程字典</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dic:%@"</span>, currentThread.threadDictionary);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"栈空间:%luKB"</span>, stackSize/<span class="number">1024</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"是否是主线程:%@"</span>, isMainThread ? <span class="string">@"是"</span> : <span class="string">@"不是"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"是否处于执行状态:%@"</span>, isExecuting ? <span class="string">@"是"</span> : <span class="string">@"不是"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"优先级:%f"</span>, priority);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程是否被取消:%@"</span>, isCancelled ? <span class="string">@"是"</span> : <span class="string">@"否"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程是否执行完毕:%@"</span>, isFinished ? <span class="string">@"是"</span> : <span class="string">@"否"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!isCancelled)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//取消线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        [currentThread cancel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//再次判断线程是否被取消</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>([currentThread isCancelled])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程被取消"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"线程没被取消"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//再次判断线程是否执行完毕</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>([currentThread isFinished])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"未执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">dic:&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">栈空间:<span class="number">1024</span>KB</span></pre></td></tr><tr><td class="code"><pre><span class="line">是否是主线程:不是</span></pre></td></tr><tr><td class="code"><pre><span class="line">是否处于执行状态:是</span></pre></td></tr><tr><td class="code"><pre><span class="line">优先级:<span class="number">0</span><span class="variable">.500000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">线程是否被取消:否</span></pre></td></tr><tr><td class="code"><pre><span class="line">线程是否执行完毕:否</span></pre></td></tr><tr><td class="code"><pre><span class="line">线程被取消</span></pre></td></tr><tr><td class="code"><pre><span class="line">未执行完毕</span></pre></td></tr></table></figure>

<p>可以看到，当调用<code>cancel</code>方法后线性被取消，但是线程中未执行完的代码会继续执行完毕。线程还有一个<code>exit</code>类方法为强制退出，强制退出则直接退出，未执行的代码不再执行。不要在主线程中调用<code>exit</code>方法，因为调用后线程将进入死亡状态，无法再次启动，界面不会崩溃，但无法操作。</p>
<p>一些类方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断当前线程是否为主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> isMainThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回主线程对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> mainThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回应用是否为多线程环境</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> isMultiThreaded];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个包含调用堆栈返回地址的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> callStackReturnAddresses];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个包含调用堆栈符号的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> callStackSymbols];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//睡眠一秒(时间秒)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//睡眠，阻塞当前线程直到指定的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>]];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置线程优先级(通常不用设置)，值范围0.0~1.0，默认值为0.5，值越大优先级越高，但并不保证优先级高的任务一定会先执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> setThreadPriority:<span class="number">1.0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回当前线程的优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> threadPriority];</span></pre></td></tr></table></figure>

<p><code>NSThread</code>中还有一个<code>main</code>方法，我们可以通过子类化<code>NSThread</code>，并重写<code>main</code>方法，以覆盖主方法来实现自己的线程入口点。如果复写了<code>main</code>方法就不要调用<code>super</code>来调用继承行为。 不要主动调用<code>main</code>方法，应通过<code>start</code>方法来启动。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span> : <span class="title">NSThread</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//分割线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyThread.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyThread</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程启动了：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyThread * mythread = [[MyThread alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [mythread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">线程启动了：&lt;MyThread: <span class="number">0</span>x60000019bd80&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>在<code>NSThread</code>的头文件中，可以看到一个<code>NSObject</code>的分类<code>NSObject (NSThreadPerformAdditions)</code>，里面提供了一些实例方法，都是跟线程相关的，这是<code>NSObject</code>提供的多线程方法，主要用来实现线程间的通信。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法1：使用指定模式调用在主线程中执行的指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为参数，第三个为在主线程中执行指定方法后，是否阻塞当前线程，YES 是 NO 否，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">如果当前线程为主线程，则不会阻塞，设置为YES时，消息(方法)将被立即执行，否则排队等待下次运行循环执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第四个为模式数组，不能为空，否则将不执行调用方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(callThreadMethod) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法2：在主线程中执行指定的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为参数，第三个为在主线程中执行指定方法后，是否阻塞当前线程，YES 是 NO 否</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">如果当前线程为主线程，则不会阻塞，设置为YES时，消息(方法)将被立即传送和处理。当方法1模式为</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">NSRunLoopCommonModes时，功能同此方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(callThreadMethod) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法3：使用指定模式调用在指定线程中执行的指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为要执行方法的线程，第三个为参数，第四个为在指定线程中执行指定方法后，是否阻</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">塞当前线程，YES 是 NO 否。如果当前线程和目标线程为同一线程，则不会阻塞，设置为YES时，消息(方法)将被立</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">即执行，否则将排队执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第五个参数为模式数组，不能为空，否则将不执行调用方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法4：在指定线程中执行指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为要执行方法的线程，第三个为从参数，第四个为在指定线程中执行指定方法后，是否阻塞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">当前线程，YES 是 NO 否。如果当前线程和目标线程为同一线程，则不会阻塞，设置为YES时，消息(方法)将被立即执</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">行，否则将排队执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">注意：此方法添加的方法是在目标线程的运行循环上排队执行，如果目标队列没有开启运行循环(RunLoop)则则不会执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callMainThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法5：在后台(子线程)执行指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(callThreadMethod) withObject:<span class="literal">nil</span>];</span></pre></td></tr></table></figure>

<p>注意：以上方法添加的方法都是在目标线程的运行循环上排队执行，如果目标队列没有开启运行循环(RunLoop)则则不会执行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加的执行方法:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建的线程：&lt;NSThread: <span class="number">0</span>x600003e4f680&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>发现，通过<code>performSelector</code>添加到<code>thread</code>的方法<code>callThreadMethod</code>并没有执行。因为目标队列没有启动运行循环，至于方法1和方法2，因为是运行在主线程上，主线程默认是开启了运行循环的，可以执行，而我们创建的线程默认是没有创建运行循环的，它直到我们获取才会创建。所以做如下更改：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//此处代码永远不会执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加的执行方法:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建的线程：&lt;NSThread: <span class="number">0</span>x600000506880&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">添加的执行方法:&lt;NSThread: <span class="number">0</span>x600000506880&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>因为运行循环是一个死循环，所以上面代码注释的地方永远不会访问到，可以用下面的方式改善代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> date]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"后面执行的任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加的执行方法:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建的线程：&lt;NSThread: <span class="number">0</span>x600001812900&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">添加的执行方法:&lt;NSThread: <span class="number">0</span>x600001812900&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">后面执行的任务</span></pre></td></tr></table></figure>

<p><code>runUntilDate</code>参数传入当前日期即可，它会给你足够的时间执行所需的任务。如果传入将来的时间，则会堵塞当前线程。当然还有别的方式，后续的<code>RunLoop</code>总结中会做说明。</p>
<h5 id="4-NSOperation与NSOperationQueue"><a href="#4-NSOperation与NSOperationQueue" class="headerlink" title="4.NSOperation与NSOperationQueue"></a>4.<code>NSOperation</code>与<code>NSOperationQueue</code></h5><p><code>NSOperation</code>是一个抽象类，不能直接使用，我们可以使用系统定义好的它的子类<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>，或自定义<code>NSOperation</code>的派生类。</p>
<p><code>NSInvocationOperation</code>可以创建一个非并发操作。它本身不会开辟线程，会在创建的线程中执行。创建后需要调用<code>start</code>方法启动。</p>
<p>创建方法1：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(callThreadMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationOperationMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [invocationOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invocationOperationMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"invocationOperation线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务执行线程：&lt;NSThread: <span class="number">0</span>x600001008100&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">invocationOperation线程：&lt;NSThread: <span class="number">0</span>x600001008100&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>创建方法2：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(callThreadMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSMethodSignature</span> * signature = [[<span class="keyword">self</span> <span class="keyword">class</span>] instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(invocationOperationMethod)];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocation</span> * invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    invocation.target = <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    invocation.selector = <span class="keyword">@selector</span>(invocationOperationMethod);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithInvocation:invocation];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [invocationOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invocationOperationMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"invocationOperation线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：<code>NSInvocation</code>主要用于在对象及应用之间存储和转发消息，<code>NSInvocation</code>可以设置多个参数，不要直接调用<code>init</code>方法初始化。</p>
<p><code>NSBlockOperation</code>管理一个或多个块的并发操作。当执行多个块操作时，只有当所有块执行完毕后，操作本身才被视为完成。添加到块操作中的任务会被调度到适当的工作队列。块创建好后，可以执行添加块任务操作，也可以查看块。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> * blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务2：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[blockOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [blockOperation executionBlocks]);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blockOperation追加任务1：&lt;NSThread: 0x6000032bfa80&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务1：&lt;NSThread: 0x6000032f6500&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务2：&lt;NSThread: 0x6000032c3180&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&lt;__NSGlobalBlock__: 0x101c9c060&gt;&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&lt;__NSGlobalBlock__: 0x101c9c080&gt;&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&lt;__NSGlobalBlock__: 0x101c9c0a0&gt;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>



<p>自定义<code>NSOperation</code>子类，自定义子类需要根据需要设计并发与非并发，非并发只需要重写<code>main</code>方法即可，可以自定义初始化行为，<code>main</code>方法中实现具体的任务代码。使用时，通过<code>start</code>启动任务即可。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyOperation.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyOperation</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!<span class="keyword">self</span>.isCancelled)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"具体任务代码"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        @autoreleasepool &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//分割线,下面为调用方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MyOperation * myOperation = [[MyOperation alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[myOperation start];</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">具体任务代码</span></pre></td></tr></table></figure>

<p>如果设计并发操作，则需要覆盖<code>start</code>、<code>asynchronous</code>、<code>executing</code>、<code>finished</code>，<code>start</code>负责以异步的方式启动操作，还应该负责更新执行状态，可通过<code>KVO</code>方式通知，而且还要保证线程安全。还有许多注意事项，可查看官方文档。</p>
<p>以上都是通过自定义<code>NSOperation</code>子类或使用系统提供的子类来实现操作的。在<code>NSOperation</code>抽象类中提供了很多关键行为，可以直接使用，我们以<code>NSBlockOperation</code>为例，进行说明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSBlockOperation</span> * blockOperation;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSBlockOperation</span> * operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"被依赖的操作任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operation1 addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"被依赖的操作任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//对于操作系统资源来说的相对优先级(重要性)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.blockOperation.qualityOfService = <span class="built_in">NSQualityOfServiceDefault</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//操作队列中操作的执行优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.blockOperation.queuePriority = <span class="built_in">NSOperationQueuePriorityNormal</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务2：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation setCompletionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"其他任务执行完毕，此任务最后执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation addDependency:operation1];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [self.blockOperation removeDependency:operation1];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self.blockOperation.dependencies:%@"</span>, <span class="keyword">self</span>.blockOperation.dependencies);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operation1 start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//相对当前线程是否为异步操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.blockOperation.asynchronous)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"异步执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"非异步执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.blockOperation.completionBlock);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"其他任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation cancel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">self<span class="variable">.blockOperation</span><span class="variable">.dependencies</span>:(    <span class="string">"&lt;NSBlockOperation: 0x7faaf44069b0&gt;"</span>   )</span></pre></td></tr><tr><td class="code"><pre><span class="line">被依赖的操作任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">被依赖的操作任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">2</span>：&lt;NSThread: <span class="number">0</span>x6000000d0080&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务<span class="number">1</span>：&lt;NSThread: <span class="number">0</span>x6000000ba0c0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">1</span>：&lt;NSThread: <span class="number">0</span>x6000000cc000&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">其他任务执行完毕，此任务最后执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">非异步执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="literal">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">其他任务</span></pre></td></tr></table></figure>

<p>首先对于所有操作来说，操作本身相对于当前线程都是串行的，即便操作内部可以执行的代码块之间可以并发。</p>
<p>所以这段例子代码中有很多的代码是看不出效果的。特此说明一下，只是说明用法。</p>
<p>可以通过<code>addDependency</code>添加依赖操作，可以通过<code>removeDependency</code>移除依赖，可以通过<code>dependencies</code>查看依赖状态。本段代码定义的两个操作本身对于执行流程来说就是串行的，先执行的任务会先输出，但是可以通过<code>dependencies</code>来查看依赖。添加依赖的目的在于添加依赖后，被依赖的操作要全部先执行完毕，才会执行依赖其它操作的任务本身。添加依赖要先启动依赖依然在启动本任务执行，否则会报错。</p>
<p>这里的调用<code>cancel</code> 方法是看不到效果的。<code>cancel</code>方法不会强制停止操作，会更新操作对象内部标志以反映状态变化。对于已完成的执行，<code>cancel</code>无效。可以取消在操作队列中，但尚未执行的操作，会比正常执行的操作更快的从队列中删除。</p>
<p><code>completionBlock</code>为该操作的主要任务完成后执行的代码，该任务块会在操作被标记为<code>finsihed</code>的情况下调用，也就是说在操作被取消的情况下，操作最后也会被标记为<code>finished</code>状态也会执行，所以在该任务块内不应该执行相当于操作任务块的任务内容，而可以添加一些与操作相关，但不属于该任务的其他任务。当<code>completionBlock</code>开始执行后，其会被设置为<code>nil</code>。</p>
<p>可以通过以下方法查看操作状态：<code>cancelled</code>操作是否已取消；<code>executing</code>操作是否正在执行；<code>finished</code>操作是否已经结束；<code>asynchronous</code>相对当前线程来说，操作是否为异步操作；<code>ready</code>是否可以立即执行该操作。</p>
<p>单一的操作不要调用<code>waitUntilFinished</code>方法，并且应避免在与其自身提交到同一操作队列的任何操作上调用它。容易造成死锁问题。此方法的典型用法是从最初创建操作的代码中调用它。将操作提交到队列后，您将调用此方法以等待该操作完成执行。</p>
<p><code>NSOperationQueue</code>操作队列，是根据操作的优先级和准备状态来进行排队的。将操作添加到操作队列后，队列就保留操作，直到操作完成。添加操作后，无法直接删除。操作多列将保留操作直到所有操作完成。挂起未完成的操作，可能导致内存泄露。如需按照特定的顺序执行，需要添加依赖来保证执行顺序。</p>
<p>取消操作，会将操作对象保留在队列中，会通知该对象尽快停止其任务。对于正在执行的操作，意味着操作对象的工作代码必须检查取消状态，停止正在执行的操作并将其标记为完成状态。对于已经排队但未执行的操作，队列仍然会调用其<code>start</code>方法，以便它可以处理取消事件并将自身标记为完成状态。</p>
<p>操作队列时线程安全的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> * operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation1 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task1) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task2) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSBlockOperation</span> * blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperation:operation1];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperation:operation2];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperation:blockOperation];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"operationQueue追加的操作:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task2 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务2:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">2</span>:&lt;NSThread: <span class="number">0</span>x600000bba200&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600000bbd180&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600000bcbf80&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationQueue追加的操作:&lt;NSThread: <span class="number">0</span>x600000bbd740&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600000b96fc0&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>因并发执行，顺序是不定的，<code>NSOperationQueue</code>可以添加附加功能及属性设置来控制执行，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> * operationQueue;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.operationQueue.name = <span class="string">@"OQ"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//设置服务质量(类似优先级)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.operationQueue.qualityOfService = <span class="built_in">NSQualityOfServiceDefault</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"穿插的操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue setUnderlyingQueue:queue];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//操作队列的最大并发数，也就是一次能最多执行多少个任务，可以自定义，如果定义为1，则功能是串行，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//任务会一个执行完毕执行另一个，如不设置则系统会根据不同的环境有不同的默认值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [operationQueue1 setMaxConcurrentOperationCount:2];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation1 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task1) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task2) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSBlockOperation</span> * blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addOperation:blockOperation];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addBarrierBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"障碍(栅栏)执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"operationQueue追加的操作:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//通过组的方式添加上到操作队列，waitUntilFinished表示是否阻塞当前线程直到多列中所有操作完成 是则阻塞等待完成，否不阻塞，直接返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addOperations:@[operation1, operation2] waitUntilFinished:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//阻塞当前线程，直到队列中所有任务都完成。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [operationQueue1 waitUntilAllOperationsAreFinished];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    NSLog(@"count:%lu", (unsigned long)self.operationQueue.operationCount);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"其他任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task2 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务2:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue cancelAllOperations];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [self.operationQueue setSuspended:NO];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">穿插的操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">mainQueue:&lt;NSOperationQueue: <span class="number">0</span>x7fab75404050&gt;&#123;name = 'NSOperationQueue Main Queue'&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">currentQueue:&lt;NSOperationQueue: <span class="number">0</span>x7fab75404050&gt;&#123;name = 'NSOperationQueue Main Queue'&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">其他任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600003204480&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x60000324fc00&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">障碍(栅栏)执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">2</span>:&lt;NSThread: <span class="number">0</span>x600003204480&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationQueue追加的操作:&lt;NSThread: <span class="number">0</span>x60000324fc00&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x60000322fd80&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>来对代码做下说明：</p>
<p>操作队列创建后可以设置名字，方便<code>debug</code>。<br>可以通过<code>qualityOfService</code>设置服务质量，如不设置，则会采用默认服务质量<code>NSOperationQualityOfServiceBackground</code>，主队列的服务质量为<code>NSOperationQualityOfServiceUserInteractive</code>且无法修改。服务质量会影响操作系统对CPU，网络资源，磁盘资源等的访问优先级，具有较高服务质量的操作比系统资源具有更高的优先级，会更快的执行其任务，但是并不建议使用，如非特殊，可以采用默认优先级即可，系统自身的调度会更合理高效的分配资源。<br>可以通过<code>setUnderlyingQueue</code>操作向队列中添加<code>dispatch_queue_t</code>类型的队列。<br><code>addBarrierBlock</code>方法可以添加障碍(栅栏)块任务，关于栅栏任务的执行方式，可以看<a href="http://www.mwpush.com/content/aeb8f67e.html">[iOS.OC]GCD的使用精解(二)</a>文章中对<code>dispatch_barrier_async</code>的说明，工作原理是一样的。<br>使用<code>waitUntilAllOperationsAreFinished</code>方法时，要将此方法的调用放在最后面，否则没效果。<br><code>cancelAllOperations</code>取消所有操作，就是让操作队列中的所有操作都调用各自的<code>cancel</code>方法。</p>
<p>可以通过<code>suspended</code>方法挂起或继续执行操作多列。</p>
<h5 id="5-GCD"><a href="#5-GCD" class="headerlink" title="5.GCD"></a>5.GCD</h5><p>关于<code>GCD</code>的介绍可以看下列文章：</p>
<p><a href="http://www.mwpush.com/content/d771b58d.html">[iOS.OC]GCD的使用精解(-)</a></p>
<p><a href="http://www.mwpush.com/content/aeb8f67e.html">[iOS.OC]GCD的使用精解(二)</a></p>
<p><a href="http://www.mwpush.com/content/d04bd655.html">[iOS.OC]GCD的使用精解(三)</a></p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>多线程</tag>
        <tag>multithreading</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]GCD的使用精解(三)</title>
    <url>/content/d04bd655.html</url>
    <content><![CDATA[<h4 id="一、Dispatch-Semaphore"><a href="#一、Dispatch-Semaphore" class="headerlink" title="一、Dispatch Semaphore"></a>一、<code>Dispatch Semaphore</code></h4><p>使用信号量可以达到控制并发数和线程锁的目的。它通过持有计数的信号的增减来控制访问。当计数为0时等待，计数大于等于1时，减1继续执行。</p>
<p><code>dispatch_semaphore_create</code>通过初始值创建一个信号量，有一个参数，为<code>long</code>类型，即初始值，应大于等于0，返回值为<code>dispatch_semaphore_t</code>类型信号量；</p>
<a id="more"></a>
<p><code>dispatch_semaphore_signal</code>发信号，即信号量值增加。有一个参数，为<code>dispatch_semaphore_t</code>类型信号量。</p>
<p><code>dispatch_semaphore_wait</code>等待信号量，即信号量减少。有两个参数，第一个为<code>dispatch_semaphore_t</code>类型信号量，第二个为<code>dispatch_time_t</code>类型超时时间。返回值为<code>long</code>类型，返回值为0则等待时间未超时，不为0则超时。</p>
<p><code>dispatch_semaphore_signal</code>与<code>dispatch_semaphore_wait</code>的调用要保持平衡。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第%d次执行"</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述代码为异步并发队列，此时输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">第<span class="number">0</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">4</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">2</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">5</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">3</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">6</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">7</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">9</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">8</span>次执行</span></pre></td></tr></table></figure>

<p>为无序输出，我们可以通过串行队列达到依次输出的目的，也可以使用信号量来控制，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第%d次执行"</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dispatch_semaphore_signal(semaphore);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">第<span class="number">0</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">2</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">3</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">4</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">5</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">7</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">6</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">8</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">9</span>次执行</span></pre></td></tr></table></figure>

<p>我们创建的信号量初始值为1，当执行<code>dispatch_semaphore_wait</code>方法时信号计数减1为0，所以此时如果有其他线程要执行同样的方法，因为信号计数为0需等待，无法继续执行。当执行<code>dispatch_semaphore_signal</code>方法时，信号计数加1，则<code>dispatch_semaphore_wait</code>方法将信号计数减1并继续执行，依次往复。</p>
<p>可见，信号量可以在多个线程间通过信号计数来协调控制访问处理。我们可以通过信号计数的值的控制来控制最大并发数，只要信号计数大于0就可以不用等待并发执行。</p>
<h4 id="二、Dispatch-Source"><a href="#二、Dispatch-Source" class="headerlink" title="二、Dispatch Source"></a>二、<code>Dispatch Source</code></h4><p>调度源，是用来监视低级系统事件的对象，在事件发生时，自动在指定的<code>Dispatch Queue</code>中执行指定的处理事件。</p>
<h5 id="1-自定义调度源"><a href="#1-自定义调度源" class="headerlink" title="1.自定义调度源"></a>1.自定义调度源</h5><p><code>dispatch_source_create</code>创建一个调度源来监视低级系统事件。有4个参数，第一个为<code>dispatch_source_type_t</code>类型，是一个结构体常量指针，用来定义调度源的类型，也就是调度源监视的低级系统对象类型的标识符，需要根据这个参数来确定第二个和第三个参数的解释方式。第二个参数为<code>uintptr_t</code>即<code>unsigned long</code>类型的要监视的底层系统句柄，这个值的设定是根据第一个参数来确定的，通过一个参数来确定这个参数是作为文件描述符、mach端口、信号数，还是进程标识符等，第三个参数为<code>unsigned long</code>类型的事件所需的标志掩码，这个值的设定也是根据第一个参数来确定的，系统提供了这个值的固定参数，第四个参数为监听到指定事件时调用的处理事件所要提交到的队列。返回值为<code>dispatch_source_t</code>类型的调度源。调度源是在非活动状态下创建的。上一篇文章中我们介绍到<code>dispatch_resume</code>与<code>dispatch_suspend</code>应该匹配使用，成对出现，否则会引发崩溃，但是有一个例外，就是这里的调度源，在官方对<code>dispatch_resume</code>的介绍中，说到新创建的调度源挂起计数为1，必须要在事件传递前将其恢复。而在官方对<code>dispatch_source_create</code>的说明中说到，出于向后兼容的原因，<code>dispatch_resume</code>在一个非活动的、而不是挂起的源上，与<code>dispatch_activate</code>的作用相同。所以我们也姑且称之为“非活动状态”。官方建议在调度源中使用<code>dispatch_activate</code>来激活调度源。</p>
<p><img src="/content/d04bd655/20191224_01.png" alt></p>
<p>2.<code>dispatch_source_merge_data</code>将数据合并到<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>或<code>DISPATCH_SOURCE_TYPE_DATA_OR</code>类型的调度源中，并将其事件处理程序提交到目标队列。两个参数，第一个为调度源，第二个参数为<code>unsigned long</code>类型，是要提交的数据，不能为0，为0不会出发提交事件处理程序块，也不能为负数。</p>
<p><code>dispatch_source_set_event_handler</code>为给定的调度源设置事件处理程序块。有两个参数，第一个为目标调度源，第二个为要执行的程序块。此方法是设置要提交到目标调度源中指定的队列的程序块。同一时间只能有一个任务块被执行，如果当另一次提交事件发生时，当前程序块还没有执行完毕，则会以指定的方式(创建调度源时指定的<code>ADD</code>或<code>OR</code>)进行积累合并，有效解决了频繁提交带来的处理事件的压力。</p>
<p><code>dispatch_source_get_data</code>返回调度源的待处理数据，有一个参数为调度源。此方法应在事件处理程序块中调用(也就是<code>dispatch_source_set_event_handler</code>中)，在事件处理程序回调之外调用此函数结果是不确定的。通过此方法可以获取调度源中的当前值，并将数据清零。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_activate(source);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="number">5</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(size_t index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_source_merge_data(source, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span></pre></td></tr></table></figure>

<p>上面的代码，自定义一个并发队列<code>c_queue</code>，作为定义调度源的使用队列，通过<code>dispatch_source_set_event_handler</code>设置处理事件的程序块，然后激活调度源。然后通过5次迭代将数据<code>1</code>提交到调度源，因为事件提交是连续发生的，程序块还没有执行完毕，会以<code>ADD</code>的方式对数据进行合并，最后输出。如果当提交合并时，程序块已执行完毕，则不会以<code>ADD</code>方式进行合并。</p>
<p>以下验证代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t source;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(<span class="keyword">self</span>.source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_activate(<span class="keyword">self</span>.source);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_source_merge_data(<span class="keyword">self</span>.source, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>此时我们点击屏幕，可以输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr></table></figure>

<p>再次验证，未执行完毕，进行合并，修改代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">2</span>); <span class="comment">//添加睡眠，模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(<span class="keyword">self</span>.source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>此时我们连续点击屏幕5次，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr></table></figure>

<p>因为第一次点击要耗时2秒后执行完毕，而点击是在短时间内完成的，所以第一次事件没有执行完毕，后面点击会被系统优化合并。</p>
<h5 id="2-定时器源"><a href="#2-定时器源" class="headerlink" title="2.定时器源"></a>2.定时器源</h5><p><code>dispatch_source_set_timer</code>设置计时器源的开始时间，间隔和回程值。4个参数，第一个为调度源，第二个为<code>dispatch_time_t</code>类型的开始时间，第三个为时间间隔，单位为纳秒，第四个为设置计时精度，单位为纳秒，如果希望很精确(相对来说，没有绝对的精确)，则设置为0，即使设为0，计时器也会有一定的等待时间，如果对精确度要求不高，可以设置为能接受的延迟时间。精确度越低对系统的执行灵活性越高(即系统可以根据延迟时间来配合系统事件执行，延迟时间允许的情况会与其他需要执行的事件一起唤醒执行，而非单单为了计时器单独执行)。</p>
<p>定时器源是有一个掩码值的，为<code>DISPATCH_TIMER_STRICT</code>，但是不建议使用，一般时候使用0就可以，除非对时间的精确度非常高。这个掩码指定<code>dispatch_source_set_timer</code>的延迟参数(leeway)尽最大努力遵守设置的值，设置此标记好，系统会将会应用最小的延迟，也会带来负面影响，比如耗电量大，影响省电技术，应谨慎使用，只有在绝对必要时设置此值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_time_t time_t = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>ull*<span class="built_in">NSEC_PER_SEC</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">uint64_t interval = <span class="number">1</span>ull*<span class="built_in">NSEC_PER_SEC</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_set_timer(source, time_t, interval, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_activate(source); <span class="comment">//dispatch_resume(source);</span></span></pre></td></tr></table></figure>

<p>以上代码实现了一个延迟2秒执行，并每隔一秒调用一次程序块的功能，如不需要重复调用，将时间间隔设置为<code>DISPATCH_TIME_FOREVER</code>即可。对于所提交的队列大家可自行选择，这里只是演示的例子。我们可以使用<code>dispatch_suspend</code>来暂停定时器，要对应有启动/继续定时器的<code>dispatch_resume</code>，也可以使用下面的方法取消定时器。</p>
<p><code>dispatch_source_cancel</code>异步取消调度源，以防止进一步调用其事件处理程序块。一个参数为调度源。注意只能取消未被执行的程序块，已经执行的将继续执行完毕(提交的程序块也有可能未来得及执行)。</p>
<p><code>dispatch_source_set_cancel_handler</code>设置目标调度源的取消处理程序块，一个参数为目标调度源。此方法在执行<code>dispatch_source_cancel</code>，且系统释放对源基础句柄的所有引用且所有已处理程序块执行完毕后被调用。</p>
<h5 id="3、其他方法"><a href="#3、其他方法" class="headerlink" title="3、其他方法"></a>3、其他方法</h5><p><code>dispatch_source_get_mask</code> 返回调度源监视的事件掩码。</p>
<p><code>dispatch_source_testcancel</code>测试目标调度源是否已取消。</p>
<p><code>dispatch_source_get_handle</code>返回与指定调度源相关联的基础系统句柄。</p>
<p><code>dispatch_source_set_registration_handler</code>设置给定调度源的注册处理程序块。</p>
<p><code>Dispatch Source</code>官方地址：<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW13" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW13</a></p>
<h4 id="三、Dispatch-I-O与Dispatch-Data介绍"><a href="#三、Dispatch-I-O与Dispatch-Data介绍" class="headerlink" title="三、Dispatch I/O与Dispatch Data介绍"></a>三、<code>Dispatch I/O</code>与<code>Dispatch Data</code>介绍</h4><p>通过使用<code>Dispatch I/O</code>和<code>Dispatch Data</code>可以将大的文件分割成若干小部分进行读取合并。</p>
<p><code>dispatch_io_create</code>创建一个I/O通道，并将其与指定的文件描述相关联。</p>
<p><code>dispatch_io_create_with_path</code>创建具有关联路径的调度I/O通道。</p>
<p><code>dispatch_io_read</code>在指定的通道上调用异步读取操作。</p>
<p><code>dispatch_io_write</code>在指定的通道上调用异步写操作。</p>
<p><code>dispatch_io_close</code>关闭指定的通道以进行新的读写操作。</p>
<p><code>dispatch_io_set_high_water</code>设置在排队处理程序块之前要处理的最大字节数。</p>
<p><code>dispatch_io_set_low_water</code>设置入队处理程序块之前要处理的最小字节数。</p>
<p><code>dispatch_io_set_interval</code>设置间隔，单位为纳秒，在该间隔处调用通道的I/O处理程序。</p>
<p><code>dispatch_read</code>  使用指定的文件描述符调度异步读取操作。</p>
<p><code>dispatch_write</code> 使用指定的文件描述符调度异步写入操作。</p>
<p>调度数据对象提供了一个用于管理基于内存的数据缓冲区的接口。客户端访问数据缓冲区将其视为连续的内存块，但是在内部缓冲区可能由多个不连续的内存块组成。</p>
<p><code>dispatch_data_create</code>使用指定的内存缓冲区创建一个新的调度数据对象。</p>
<p><code>dispatch_data_get_size</code>返回由调度数据对象管理的内存逻辑大小。</p>
<p><code>dispatch_data_create_map</code>返回一个新的调度数据对象，其中包含指定对象内存的连续表示形式。</p>
<p><code>dispatch_data_create_concat</code>返回一个新的调度数据对象，该对象由来自其他两个数据对象的串联数据组成。</p>
<p><code>dispatch_data_create_subrange</code>返回一个新的调度数据对象，其内容由另一个对象的内存区域的一部分组成。</p>
<p><code>dispatch_data_apply</code>遍历调度数据对象的内存，并在每个区域上执行自定义代码。</p>
<p><code>dispatch_data_copy_region</code>返回一个数据对象，该数据对象包含另一个数据对象中的一部分数据。</p>
<p>关于剩下这些内容，来日再更新。。。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>gcd</tag>
        <tag>队列</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]GCD的使用精解(二)</title>
    <url>/content/aeb8f67e.html</url>
    <content><![CDATA[<h4 id="一、dispatch-after"><a href="#一、dispatch-after" class="headerlink" title="一、dispatch_after"></a>一、<code>dispatch_after</code></h4><p>这个方法是指定一个时间，然后一直等待，等到指定的时间后，将块(<code>block</code>)异步提交到指定队列中。注意字眼，是指定时间提交到队列，而非指定时间执行，具体执行情况与队列的调度等有关，如遇到阻塞等情况会延时。所以这个方法最理想，也就是最快的情况是提交后马上执行。所以如果要求精确时间执行，此方法并不适用，而是适用于大致时间执行的时候。</p>
<a id="more"></a>

<p>看下具体的使用代码，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建方式1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>ull*<span class="built_in">NSEC_PER_SEC</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_after(time, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建方式2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>两种创建方式，其实都是一样的。共有三个参数，第一个是<code>dispatch_time_t</code>类型的延迟时间，第二个参数是要提交到的队列，第三个是要执行的代码块。</p>
<p>比如上面的代码，就是从现在(当前时间)开始，延迟2秒执行，也就是2秒后执行(将块提交到队列)。</p>
<p><code>dispatch_time</code>方法返回的是一个<code>dispatch_time_t</code>类型的数据，是一个<code>unsigned long long</code>类的数据。<code>2ull</code>表示的就是<code>unsigned long long</code>类型的<code>2</code>，<code>uul</code>是c语言中的数值字面量，是显示表名类型时使用的字符串。 <code>NSEC_PER_SEC</code>是系统提供的常量值，表示一秒的纳秒(毫微)数，具体时间关系如下：</p>
<blockquote>
<p>1秒(s) =1000 毫秒(ms) = 1,000,000 微秒(μs) = 1,000,000,000 纳秒(ns) = 1,000,000,000,000 皮秒(ps)=1,000,000,000,000,000飞秒(fs)=1,000,000,000,000,000,000仄秒(zs) =1,000,000,000,000,,000,000,000幺秒(ys)1,000,000,000,000,000,000,000,000渺秒(as)</p>
</blockquote>
<p>系统提供了以下几个常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一秒中的毫微秒数</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define NSEC_PER_SEC 1000000000ull</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一秒中的毫秒数</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define NSEC_PER_MSEC 1000000ull</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一秒中的微秒数</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define USEC_PER_SEC 1000000ull</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一微秒中的纳秒数。</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define NSEC_PER_USEC 1000ull</span></pre></td></tr></table></figure>

<p>上面创建时间使用的是<code>dispatch_time</code>，它使用的是相对时间的创建方式，还有一个以绝对时间方式创建的方法<code>dispatch_walltime</code>，当<code>dispatch_time</code>的第一个参数为<code>DISPATCH_WALLTIME_NOW</code>时，等价于<code>dispatch_walltime</code>第一个参数为<code>NULL</code>时创建的时间。</p>
<p><code>dispatch_walltime</code>有两个参数，第一个为<code>struct timespec</code>的结构体，第二个为<code>int64_t</code>类型的延迟时间。<br><code>timespec</code>结构体中有两个变量，一个是<code>tv_sec</code>为整秒数，一个是<code>tv_nsec</code>为纳秒数。比如我们要在未来的某一时间执行，也可以通过下面的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> timespec s_time;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> second, decimals;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSDate</span> * date = [[<span class="built_in">NSDate</span> date] dateByAddingTimeInterval:<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimeInterval</span> timeInterval = [date timeIntervalSince1970];;</span></pre></td></tr><tr><td class="code"><pre><span class="line">decimals = modf(timeInterval, &amp;second);</span></pre></td></tr><tr><td class="code"><pre><span class="line">s_time.tv_sec = second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">s_time.tv_nsec = decimals * <span class="built_in">NSEC_PER_SEC</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_walltime(&amp;s_time, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_after(time, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>以上代码实现了从当前时间开始2秒后执行，<code>double modf(double, double*)</code>函数返回浮点数的小数部分，整数部分放在指针<code>double *</code>中。</p>
<p>两种方法的时间原理是不一样的，第一种是从现在开始多少秒后执行，第二种是定义了未来的一个时间点，到时间执行。</p>
<h4 id="二、dispatch-once"><a href="#二、dispatch-once" class="headerlink" title="二、dispatch_once"></a>二、<code>dispatch_once</code></h4><p>在应用程序的声明周期内，只执行一次块对象。此方法有两个参数，第一个参数为指向<code>dispatch_once_t</code>类型的指针，第二个为要执行一次的代码块对象。</p>
<p><code>dispatch_once_t</code>是专门为<code>dispatch_once</code>方法提供的参数类型，作为只执行一次的标记使用，所以必须定义在全局或静态作用域中。</p>
<p>使用方式如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行性一次的代码"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>dispatch_once</code>经常在创建单例的时候使用，我们经常使用以下方式创建单例，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> SomeClass * shareClass = <span class="literal">nil</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!shareClass)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shareClass = [[SomeClass alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> shareClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为了保证线程安全，我们还需要加锁，如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> SomeClass * shareClass = <span class="literal">nil</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!shareClass)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            shareClass = [[SomeClass alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> shareClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样就增加了方法执行的开销，而使用<code>dispatch_once</code>方法是提供线程安全的，从多个线程同时调用时，此方法将同步等待，直到代码块执行完毕。</p>
<p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> SomeClass * shareClass = <span class="literal">nil</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shareClass = [[SomeClass alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> shareClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>两种创建单例的方式，使用<code>dispatch_once</code>将更高效，它使用“原子访问(atomic access)”来查询标记，来判断对应的代码块是否执行过。而<code>@synchronized</code>隐式添加额外的异常处理等，增加了开销。代码中应避免大量使用<code>@synchronized</code>。</p>
<h4 id="三、dispatch-set-target-queue"><a href="#三、dispatch-set-target-queue" class="headerlink" title="三、dispatch_set_target_queue"></a>三、<code>dispatch_set_target_queue</code></h4><p>设置给定对象的目标队列。为指定对象设置一个目标队列，有两种用途，改变给定对象的优先级和合并多个串行队列。<br>第一个参数为给定队列，第二个为目标队列。</p>
<h5 id="1-改变队列优先级"><a href="#1-改变队列优先级" class="headerlink" title="1.改变队列优先级"></a>1.改变队列优先级</h5><p><code>dispatch_get_global_queue</code>方法是直接能设置优先级的，而我们自定义的队列是不能设置优先级的，它默认的优先级就是<code>dispatch_get_global_queue</code>的默认优先级，即<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。既然要改变给定队列的优先级，就可以将<code>dispatch_get_global_queue</code>作为目标队列，通过<code>dispatch_get_global_queue</code>的优先级设置来改变自定义队列的优先级。看如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gh_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gl_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue, gh_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(gl_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"低优先级1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(gl_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"低优先级2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(gl_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"低优先级3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">高优先级<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">高优先级<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">高优先级<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">低优先级<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">低优先级<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">低优先级<span class="number">2</span></span></pre></td></tr></table></figure>

<p>我们定义的是并发队列，所以输出的顺序不定，但是高优先级的输出会先输出。</p>
<p>但是需要注意的是，这个优先级除非相差很多，比如一个高一个低或者后台，这样效果会很明显，如果相差不多，比如<code>DISPATCH_QUEUE_PRIORITY_HIGH</code>和<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>，输出结果就会不定，也许高先输出，也许低先输出，所以说，对于优先级的设置只是一个衡量值，只是一个大致的判断，并不是每次都按照优先级的设置执行。</p>
<p>通过上面的方法我们将自定义队列设置成高或默认优先级，当同样定义一个串行队列(<code>Serial Dispatch Queue</code>) 时与主队列做对比发现，当自定义队列优先级设置为<code>DISPATCH_QUEUE_PRIORITY_HIGH</code>或<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>时，几乎每次都是比主队列先输出，所以可以说主队列的优先级还是比较低的(测试判断、猜测)。</p>
<p>当我们试图改变主队列优先级时发现，无论主队列优先级设置成高低，对结果的输出都没有任何影响，结果依然遵循上一条的规律，所以似乎可以得出结论，主队列的优先级是无法更改的，这里的代码比较简单，这里不多做说明，大家可以自己试试。</p>
<h5 id="2-合并多个串行多列为一个队列"><a href="#2-合并多个串行多列为一个队列" class="headerlink" title="2.合并多个串行多列为一个队列"></a>2.合并多个串行多列为一个队列</h5><p>我们实现并发有多重途径，使用并发队列并异步执行，也可以创建多个串行队列达到并发的目的。但是创建多个串行队列会创建多个线程，增加了系统的开销，如果想将多个串行队列归并为一个串行队列就可以用到<code>dispatch_set_target_queue</code>方法，代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue1 = dispatch_queue_create(<span class="string">"com.mwpush1"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue2 = dispatch_queue_create(<span class="string">"com.mwpush2"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue3 = dispatch_queue_create(<span class="string">"com.mwpush3"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> t_queue  = dispatch_queue_create(<span class="string">"com.mwpusht"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue1, t_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue2, t_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue3, t_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(t_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"目标队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue1, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue2, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue3, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">目标队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">串行队列<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">串行队列<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">串行队列<span class="number">3</span></span></pre></td></tr></table></figure>

<p>因为是串行队列，输出顺序就是按照添加的顺序输出的，先进先出，这里要注意参数的顺序，第二个参数为目标队列，设置错误也会正常运行，但是达不到想要的目的。如果是并发队列则没有任何意义，添加后仍然是并发，并没有任何影响。</p>
<p>也要注意不要讲A设置为B的目标队列，而又把B设置为A的目标队列，这是错误的做法，不会有任何输出。</p>
<h4 id="四、dispatch-apply"><a href="#四、dispatch-apply" class="headerlink" title="四、dispatch_apply"></a>四、<code>dispatch_apply</code></h4><p>此方法主要用于将一个块提交到调度队列进行多次调用。为同步方法，会等任务块迭代执行完毕返回。如果目标队列为串行队列，则块任务顺序执行，如果为并发队列，则并发执行，顺序不定。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1-%zu"</span>, index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并发队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1-%zu"</span>, index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr></table></figure>

<p>当队列为并发队列时，会为任务创建多个线程并发执行，来提高执行效率。</p>
<p>由于<code>dispatch_apply</code>方法为同步方法，会阻塞线程，所以使用时，如非同步要求，应将其添加到异步方法<code>dispatch_async</code>中执行。</p>
<h4 id="五、dispatch-suspend与dispatch-resume"><a href="#五、dispatch-suspend与dispatch-resume" class="headerlink" title="五、dispatch_suspend与dispatch_resume"></a>五、<code>dispatch_suspend</code>与<code>dispatch_resume</code></h4><p><code>dispatch_suspend</code>挂起(暂停)调度对象上块的调用，参数为要挂起的调度队列或调度源，不能挂起其他类型的调度对象。</p>
<p><code>dispatch_resume</code>恢复调度对象上块的调用，参数为要恢复的对象。</p>
<p><code>dispatch_suspend</code>和<code>dispatch_resume</code>使用的是类似引用计数的方式，挂起一次意味着计数加一，恢复一次意味着计数减一，当计数大于零时，对象保持挂起状态，所以使用时，应匹配<code>dispatch_suspend</code>与<code>dispatch_resume</code>的调用来达到平衡。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"挂起队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_suspend(c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"恢复队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_resume(c_queue);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">挂起队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//下面输出为2秒后队列恢复执行后输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">恢复队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr></table></figure>

<p>注意，挂起队列只能挂起还没有执行的任务，已经执行或正在执行的任务无法挂起。<code>dispatch_suspend</code>与<code>dispatch_resume</code>要成对出现，否则会引起崩溃。</p>
<p>全局并发队列<code>dispatch_get_global_queue</code>和主队列<code>dispatch_get_main_queue</code>中是无法使用<code>dispatch_suspend</code>、<code>dispatch_resume</code>的(使用后不起任何效果)。</p>
<h4 id="六、dispatch-queue-set-specific与dispatch-get-specific"><a href="#六、dispatch-queue-set-specific与dispatch-get-specific" class="headerlink" title="六、dispatch_queue_set_specific与dispatch_get_specific"></a>六、<code>dispatch_queue_set_specific</code>与<code>dispatch_get_specific</code></h4><p><code>dispatch_queue_set_specific</code>用来设置指定队列的键值数据。有4个参数，第一个是<code>dispatch_queue_t</code>类型定义的队列，也就是要添加键值的队列，第二个是<code>const void *</code>类型的键，通过键来查找值时是通过指针的值来做比较的，可以使用静态变量的指针或其他可以唯一标识该值的值。第三个是<code>void *</code>类型键对应的值，第四个是<code>dispatch_function_t</code>类型的析构函数，用来释放上下文数据，可为空(<code>NULL</code>)，当键对应的值使用ARC不能管理内存方式的参数时，在此释放。</p>
<p><code>dispatch_queue_get_specific</code>获取与指定队列关联的键的值。有两个参数，第一个是<code>dispatch_queue_t</code>类型，第二个是<code>const void *</code>类型的键。</p>
<p><code>dispatch_get_specific</code>返回与当前队列相关联的键的值。有一个参数，为<code>const void *</code>类型的键。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * kQueueAKey = <span class="string">"s_queueA"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * kQueueBKey = <span class="string">"s_queueB"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queueA = dispatch_queue_create(<span class="string">"com.mwpushA"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queueB = dispatch_queue_create(<span class="string">"com.mwpushB"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_queue_set_specific(s_queueA, kQueueAKey, kQueueAKey, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_queue_set_specific(s_queueB, kQueueBKey, kQueueBKey, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queueA, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    __block <span class="keyword">char</span> * specificAValue = dispatch_get_specific(kQueueAKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * specificGetAValue = dispatch_queue_get_specific(s_queueA, kQueueAKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * specificGetBValue = dispatch_queue_get_specific(s_queueB, kQueueBKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A队列键对应的值%s"</span>,specificGetAValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"B队列键对应的值%s"</span>,specificGetBValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(specificAValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"获取A队列，值非空，证明是A队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"获取A队列，值为空，则不是A的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(s_queueB, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        specificAValue = dispatch_get_specific(kQueueAKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(specificAValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"获取A队列，值非空，证明是A队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">char</span> * specificGetBValue = dispatch_queue_get_specific(s_queueB, kQue</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(specificGetBValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"获取B队列，值非空，证明是B队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"获取B队列，值为空，则不是B的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> * specificGetAValue = dispatch_queue_get_specific(s_queueA, kQueueAK</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> * specificGetBValue = dispatch_queue_get_specific(s_queueB, kQueueBK</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"A队列键对应的值%s"</span>,specificGetAValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"B队列键对应的值%s"</span>,specificGetBValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">A队列键对应的值s_queueA</span></pre></td></tr><tr><td class="code"><pre><span class="line">B队列键对应的值s_queueB</span></pre></td></tr><tr><td class="code"><pre><span class="line">获取A队列，值非空，证明是A队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">获取B队列，值非空，证明是B队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">A队列键对应的值s_queueA</span></pre></td></tr><tr><td class="code"><pre><span class="line">B队列键对应的值s_queueB</span></pre></td></tr></table></figure>

<p>总结：<code>dispatch_queue_get_specific</code>是根据键查找指定队列的对应的值，只要定义过，在后续执行中在哪都能输出，无论是否在当前队列。而<code>dispatch_get_specific</code>只有所在的是当前队列时，才会输出队列的值，否则为空。</p>
<p>参数设置的其他方式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> kQueneKey;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">CFStringRef</span> value = <span class="built_in">CFSTR</span>(<span class="string">"s_queue"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_queue_set_specific(s_queue, &amp;kQueneKey, (<span class="keyword">void</span> *)value, (dispatch_function_t)<span class="built_in">CFRelease</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFStringRef</span> specificGetValue = dispatch_queue_get_specific(s_queue, &amp;kQueneKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"队列键对应的值%@"</span>,specificGetValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFStringRef</span> specificValue = dispatch_get_specific(&amp;kQueneKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(specificValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"值非空，证明是获取的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"值为空，则不是想获取的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>dispatch_get_current_queue</code>在 iOS 6.0以后已废弃，它会引发一系列问题，而且返回的值有时也不是很准，只能用在代码调试阶段，不能用于<code>Release</code>版本。在<code>Release</code>版本中可以使用上述方法。</p>
<h4 id="七、dispatch-queue-get-label"><a href="#七、dispatch-queue-get-label" class="headerlink" title="七、dispatch_queue_get_label"></a>七、<code>dispatch_queue_get_label</code></h4><p>返回目标队列的标签，参数为目标队列，返回值为<code>const char *</code>类型的标签名字符串。如未设置标签则返回<code>NULL</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * labelName = dispatch_queue_get_label(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, labelName);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">com<span class="variable">.mwpush</span></span></pre></td></tr></table></figure>



<h4 id="八、dispatch-set-context与dispatch-get-context"><a href="#八、dispatch-set-context与dispatch-get-context" class="headerlink" title="八、dispatch_set_context与dispatch_get_context"></a>八、<code>dispatch_set_context</code>与<code>dispatch_get_context</code></h4><p>将自定义的上下文与目标对象关联，需根据需要分配和取消数据分配。比如<code>malloc</code>出来的数据就要有对应的<code>free</code>，<code>new</code>出来的就得<code>delete</code>。</p>
<p><code>dispatch_set_context</code>有两个参数，第一个参数为<code>dispatch_object_t</code>类型的目标对象，第二个参数为<code>const void *</code>类型的上下文。</p>
<p><code>dispatch_get_context</code>获取上下文数据，一个参数，为<code>dispatch_object_t</code>类型对象。</p>
<p><code>dispatch_set_finalizer_f</code>终结器方法，用来调用在对应队列上下文中开辟的内存等的清理方法。两个参数，第一个为目标队列，第二个为<code>dispatch_function_t</code>类型函数指针。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_context(s_queue, <span class="string">"www.mwpush.com"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * mycontext = dispatch_get_context(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, mycontext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">www<span class="variable">.mwpush</span><span class="variable">.com</span></span></pre></td></tr></table></figure>

<p>上面我们只是简单的设置了一个字符串常量，没有涉及到动态开辟内存的问题，如果涉及则需要手动处理，以下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Person &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; Student;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> cleanData(<span class="keyword">void</span> *context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="built_in">NSLog</span>(<span class="string">@"清理释放"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    free(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setContextData &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student * student = (Student *)malloc(<span class="keyword">sizeof</span>(Student));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    student-&gt;name = <span class="string">"zhangsan"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    student-&gt;age = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_context(s_queue, student);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_finalizer_f(s_queue, &amp;cleanData);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Student * myStudent = dispatch_get_context(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, myStudent-&gt;name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">zhangsan</span></pre></td></tr><tr><td class="code"><pre><span class="line">清理释放</span></pre></td></tr></table></figure>

<p>如果上下文为<code>Foundation</code>对象，因为参数为<code>void *</code>类型，需要做桥接处理，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person类代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//实现代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了dealloc"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>调用处理代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> cleanData(<span class="keyword">void</span> *context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"清理释放"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFRelease</span>(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setContextData &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person *person = [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.name = <span class="string">@"zhangsan"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.age = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_context(s_queue, (__bridge_retained <span class="keyword">void</span> *)person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_finalizer_f(s_queue, &amp;cleanData);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person * myPerson = (__bridge Person *)dispatch_get_context(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, myPerson.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">zhangsan</span></pre></td></tr><tr><td class="code"><pre><span class="line">清理释放</span></pre></td></tr><tr><td class="code"><pre><span class="line">调用了dealloc</span></pre></td></tr></table></figure>



<h4 id="九、dispatch-barrier-async与dispatch-barrier-sync"><a href="#九、dispatch-barrier-async与dispatch-barrier-sync" class="headerlink" title="九、dispatch_barrier_async与dispatch_barrier_sync"></a>九、<code>dispatch_barrier_async</code>与<code>dispatch_barrier_sync</code></h4><p><code>dispatch_barrier_async</code>提交一个异步执行的障碍(也有叫栅栏)块到目标队列，并立即返回。有两个参数，第一个是目标队列，第二个是要提交到目标队列的障碍块。此方法需与自定义的并发队列一起使用才能发挥出其特有的效果。与自定义的并发队列(通过<code>dispatch_queue_create</code>创建出的<code>Concurrent Dispatch</code>)一起使用时，<code>barrier</code>提交的块不会与该队列上的其他块同时运行。它会等待它插入位置之前的块执行完成(当前执行的所有操作)，然后执行提交的障碍块并阻塞队列上的待执行内容，等障碍块执行完毕，继续执行后续操作。如果<code>barrier</code>提交的块不是与自定义的并发队列一起使用，则功能类似于<code>dispatch_async</code>。</p>
<p><code>dispatch_barrier_sync</code>提交一个同步执行的障碍块到目标队列，并等待该块执行完毕。有两个参数，第一个是目标队列，第二个是要提交到目标队列的障碍块。此方法也同样需要与自定义的并发队列一起使用，此时会等待其块任务插入之前的任务执行完毕然后执行，并阻塞队列上的执行内容，且阻塞<code>dispatch_barrier_sync</code>方法所在的线程。如果与<code>dispatch_get_global_queue</code>或串行队列(包括主队列与自定义串行队列)一起使用，则相当于<code>dispatch_sync</code>。注意，因为是同步方法，所以当其目标队列与当前所在队列为同一队列时，将造成死锁，关于这个可以看 <a href="http://www.mwpush.com/content/d771b58d.html">GCD的使用精解(-)</a> 中对死锁的说明。</p>
<p>关于<code>dispatch_barrier_sync</code>的代码这里就不在写了，需要说明的是，当与<code>dispatch_get_global_queue</code>一起使用时，<code>barrier</code>提交块任务不能保证当其执行时，其前序任务都已执行完毕，有可能先执行<code>barrier</code>提交的块任务。</p>
<p><code>dispatch_barrier_async</code> 示例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_barrier_async(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"循环任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"其他任务"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">其他任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以下为barrier循环执行完毕后，延迟2秒输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr></table></figure>

<p>通过输出可以看出，<code>dispatch_barrier_async</code>并不阻塞主线程任务的执行，只是阻塞目标队列的后续块任务，待其执行完毕，后续任务按原始执行操作继续执行。</p>
<p>当其与<code>dispatch_get_global_queue</code>或串行队列(包括主队列与自定义串行队列)一起使用时，功能与<code>dispatch_async</code>相同。全局并发队列属于共享资源，不允许单个组件对其进行阻塞(说的是队列阻塞，而非线程)。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>gcd</tag>
        <tag>队列</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]GCD的使用精解(-)</title>
    <url>/content/d771b58d.html</url>
    <content><![CDATA[<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p><code>GCD(Grand Central Dispatch)</code>，大中枢派发，是一套基于C语言的多线程开发框架，它提供了一个易用的抽象层，使开发者不需要处理底层的线程管理就可以充分利用系统的多核特性，可以自动平衡系统资源分配方式，提高系统资源的利用率，是异步执行任务的技术之一。                                                                          </p>
<p><code>GCD API</code>的核心概念是调度队列，对线程的操作实际上是由调度队列完成的，开发者只需将任务添加到调度队列即可，系统负责线程的创建、管理，提交给调度队列的任务会在完全受系统管理的线程池上执行。因为线程的管理由系统执行，系统会根据系统占用资源相对合理分配资源，比传统的线程提高了效率。</p>
<a id="more"></a>

<h4 id="二、Dispatch-Queue-派发队列"><a href="#二、Dispatch-Queue-派发队列" class="headerlink" title="二、Dispatch Queue 派发队列"></a>二、<code>Dispatch Queue</code> 派发队列</h4><h5 id="1-主队列"><a href="#1-主队列" class="headerlink" title="1.主队列"></a>1.主队列</h5><p>主队列任务在主线程中执行，会阻塞主线程，是一个串行队列，可以通过以下方式获取，代码(1-1)，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_queue_main_t m_queue = dispatch_get_main_queue();</span></pre></td></tr></table></figure>
<p>PS：主队列是在调用<code>main</code>函数之前由系统自动创建的，并将其与程序的主线程相关联。由于主队列运行在应用程序的主线程上，因此通常用作应用程序的关键同步点。</p>
<h5 id="2-全局并发队列"><a href="#2-全局并发队列" class="headerlink" title="2.全局并发队列"></a>2.全局并发队列</h5><p>共享当前进程资源，提交到此队列的任务是无序的并发执行。获取方式代码(1-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_queue_global_t g_queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr></table></figure>

<p>第一个参数为执行的优先级，定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最高优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//中等优先级，为默认优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//低优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//后台优先级，级别最低</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span></pre></td></tr></table></figure>

<p>现在优先级已被服务质量QOS(quality of service)所取代，服务质量可用于<code>GCD</code>和<code>NSOperation</code>，且苹果建议最好用Qos来代替全局并发优先级。服务质量对应优先级代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span></pre></td></tr></table></figure>

<p>PS：设置优先级并不能保证执行的实时性，只是大致的判断。</p>
<p>第二个为系统保留参数，可传入<code>NULL</code>或0。</p>
<h5 id="3-自定义队列"><a href="#3-自定义队列" class="headerlink" title="3.自定义队列"></a>3.自定义队列</h5><p>自定义派发队列有两种，<code>Serial Dispatch Queue</code>串行队列，<code>Concurrent Dispatch Queue</code>并发队列。串行队列需要一个执行结束，才能继续执行下一个任务。</p>
<p>并发队列则不需要等待，按FIFO入队后无需等待前一个任务执行完毕在执行，而是入队后便开始执行，并发队列中的任务可以同时运行。无论串行还有并发队列，都严格按照FIFO顺序进队出队。</p>
<p>自定义队列的创建方式代码(1-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_SERIAL);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//并发队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush.www"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr></table></figure>
<p>第一个参数为队列的名称，一般命名方式为域名倒叙，也可以不命名，传入<code>NULL</code>，但是命名对于调式查找非常有帮助。</p>
<p>第二个参数为队列属性，即串行或并发。当为串行时，可直接传入<code>NULL</code>，并发时则需传入<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<h4 id="三、派发任务到队列并执行"><a href="#三、派发任务到队列并执行" class="headerlink" title="三、派发任务到队列并执行"></a>三、派发任务到队列并执行</h4><p>任务分为两种，<code>dispatch_sync</code>同步派发与<code>dispatch_async</code>异步派发，这两种均是针对所在线程而言。</p>
<p>同步派发(<code>dispatch_sync</code>)，直到任务完成后才返回，会阻塞当前线程。当同步派发后并不意味着立即执行，执行时机由调度队列选择。使用同步派发时，需谨慎使用，在串行队列中派发同步任务容易造成死锁。</p>
<p>异步派发(<code>dispatch_async</code>)，函数会立即返回，函数任务将在后台执行并在未来某个时机完成。</p>
<h5 id="1-同步串行队列"><a href="#1-同步串行队列" class="headerlink" title="1.同步串行队列"></a>1.同步串行队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);      </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>  输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">1</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">2</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">3</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">4</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>串行队列同步执行，并且没有开辟新的线程，都在主线程执行，且顺序执行。</p>
<h5 id="2-同步并发队列"><a href="#2-同步并发队列" class="headerlink" title="2.同步并发队列"></a>2.同步并发队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">1</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">2</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">3</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">4</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>并发队列同步执行，没有开辟新的线程，在主线程执行，顺序输出。</p>
<h5 id="3-异步串行队列"><a href="#3-异步串行队列" class="headerlink" title="3.异步串行队列"></a>3.异步串行队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p> 输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">1</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">2</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">3</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">4</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>串行队列异步执行时，开辟了新线程(主线程除外)，但是注意：串行队列只保证同一时间只有一个任务在被调用执行，是一个任务执行完毕下一个任务出队执行，但是不一定都在同一条线程执行，只是同一时间对于当前串行队列只分配了一条线程，但是具体是哪条线程，由系统控制。所以这里的线程输出是有不确定性的，不一定每条都一样，比如第一次分配线程2，下次出队执行时，线程2被其他任务占用，此时就会分配线程3或线程4等等不定的线程！</p>
<h5 id="4-异步并发队列"><a href="#4-异步并发队列" class="headerlink" title="4.异步并发队列"></a>4.异步并发队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;       </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>   输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">3</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x100796f10&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">2</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102800410&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">1</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x100520ad0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">4</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1028001f0&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>并发队列异步执行，开辟了多条线程，且任务分别在不同的线程执行，顺序不定。</p>
<h5 id="5-外话"><a href="#5-外话" class="headerlink" title="5.外话"></a>5.外话</h5><p><code>dispatch_sync</code>官网文档有这样一段说明：</p>
<blockquote>
<p>As a performance optimization, this function executes blocks on the current thread whenever possible, with one obvious exception. Specifically, blocks submitted to the main dispatch queue always run on the main thread.</p>
<p><em>作为性能优化，此功能在可能的情况下尽可能在当前线程上执行块，一个明显的例外。具体来说，提交到主调度队列的块始终在主线程上运行。</em></p>
</blockquote>
<p>其不同效果代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交到非主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"提交到非主队列之前-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"提交到非主队列之后-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//提交到主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"提交到主队列之前-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"提交到主队列之后-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">提交到非主队列之前-&lt;NSThread: <span class="number">0</span>x600002942200&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到非主队列之后-&lt;NSThread: <span class="number">0</span>x600002942200&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到主队列之前-&lt;NSThread: <span class="number">0</span>x600002973380&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到主队列之后-&lt;NSThread: <span class="number">0</span>x600002925a80&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>为了便于做对比，我将输出后的顺序调整了粘贴出来，大家的输出顺序应该是不一样的。</p>
<p>可以很明显的区别：提交到非主队列之前和之后所在线程相同，而提交到主队列后执行的线程便是主线程。</p>
<p>此外还有主队列与全局队列，主队列属于串行，全局队列属于并发。主队列在主线程执行，所以通过<code>dispatch_async</code>异步添加到主队列的任务不会开启新的线程，在主队列(串行队列)顺序执行。通过<code>dispatch_sync</code>同步添加到主队列的任务容易造成死锁(不是一定)，下面会讲到。  </p>
<p>总结：<code>dispatch_sync</code>不会开辟新线程， <code>dispatch_async</code>会开辟新线程(添加主队列除外，主队列任务始终在主线程执行)。并发需要多线程的支持，能创建多线程的情况下才能发挥并发的效用。提交给队列的任务，除了主队列在主线程执行之外，系统无法保证其他队列在哪个线程执行。   </p>
<p>在设计并发任务时，也可以使用多个串行队列并行的方式处理，但是不建议这样做，因为这样做会开辟多条线程，每个串行队列都需要一个单独的线程，以此方式来实现并发的目的。总体建议就是无论并发还是串行都尽可能的少通过用户主动创建线程，如有需要可提交任务到全局并发队列实现目的。使用队列处理多任务，系统会根据线程的执行情况分配线程执行，并非一个线程处理一个任务，一个任务处理完成，可以继续处理其他任务，系统会在此做优化使用尽可能少的线程执行更多的任务。因为线程的开销相比队列大的多，所以尽量多使用多列处理任务，由系统分配线程处理。</p>
<p> 在使用时应注意死锁问题。</p>
<p>关于队列相关的说明在另一篇文章有介绍，通过下面链接查看：  </p>
<p><a href="http://www.mwpush.com/content/edab7fec.html">关于串行、并发、并行等的说明</a></p>
<h4 id="三、死锁-deadlock"><a href="#三、死锁-deadlock" class="headerlink" title="三、死锁 (deadlock)"></a>三、死锁 (deadlock)</h4><p>关于<code>GCD</code>中的死锁，网上有很多说明，也看了很多，但是都是看似讲的很有道理却难以让人明白，或者有些根本就是讲的不对，总会扯到一些无所谓的条件上。当然，本人也是貌似懂了，所以说一下这个问题，从一段最基本的代码开始，如下：</p>
   <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行结果如下：</p>
   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">deadlock[<span class="number">71971</span>:<span class="number">7964750</span>] 任务<span class="number">1</span></span></pre></td></tr></table></figure>

<p>附上几张张错误的截图，如下：</p>
<p><img src="/content/d771b58d/20191218_01.png" alt="20191218_01"></p>
<p>   <img src="/content/d771b58d/20191218_02.png" alt="11"></p>
<p>网上很大一部分文章在讲到这段代码的时候总会把这里的任务3，也就是<code>NSLog(@&quot;任务3&quot;);</code>，这部分也扯进去，但是这段代码的错误原因与<code>NSLog(@&quot;任务3&quot;);</code>有与没有根本没有任何关系，删除<code>NSLog(@&quot;任务3&quot;);</code>也是同样的错误。</p>
<p>这段代码只能执行到任务1，我们首先看一下图2中的第一段红色字体部分，内容如下：</p>
   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="string">"BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread"</span></span></pre></td></tr></table></figure>

<p>翻译过来就是：在当前线程已经拥有的队列上调用<code>dispatch_sync</code>。   </p>
<p>那么当前线程是哪个线程呢？我们从图2的调用栈可以看到是<code>Thread 1</code>，也就是主线程，队列就是主队列，而主队列还是个<code>Serial</code>串行队列。   </p>
<p>那么就来看一下<code>dispatch_sync</code>的官方说明，如下：</p>
<blockquote>
<p>Submits a block object for execution and returns after that block finishes executing</p>
<p>//提交block到队列，并等着block执行完毕返回。</p>
<p>Submits a block to the specified dispatch queue for synchronous execution. Unlike <code>dispatch_async</code>, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>
<p>这句主要的是最后一句：调用此方法提交块到当前队列将造成死锁！就是说，如果提交block的目标队列与当前所在的队列是同一队列，将造成死锁。</p>
</blockquote>
<p> 那么来分析下我们的代码造成死锁的原因：</p>
<p>首先主队列是在<code>main</code>方法执行之前就已经由系统创建好了，<code>main</code>函数本身就在主队列中，线程首先调用队列中的<code>main</code>方法开始执行，当执行<code>dispatch_sync</code>方法时，将要执行的任务2(<code>NSLog(@&quot;执行2&quot;);</code>所在的<code>block</code>块)，添加到获取的当前队列的末尾，也就是<code>main</code>的后面，并等待<code>block</code>执行完毕返回。但是串行队列的特性是先进先出(FIFO)，且前一个方法执行完毕之前，后面方法不能执行，需要等待执行，也就是在<code>block</code>之前的<code>main</code>方法还没有还行完毕，就不能执行<code>block</code>，而<code>block</code>又是通过同步方法添加执行的，添加后就需要等待执行，而且还得执行完毕才能返回。这样造成了<code>main</code>想执行，但是需要等待<code>block</code>执行完毕，而<code>block</code>要执行，但是<code>main</code>方法还没有执行完毕，所以不能执行，互相牵制，造成死锁。</p>
<p>用通俗点的话来说就是：<strong>串行队列</strong>中的任务1在执行，任务1要执行的代码就是将任务2添加到任务1所在的队列中<strong>同步执行</strong>，因为是同步添加，就需要等待任务2执行并执行完毕返回结果，任务1才能继续执行。但是此时队列中任务1排在任务2的前面，需要先执行完毕才能执行任务2，而任务2又要任务1等待，所以彼此牵制，都不能执行，造成死锁。</p>
<p>以上是添加到系统的主队列中造成的死锁，下面在来看一下我们手动创建的队列的死锁，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">deadlock[<span class="number">72943</span>:<span class="number">8153590</span>] 任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deadlock[<span class="number">72943</span>:<span class="number">8153590</span>] 任务<span class="number">2</span></span></pre></td></tr></table></figure>

<p>同样是串行队列，为何第一个<code>dispatch_sync</code>没有造成死锁，而第二个就造成了呢？其实就是文档中说的：<em>如果提交block的目标队列与当前所在的队列是同一队列，将造成死锁</em>。因为当执行第一个<code>dispatch_sync</code>时，将任务2添加到我们创建的<code>serial_queue</code>队列中，而此时所在的队列是系统的主队列，添加到的队列与当前所在的队列不是一个队列。而当第二个<code>dispatch_sync</code>执行时，所在的队列就是我们创建的<code>serial_queue</code>队列，目标队列与当前所在队列为同一队列，造成死锁的过程上面已经讲解了。各位可以尝试将第一个<code>dispatch_sync</code>换成<code>dispatch_async</code>等，自己试试结果，这里就不在多说。</p>
<h4 id="四、调度组-Dispatch-Group"><a href="#四、调度组-Dispatch-Group" class="headerlink" title="四、调度组(Dispatch Group)"></a>四、调度组(Dispatch Group)</h4><p>当队列中有多个任务需要处理，且需要根据这些任务的处理结果执行某些操作时，我们可以选择调度组(<code>Dispatch Group</code>)来操作，当然也有其他的实现方式，但是相对来说，使用调度组实现代码整洁且逻辑清晰。当然使用串行队列也能达到目的，但是如果大部分任务之间没有依赖关系，则最好选择并发处理。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"全部任务执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">全部任务执行完毕</span></pre></td></tr></table></figure>

<p>将任务提交到全局并发队列并异步执行，任务1，2，3，4的输出顺序不定，但是最后的“全部任务执行完毕”一定最后输出，也就是等到所有任务都完成后执行。我们可以追加数据分块下载、处理等到调度组，最后在<code>dispatch_group_notify</code>中将执行完毕的所有数据进行统一处理。也可以等数据处理完成到主线程更新UI操作，这个时候需要将<code>dispatch_group_notify</code>中的队列设置为<code>dispatch_get_main_queue()</code>即可。</p>
<p><code>dispatch_group_wait</code>等待方法，看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"其他操作"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">其他操作 <span class="comment">//此处为5秒后输出的</span></span></pre></td></tr></table></figure>

<p>与上面代码不同之处仅在于一个使用了<code>dispatch_group_notify</code>，一个使用了<code>dispatch_group_wait</code>。</p>
<p><code>dispatch_group_wait</code>是一个同步函数，同步意味着等待，阻塞，从名字中就可以看得出来。它的作用是等待，直到与之关联的组中的队列任务全部执行完毕或超过了指定的超时时间继续执行。所以我们在“任务4”中设置了睡眠5秒钟，最后的“其他操作”是过了5秒钟后才执行输出的。</p>
<p><code>dispatch_group_wait</code>第二个参数是设置超时时间，是<code>dispatch_time_t</code>类型，当设置为<code>DISPATCH_TIME_FOREVER</code>时，意味着永久等待，就是等所有任务都执行完毕才继续执行。此时，与<code>dispatch_group_notify</code>相同之处是都会等到任务全部执行完毕做其他操作，不同之处在于<code>dispatch_group_wait</code>会阻塞所在线程，<code>dispatch_group_notify</code>不阻塞线程。所以在主线程中慎用<code>dispatch_group_wait</code>方法。</p>
<p><code>dispatch_group_wait</code>是有返回值的，其返回值类型为<code>long</code>，当所有任务在设置的超时时间内全部完成，返回值为0，否则非零(超时)，也就是说队列中的任务至少还有一个未完成，也许有多个。等待时间设置为<code>DISPATCH_TIME_FOREVER</code>则返回值恒为0，因为永不超时，也就是任务总会前部执行完毕。还有一个为我们准备好的常量<code>DISPATCH_TIME_NOW</code>，将<code>dispatch_group_wait</code>时间参数设置为<code>DISPATCH_TIME_NOW</code>时，则意味着不等待，此时不阻塞线程。除了使用以上两种系统为我们准备好的时间常量，也可以自定义时间，时间类型为<code>dispatch_time_t</code>，关于<code>dispatch_time_t</code>类型的说明请关注下一篇<code>GCD</code>文章。</p>
<p>我们可以将<code>dispatch_group_wait</code>和<code>dispatch_group_notify</code>组合使用，使用<code>dispatch_group_wait</code>时，应放在非主线程，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPAT</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后执行整理任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>以上是通过<code>dispatch_group_async</code>方法提交任务到队列入组后自动执行并完成的，我们也可以通过手动入组执行，通过使用<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>方法，这两个方法只有一个参数，就是要加入的组。两个方法是一对儿的关系，缺一不可，有入就得有出，类似于引用计数，入组就是加一，出组就是减一。如果数量不对应，入比出多，则任务<code>dispatch_group_notify</code>和<code>dispatch_group_wait</code>永远不会执行。如果出比入多，则会报<code>Unbalanced call to dispatch_group_leave()</code>错误，具体看下面的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后执行整理任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>以上是正确的写法，一一对一个，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>通过<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>手动进组出组的任务，就是正常的函数方法，需要根据需要自己执行同步或异步方法，上面的代码为同步方法，所以输出结果为顺序输出。当我们执行异步方法时，<code>dispatch_group_leave</code>要放在异步函数内的方法执行完毕处！如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];  <span class="comment">//模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>这样才能保证任务全部任务执行完毕在执行<code>dispatch_group_notify</code>方法，输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">异步任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>如果放在外面，如下代码，则不能保证所有任务都处理完毕后执行<code>dispatch_group_notify</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];  <span class="comment">//模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步任务</span></pre></td></tr></table></figure>

<p>PS：<code>dispatch_group_enter</code>、<code>dispatch_group_leave</code>、<code>dispatch_group_notify</code>、<code>dispatch_group_wait</code>一起使用的方式跟上面的操作一样，不在赘述。</p>
<p>以上代码都是在同一并发多列中实现的，也可以将不同重要等级的任务提交到不同的队列后入组执行，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gd_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gh_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gd_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"默认优先级的任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gd_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"默认优先级的任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gh_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级的任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gh_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级的任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"到主线程执行所需的操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>当然队列也可以是串行队列，不过使用串行队列执行就没有意义了，任务依然需要一个一个的执行，同一队列任务不能实现并发的目的，可根据具体需要自行选择！</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>gcd</tag>
        <tag>队列</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>关于串行、并发、并行等的说明</title>
    <url>/content/edab7fec.html</url>
    <content><![CDATA[<h4 id="一、概念术语"><a href="#一、概念术语" class="headerlink" title="一、概念术语"></a>一、概念术语</h4><ol>
<li><p>进程 (<code>process</code>)</p>
<p>系统中正在运行的一个程序的实例(即一个正在运行的可执行文件)，具有一定的独立功能，是线程的容器</p>
</li>
</ol>
<ol start="2">
<li><p>线程 (<code>thread</code>)</p>
<p>线程是进程执行的最小单位，一个进程中至少包含一个线程(主线程)，进程中任务都在线程中执行(主线程或子线程)。是代码独立执行的路径。</p>
<a id="more"></a>
</li>
<li><p>任务 (<code>task</code>)</p>
<p>需要执行的工作的抽象概念。</p>
</li>
<li><p>并行 (<code>parallel</code>)</p>
<p>并行是一种使用多种运算硬件(如：多核处理器)，以便更快的执行计算。是两个或多个事件在同一时间发生。目的是将计算机不同的任务委派给同时执行的不同处理器来处理，以便尽早获得结果。比如银行业务，同时开通多个业务窗口来办理业务，每个窗口都可以执行特定的任务，多个窗口可以同时办理业务。</p>
</li>
</ol>
<ol start="5">
<li><p>并发 (<code>concurrent</code>)</p>
<p>是一种程序结构技术，有多个控制线程，是两个或多个事件在同一时间间隔发生。从概念上将，控制线程同时执行，实际上是多个线程之间不断切换以达到多线程执行任务的目的，当然也可以在多个物理处理器上执行。比如银行业务，只开通了一个业务窗口，但是可以排多个队伍到一个窗口办理业务。</p>
</li>
</ol>
<ol start="6">
<li><p>串行 (<code>serial</code>)</p>
<p>多个任务依次执行，当一个任务完成以后继续执行下一个任务。例如A，B，C三个任务，A执行完毕执行B，B执行完毕执行C。比如银行业务，只开通了一个业务窗口，并且只能排一条队伍进行业务办理。</p>
</li>
</ol>
<ol start="7">
<li><p>队列 (<code>queue</code>)</p>
<p>是一种先进先出(FIFO)的线性表。与现实世界中的规则一样，先进入的先办理业务。</p>
</li>
</ol>
<ol start="8">
<li><p>同步 (<code>synchronous</code>)</p>
<p>调用后，等任务完成之后返回的称为同步，同步执行会阻塞线程。</p>
</li>
</ol>
<ol start="9">
<li><p>异步 (<code>asynchronous</code>)</p>
<p>调用后，立即返回的称为异步，异步执行不会阻塞线程。</p>
</li>
</ol>
<ol start="10">
<li><p>串行队列 (<code>serial queue</code>)</p>
<p>按照FIFO原则，出队后将任务移交给线程执行实际工作，后面一个任务需要等待前面一个任务执行完毕在出队移交，依次类推</p>
</li>
</ol>
<ol start="11">
<li><p>并发队列 (<code>concurrent queue</code>)</p>
<p>遵循FIFO原则入队出队，任务出队意味着将任务移交给一个线程，并发不用等待，移交给线程后立刻返回，后一个任务继续出队，移交线程。会因为系统因素与任务复杂度出现不同的执行结果，但出队也是按照先进先出的顺序执行，只是移交给线程后的处理结果不同(开辟多线程才会出现不同的执行结果，单线程依然顺序输出，因为只有一条线程执行任务)。</p>
</li>
</ol>
<h4 id="二、图解说明"><a href="#二、图解说明" class="headerlink" title="二、图解说明"></a>二、图解说明</h4><p>可参照下图理解.</p>
<p>串行，并发，与并行的区别。(图片均摘自网络)</p>
<p><img src="/content/edab7fec/20191216_01.jpg" alt="20191216_01"></p>
<p>串行列队，并发队列的区别。(图片均摘自网络)</p>
<p><img src="/content/edab7fec/20191216_02.jpg" alt="20191216_01"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>串行</tag>
        <tag>并发</tag>
        <tag>并行</tag>
        <tag>serail</tag>
        <tag>coucurrent</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]self与super调用本质分析</title>
    <url>/content/3b516ae7.html</url>
    <content><![CDATA[<h4 id="一、self-基本说明"><a href="#一、self-基本说明" class="headerlink" title="一、self 基本说明"></a>一、self 基本说明</h4><p>在日常开发中，我们经常使用到<code>self</code>关键字，比如，访问属性，调用实例方法等。那么<code>self</code>到底指的是什么？我们来看一下官方文档的解释和定义：</p>
<blockquote>
<p>Returns the receiver.   //返回接收器</p>
</blockquote>
<p>在看一下<code>NSObject</code>中关于<code>self</code>的一些说法：</p>
<a id="more"></a>
<blockquote>
<p>Rather than using <code>[[XYZPerson alloc] init]</code> in the class factory method, instead try using <code>[[self alloc] init]</code>.</p>
<p>Using <code>self</code> in a class factory method means that you’re referring to the class itself.</p>
</blockquote>
<p>在工厂方法中使用<code>self</code>意味着引用类本身，意思就是说<code>self</code>就是当前类，那么再来看一下源码中对<code>self</code>的定义，代码(1-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)<span class="keyword">self</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)<span class="keyword">self</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到<code>self</code>只是返回本身，也就是当前调用者。<font color="red">(PS:调用者并不一定是当前类，继续看下文可明白)</font></p>
<p>因为<code>self</code>是消息机制中的第一个隐藏参数，在消息传递的过程中，本赋值为调用者，也就是消息接收者。第二个隐藏参数为<code>_cmd</code>，也就是<code>SEL</code>，调用的方法。</p>
<h4 id="二、super-基本说明"><a href="#二、super-基本说明" class="headerlink" title="二、super 基本说明"></a>二、super 基本说明</h4><p><code>super</code>关键字，<font color="red">（PS：不知为何大部分文章中都说super不是关键字，关键字的概念就是保留字，很明显super是保留字）</font>也是我们经常看到和使用的。代码(2-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>关于<code>super</code>的说明，本人并没有在官方文档中看到，如果大家有发现请关注本文末尾的公众号，告知本人，将不胜感激。只是在<code>NSObject</code>中有部分说明如下：</p>
<blockquote>
<p>There’s another important keyword available to you in Objective-C, called <code>super</code>. Sending a message to <code>super</code> is a way to call through to a method implementation defined by a superclass further up the inheritance chain. The most common use of <code>super</code> is when overriding a method.</p>
</blockquote>
<p>意思是说，<code>super</code>是一个重要的关键字<font color="red">(这里也有说super是关键字，所以网上很多说法是错误的，大家要自己甄别！)</font>，向<code>super</code>发送消息是调用继承链上的超类方法。<code>super</code>最常见的用法就是覆盖一个方法。</p>
<h4 id="三、探究self和super"><a href="#三、探究self和super" class="headerlink" title="三、探究self和super"></a>三、探究<code>self</code>和<code>super</code></h4><p>首先创建一个基于 Single View App的模板项目，添加<code>Person</code>和<code>Student</code>类，<code>Person</code>类继承于<code>NSObject</code>类，<code>Student</code>类继承于<code>Person</code>类，以备后面使用。下面我们在项目默认创建的<code>ViewController.m</code>类中添加代码(3-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self:%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super:%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>查看输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">demo1[<span class="number">2534</span>:<span class="number">11854005</span>] self:ViewController</span></pre></td></tr><tr><td class="code"><pre><span class="line">demo1[<span class="number">2534</span>:<span class="number">11854005</span>] <span class="keyword">super</span>:ViewController</span></pre></td></tr></table></figure>

<p>我们发现<code>self</code>与<code>super</code>的输出同样是<code>ViewController</code>，也就是当前类。然后我们继续试验，在<code>Person</code>和<code>Student</code>类中分别添加<code>eat</code>方法，代码(3-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)eat &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ eat!"</span>, <span class="keyword">self</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)eat &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> eat];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ eat!"</span>, <span class="keyword">self</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>然后在<code>ViewController.m</code>的<code>ViewDidLoad</code>方法中，创建<code>Student</code>类并调用<code>eat</code>方法，代码(3-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student * student = [[Student alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[student eat];</span></pre></td></tr></table></figure>

<p>运行，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">demo1[<span class="number">2962</span>:<span class="number">11906123</span>] &lt;Student: <span class="number">0</span>x600003fc8100&gt; eat!</span></pre></td></tr><tr><td class="code"><pre><span class="line">demo1[<span class="number">2962</span>:<span class="number">11906123</span>] &lt;Student: <span class="number">0</span>x600003fc8100&gt; eat!</span></pre></td></tr></table></figure>

<p>我们明明是在<code>Student</code>类中通过<code>super</code>调用的父类<code>Person</code>中的<code>eat</code>方法，为何<code>Person</code>中的<code>eat</code>方法输出的也是<code>Student eat</code>呢？关于这一部分的解释，网上有很多说明解释，总感觉不够详细彻底，下面我们来分析一下。</p>
<p>我们通过命令行将<code>Student.m</code>文件转成<code>.cpp</code>文件，，<code>cd</code>进入到<code>Student.m</code>文件所在的目录，使用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc Student.m</span></pre></td></tr></table></figure>

<p>会在当前文件夹中生成<code>Student.cpp</code>文件，打开找到以下代码(3-4)，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Student_eat(Student * self, SEL _cmd) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Student"</span>))&#125;, sel_registerName(<span class="string">"eat"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fm_9d3dmfcj49598v7_hghf3qjc0000gn_T_Student_370c84_mi_0, self);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>找到关于<code>super</code>调用的部分代码(3-5)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Student"</span>))&#125;, sel_registerName(<span class="string">"eat"</span>));</span></pre></td></tr></table></figure>

<p>我们发现，当<code>super</code>调用时，其实是调用的<code>objc_msgSendSuper</code>方法进行的消息发送，我们看下官方文档对于此方法的解释：</p>
<blockquote>
<p>Sends a message with a simple return value to the superclass of an instance of a class.</p>
</blockquote>
<p>向超类发送消息。</p>
<p>通过代码(3-5)，可以得知，我们这里有两个参数，一个是结构体指针类型<code>__rw_objc_super</code>，一个是返回<code>SEL</code>类型方法编号的<code>sel_registerName</code>。而<code>__rw_objc_super</code>在我们编译的<code>Student.cpp</code>文件中可以找到原型，代码(3-6)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>结合官方文档对<code>objc_msgSendSuper</code>方法参数的说明我们得知，<code>__rw_objc_super</code>，也就是<code>objc_super</code>。官方文档对此参数的说明如下：</p>
<blockquote>
<p>A pointer to an <a href="https://developer.apple.com/documentation/objectivec/objc_super?language=objc" target="_blank" rel="noopener"><code>objc_super</code></a> data structure. Pass values identifying the context the message was sent to, including the instance of the class that is to receive the message and the superclass at which to start searching for the method implementation.</p>
</blockquote>
<p>指向<code>objc_super</code>的结构体指针，传递标识了上下文的消息，包含了消息接收者和要在超类中搜索的方法实现。我们再来看一下<code>objc_super</code>结构体的源码(3-7)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull id receiver;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull Class <span class="class"><span class="keyword">class</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr></table></figure>

<p>结合我们编译的代码(3-5)，我们得知，消息的接收者在这里传递的就是当前对象<code>self</code>，即<code>Student</code>类的实例对象，方法即<code>eat</code> 。</p>
<p>通过上面的分析我们得知，在我们使用<code>super</code>方法调用父类方法时，其实传递了隐藏参数。我们上面说过，<code>self</code>调用返回方法本身，并不一定是你看到的当前调用者。这里可以说明，当我们在父类中使用<code>self</code>时，因为是在子类中通过<code>super</code>方法调用的父类方法，在这过程中，通过隐藏结构体参数，消息接收者传递的是当前的<code>self</code>，也就是<code>Student</code>的实例，所以我们在父类中使用<code>self</code>时，其实是使用子类的实例在调用父类的方法，所以也就有了代码(3-1)和(3-3)的输出。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>super</tag>
        <tag>self</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>[iOS.OC]关于类簇</title>
    <url>/content/b7bda735.html</url>
    <content><![CDATA[<h4 id="一、引语"><a href="#一、引语" class="headerlink" title="一、引语"></a>一、引语</h4><p>首先新建基于 Single View App的工程，在<code>ViewController.m</code>文件中添加如下代码(1-1)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [[<span class="built_in">NSString</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<a id="more"></a>
<p>这是一段普通的不能在普通的创建不可变字符串的过程，<code>length</code>为<code>NSString</code>的获取长度的属性，我们输出了字符串的长度，结果为0。然后我们创建一个<code>Person</code>类，添加属性变量<code>age</code>，代码(1-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>然后在<code>ViewControlelr.m</code>中添加代码(1-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [[<span class="built_in">NSString</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person = [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, person.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过运行我们发现代码完全没有问题，那么我们对上面的代码做如下修改，代码(1-4)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person = [Person alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, person.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行我们发现有如下结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.183451</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.183520</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] Did you forget to nest alloc <span class="keyword">and</span> init?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.185386</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -length only defined <span class="keyword">for</span> abstract <span class="keyword">class</span>.  Define -[NSPlaceholderString length]!'</span></pre></td></tr></table></figure>

<p>当输出<code>person.age</code>时没有任何问题，正确输出结果，而执行到<code>string1.length</code>时报错了。错误提示告诉我们<code>NSString</code>要嵌套使用<code>alloc</code>和<code>init</code>方法，并且<code>length</code>属性仅仅是定义在一个抽象类中。那么我们来一看什么是抽象类，摘自百度百科的概念如下：</p>
<blockquote>
<p>抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。</p>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p>
<p>抽象类不能实例化</p>
</blockquote>
<p>通过以上说明我们可以得出，其实<code>NSString</code>是一个抽象类，类中只是进行了简单的行为声明，并没有实现。而在<code>Objective-C</code>中并没有明确的抽象类的定义，所以这样的实现方式我们称谓”类簇“。</p>
<h4 id="二、类簇的概念"><a href="#二、类簇的概念" class="headerlink" title="二、类簇的概念"></a>二、类簇的概念</h4><p>类簇(class cluster)，是一种模式，可以隐藏”抽象基类(abstract  base class)“背后的实现细节，用户无需创建子类的实例，只需调用基类方法来创建即可。</p>
<p>下面我们来验证一下，代码(3-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string2 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string3 = <span class="string">@"string"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string4 = [[<span class="built_in">NSString</span> alloc] initWithString:string2];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string5 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"string"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string1:%s"</span>, object_getClassName(string1));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string2:%s"</span>, object_getClassName(string2));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string3:%s"</span>, object_getClassName(string3));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string4:%s"</span>, object_getClassName(string4));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string5:%s"</span>, object_getClassName(string5));</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423153</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string1:NSPlaceholderString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423323</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string2:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423428</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string3:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423523</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string4:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423616</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string5:NSTaggedPointerString</span></pre></td></tr></table></figure>

<p>PS:通过上面的结果可以看出，<code>string3</code>和<code>string4</code>本质上是一样的，所以在创建字符串时，如果不是通过一个字符串来创建另一个字符串的情况用<code>string3</code>的方式创建即可。</p>
<p>通过结果可以看出我们创建的字符串对象本质上并不是一个<code>NSString</code>类型，而是其子类类型，我们通过以下方法可以验证，代码(3-2)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"superclass:%@"</span>, [<span class="built_in">NSClassFromString</span>(<span class="string">@"NSTaggedPointerString"</span>) superclass]);</span></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">02</span><span class="variable">.662405</span>+<span class="number">0800</span> allocmessage[<span class="number">81090</span>:<span class="number">9732886</span>] superclass:NSString</span></pre></td></tr></table></figure>

<p>所以当我们使用<code>isMemberOfClass</code>来判断字符串是否是当前类时，得到的结果是否定的，代码(3-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([string3 isMemberOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"是NSString当前类"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"否"</span>);</span></pre></td></tr></table></figure>

<p>结构为：否。</p>
<p>当然我们可以通过<code>isKindOfClass</code>来判断，结果是正确是正确的。</p>
<h4 id="三、地址验证"><a href="#三、地址验证" class="headerlink" title="三、地址验证"></a>三、地址验证</h4><p>首先重写<code>Person</code>类的<code>init</code>初始化方法，代码(4-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">self</span>.age = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后在<code>ViewController</code>的<code>viewDidLoad</code>方法中添加代码(4-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person1 = [Person alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person2 = [person1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person1 address:%p"</span>, person1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person2 address:%p"</span>, person2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string2 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string3 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string4 = [string2 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string5 = [string1 initWithFormat:<span class="string">@"string1"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string6 = [string1 initWithString:<span class="string">@"string2"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 address:%p"</span>, string1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string2 address:%p"</span>, string2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string3 address:%p"</span>, string3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string4 address:%p"</span>, string4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string5 address:%p"</span>, string5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string6 address:%p"</span>, string6);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355410</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] person1 address:<span class="number">0</span>x600001fe8340</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355542</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] person2 address:<span class="number">0</span>x600001fe8340</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355643</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string1 address:<span class="number">0</span>x1103f16f8</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355714</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string2 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355779</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string3 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355851</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string4 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355940</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string5 address:<span class="number">0</span>xb716bea187e38d28</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.356021</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string6 address:<span class="number">0</span>x10fdce0e8</span></pre></td></tr></table></figure>

<p>通过以上代码可以看出，<code>Person</code>类创建的对象，在<code>alloc</code>分配内存空间与初始化后的地址是一致的，也就是说<code>init</code>初始化方法只是完成了我们覆盖方法的赋值初始化操作。而<code>NSString</code>创建的对象在<code>alloc</code>分配内存空间后，初始化<code>init</code>方法又一次完成了分配空间的操作，重新分配了内存地址。</p>
<p>而通过基本的<code>init</code>初始化方法分配的内存地址是一致的，无论多次调用也不会改变，即指向了同一块内存区域。而<code>initWithFormat</code>，<code>initWithString</code>等带参数的初始化方法则重新分配了不同的内存空间。</p>
<p>PS：通过以上代码可以发现，类簇<code>alloc</code>分配内存空间后，<code>init</code>方法又一次重新分配了内存空间，又一次完成了开辟地址的操作。而非类簇的<code>Person</code>类则无此操作。</p>
<p>在关于<code>Initializers</code>的官方文档中有这样的叙述：</p>
<blockquote>
<p>Although <code>init...</code> methods are required by their method signature to return an object, that object is not necessarily the one that was most recently allocated—the receiver of the <code>init...</code> message. In other words, the object you get back from an initializer might not be the one you thought was being initialized.</p>
</blockquote>
<p>PS:大概意思是说：虽然<code>init</code>通过方法返回了一个对象，但这个这个对象并不一定是您最近分配的对象。换句话说，返回的对象并不一定是你认为的初始化方法返回的对象。</p>
<p>这些我们在类簇的模式中也得到了验证。</p>
<h4 id="四、类簇的实现"><a href="#四、类簇的实现" class="headerlink" title="四、类簇的实现"></a>四、类簇的实现</h4><p>改造<code>Person</code>类，<code>.h</code>文文件代码(5-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MWPersonType) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeProgrammer,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeDesigner,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeTester,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPersonType:(MWPersonType)type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)work;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span></pre></td></tr></table></figure>

<p><code>.m</code>文件代码(5-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonProgrammer.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonDesigner.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonTester.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPersonType:(MWPersonType)type &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span> (type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeProgrammer:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonProgrammer alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeDesigner:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonDesigner alloc] init] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeTester:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonTester alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)work &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//do something</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>分别实现<code>MWPersonProgrammer</code>，<code>MWPersonDesigner</code>，<code>MWPersonTester</code>，并全部继承于<code>Person</code>类，并在<code>.m</code>文件中实现自己的<code>work</code>方法。</p>
<h4 id="五、引申"><a href="#五、引申" class="headerlink" title="五、引申"></a>五、引申</h4><p>我们熟悉的<code>self = [super init]</code>这种写法，其中有一个原因就是类簇的模式。因为返回类型并不一定是当前类型。上面的例子，当我们初始化<code>Person</code>的对象时，其返回的对象并不是<code>Person</code>对象。<code>self = [super init]</code>写法并不会对<code>self</code>的指向造成任何影响，<code>self</code>总是指向当前类，父类的指针可以指向子类。主要的目的就是确保父类初始化成功，不会返回<code>nil</code>。</p>
<h4 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h4><p>OC中类簇的模式被大量使用，如<code>NSNumber</code>，<code>NSArray</code>，<code>UIButton</code>，<code>NSDictionary</code>等。类簇并非无法继承，而是需要实现特定的方法等。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>类簇</tag>
      </tags>
  </entry>
</search>
