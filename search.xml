<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[IOS.Swift]Swift基础数据类型(一)</title>
    <url>/content/bc12b792.html</url>
    <content><![CDATA[<h4 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h4><p>在 <code>Swift</code> 中，常量(不可变的变量)使用 <code>let</code> 关键字定义，变量使用 <code>var</code> 关键字定义，并且 <code>Swift</code> 建议尽可能使用 <code>let</code> 关键字定义，因为常量要更安全一些，如果一个值不允许被改变，但在无意间做了修改则有可能造成一些Bug的出现。定义的常量如果进行了修改，则编译器会报错。</p>
<a id="more"></a>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法，正确写法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二种写法，错误写法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//var a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//let b</span></span></pre></td></tr></table></figure>

<p>为什么第一种写法是正确的，而第二种写法是错误的呢？因为在 <code>Swift</code> 中可以进行变量类型推断，当我们定义变量并初始化以后，编译器可以根据我们的初始化值对所定义的变量自动进行类型推断。而定义但不初始化编译器就无法做出类型推断。当然可以进行显示指出定义的数据类型，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Double</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//同时声明三个Double类型变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d, e, f:<span class="type">Double</span></span></pre></td></tr></table></figure>

<p>虽然这样写是正确的，但是未初始化的变量是无法使用的，使用编译器会报错，所以在定义时最好直接进行初始化工作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Double</span> = <span class="number">200.0</span></span></pre></td></tr></table></figure>

<p>建议使用第一种写法，让编译器自动进行类型推断。</p>
<p>以上代码可以发现，在每一个代码后并没有使用分号(<code>;</code>)，在 <code>Swift</code> 中，一行只有一条语句是可以不加分号的，加了也没有错，但是如果一行的语句大于1，则需要使用分号隔开，以下都是正确的写法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>, b = <span class="number">200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="keyword">var</span> y = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以下分行写也是正确的，但是不便于阅读</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> =</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">100</span></span></pre></td></tr></table></figure>

<p>建议每一行只定义一条语句。</p>
<p><code>Swift</code> 中不允许使用系统提供的关键字作为变量名，如果想使用，可以用如下方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确，需要使用``将关键字包起来</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> `<span class="class"><span class="keyword">class</span>` = 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">`<span class="title">class</span>` = 100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">//错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">var</span> <span class="title">class</span> = 10</span></span></pre></td></tr></table></figure>



<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><code>print</code> 对象打印提供的内容。</p>
<p><code>debugPrint</code> 将最适合调试的给定项的文本表示形式写入标准输出。</p>
<p>都是将要打印的内容输出到控制台，但是 <code>debugPrint</code> 的打印结果非常丰富，与打印内容相关的内容都会做输出，特别在复杂对象输出时，比较明显，比如网络。</p>
<p><code>Swift</code>使用字符串插值(string interpolation)的方式将常量名或变量名当做占位符插入到字符串中，<code>Swift</code> 会使用该变量或者常量的值替换这些占位符。使用方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式 \(变量名)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> world = <span class="string">"hello world"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"this is hello \(world)"</span>)</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> is hello hello world</span></pre></td></tr></table></figure>



<h4 id="Int-整型"><a href="#Int-整型" class="headerlink" title="Int 整型"></a><code>Int</code> 整型</h4><p><code>Swift</code> 中整型有如下几种：</p>
<p>有符号型：<code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>、<code>Int</code></p>
<p>无符号型：<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code>、<code>UInt</code></p>
<p>8、16、32、64代表位，比如：<code>Int8</code> 8位有符号整型，在内存中占8位，占位不同，数值大小范围不同。</p>
<p><code>Int</code> 所占内存空间与当前平台原生字长相同，32位平台，<code>Int</code> 与 <code>Int32</code> 长度相同，64位平台，<code>Int</code> 与 <code>Int64</code> 长度相同。相应的，<code>UInt</code> 也与平台原生字长相同，32位平台，<code>UInt</code> 与 <code>UInt32</code> 长度相同，64位平台，<code>UInt</code> 与 <code>UInt64</code> 长度相同。</p>
<p>整型可以有四种表示形式：十进制(无前缀)、二进制(<code>0b</code>前缀)、八进制(<code>0o</code>前缀)、十六进制(<code>0x</code>前缀)。</p>
<p>可以通过 <code>Int.max</code> 来获取 <code>Int</code> 的最大值，<code>Int.min</code> 获取最小值，其他整型也如此。</p>
<p><strong><em>尽量不要使用 <code>UInt</code> ，即便变量保存的总是非负的值，统一使用 <code>Int</code> 型可以提高代码的复用性，避免在不同数据类型之间进行转换，并可匹配数值的类型推断。非特殊要求内存优化等情况，应尽量使用<code>Int</code></em></strong></p>
<h4 id="Double-和-Float-字符型"><a href="#Double-和-Float-字符型" class="headerlink" title="Double 和 Float 字符型"></a><code>Double</code> 和 <code>Float</code> 字符型</h4><p>浮点数可以表示更大范围的数。</p>
<p><code>Float</code> 表示32位浮点数，当要求精度不高时可以使用此种类型，可以输出到小数点后6位。</p>
<p><code>Double</code> 表示64位浮点数，存储很大或高精度浮点数时使用，可以输出到小数点后15位。</p>
<p>浮点可以有十进制(无前缀)、十六进制(<code>0x</code>前缀)表示。两种都可以使用指数方式表示。</p>
<p>当声明浮点型变量时，如不指定数据类型，通过自动推断，那么 <code>Swift</code> 会自动推断其为 <code>Double</code> 类型。</p>
<p>在 <code>Swift</code> 中，正浮点数除以0.0，得到的结果表示正无穷大，负浮点数除以0.0，得到的结果表示负无穷大，0.0除以0.0或对一个负数开方的结果表示非数。所有的正无穷大都相等，所有的负无穷大都相等，非数与任何数都不相等，包括它自己。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="number">200</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a == a1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"不相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = -<span class="number">100</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b1 = -<span class="number">200</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b == b1)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="number">0.0</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="number">0.0</span>/<span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">c</span> == c1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> a == <span class="built_in">c</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"不相等"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">相等</span></pre></td></tr><tr><td class="code"><pre><span class="line">true</span></pre></td></tr><tr><td class="code"><pre><span class="line">不相等</span></pre></td></tr></table></figure>

<p><strong><em>只有浮点数才能除以0.0，整数除以0编译器会报错。</em></strong></p>
<h4 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h4><p>在 <code>Swift</code> 中，为了增加可读性，数值类型数据可以使用以下表示方式，并不影响使用效果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1_000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d = <span class="number">1_000.1_000</span></span></pre></td></tr></table></figure>

<p><code>Swift</code> 中不同数据类型之间不能进行隐式转换，即便都是整型的 <code>Int</code> 与 <code>Int64</code> 等也不能直接使用，必须显示转换，这样可以防止不同数据类型之间不能转换或取值范围不同等造成的问题。显示转换方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:Int = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:Int64 = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = Int64(a) + b</span></pre></td></tr></table></figure>

<p>浮点数与整数之间操作也要显示转换。</p>
<h4 id="Bool-布尔型"><a href="#Bool-布尔型" class="headerlink" title="Bool 布尔型"></a><code>Bool</code> 布尔型</h4><p><code>Swift</code> 中布尔类型只有两个值，<code>true</code> 、 <code>false</code> ，其他值并不能当做布尔类型使用，不能用于判断真假。比如，非0值并不能当做 <code>true</code> 使用。比如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"真"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"假"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//错误，b为整型，并非布尔类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> b &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"真"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"假"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是可以使用条件来判断真假，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> b &gt; <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"真"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(<span class="string">"假"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h4 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a><code>tuple</code> 元组</h4><p>元组，使用圆括号把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求元组内的值具有相同的类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明但未初始化，不可使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user : (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Bool</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//初始化，可使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">user = (<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//声明并初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1:(<span class="type">Int</span>, <span class="type">Bool</span>)  = (<span class="number">10</span>, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user1)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用类型推断为(Int, Bool)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user3 = (<span class="number">10</span>, <span class="literal">true</span>)</span></pre></td></tr></table></figure>

<p>元组也可以嵌套使用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user4 = (<span class="number">10</span>, (<span class="number">10</span>, <span class="number">20</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user5:(<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">String</span>)) = (<span class="number">10</span>, (<span class="number">20</span>, <span class="string">"hello"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user4)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"\(user5)"</span>)</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, (<span class="number">10</span>, <span class="number">20</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, (<span class="number">20</span>, <span class="string">"hello"</span>))</span></pre></td></tr></table></figure>

<p>获取元组元素的值可以通过下标来获取，与数组一样，下标从0开始。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user1:(<span class="type">Int</span>, <span class="type">Bool</span>)  = (<span class="number">10</span>, <span class="literal">false</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = (<span class="number">10</span>, (<span class="number">10</span>, <span class="number">20</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user3:(<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">String</span>)) = (<span class="number">10</span>, (<span class="number">20</span>, <span class="string">"hello"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user1.<span class="number">0</span>, user1.<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user2.<span class="number">0</span>, user2.<span class="number">1.0</span>, user2.<span class="number">1.1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user3.<span class="number">1</span>)</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> false</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="number">20</span>, <span class="string">"hello"</span>)</span></pre></td></tr></table></figure>

<p>可以对元组进行拆分，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (name, age) = user1</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (name1, (age1, sex)) = user2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(name, age)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(name1, age1, sex)</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">张三 <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">李四 <span class="number">22</span> m</span></pre></td></tr></table></figure>

<p>如果只需要部分元素，分解时，可是使用 <code>_</code> 下划线来作为被忽略部分的占位符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (name, <span class="number">_</span>) = user1</span></pre></td></tr></table></figure>

<p>也可以为元组的数据元素命名，可以通过名称来对元组元素进行访问。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = (name:<span class="string">"zhangsan"</span>, age:<span class="number">20</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(user.name, user.age)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user1:(name:<span class="type">String</span>, age:<span class="type">Int</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//不指定元素名称则需要按照元素类型顺序进行复制</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">user1 = (<span class="string">"zhangsan"</span>, <span class="number">29</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//指定名称则可以不用按照顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">user1 = (age:<span class="number">20</span>, name: <span class="string">"张三"</span>)</span></pre></td></tr></table></figure>

<p>当元组中只有一个数据时，<code>Swift</code> 会将只有一个数据的元组当做其中数据的数据类型来处理，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时的age为Int类型，而非元组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = (<span class="number">20</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//所以如下方法是错误的，编译器会报错</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//let age:(num:Int)</span></span></pre></td></tr></table></figure>

<p>可以使用 <code>type(of: &lt;T&gt;)</code> 查看数据类型。</p>
<p>如果元组中数据类型相同，可以快速交换元组中数据元组的值，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">(i, j) = (j, i)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(i, j)  <span class="comment">//输出 20 10</span></span></pre></td></tr></table></figure>

<p>可以定义空元组，但是不能赋值，无法使用，只能是空元组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无法再次进行赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = ()</span></pre></td></tr></table></figure>



<h4 id="Optional-可选类型"><a href="#Optional-可选类型" class="headerlink" title="Optional 可选类型"></a><code>Optional</code> 可选类型</h4><p>在 <code>Swift</code> 中，使用可选类型来表示一个变量或常量有可能有值，也可能没有值(<code>nil</code>)，也称为值缺失。非可选类型数据是不能为 <code>nil</code> 的。<code>Swift</code> 中 <code>nil</code> 代表一个确定的值，即值缺失，任何可选类型数据都可以设置为 <code>nil</code>。 如果一个变量或常量有可能被赋予空值(值缺失)，则要声明为可选类型，否则赋 <code>nil</code> 值时会报错。</p>
<p>非可选类型的变量或常量在未初始化之前是无法使用的，可选类型未初始化则会自动设置为 <code>nil</code> (可选类型常量使用前也必须初始化，否则编译会报错，但是可设置为 <code>nil</code> )。可选类型使用如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">c</span>:<span class="type">Int?</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d:<span class="type">Bool?</span> = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(d)</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Optional(<span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">nil</span></pre></td></tr><tr><td class="code"><pre><span class="line">Optional(true)</span></pre></td></tr></table></figure>

<p>下面的写法是错误的，因为e非可选值类型，不能为 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e:<span class="type">Int</span> = <span class="literal">nil</span>  <span class="comment">//错误</span></span></pre></td></tr></table></figure>

<p>通过上面的输出结果可以发现，输出的都是可选值类型，而非基本数据类型，所以不能直接进行基本类型的操作，需要进行强制解析操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Int?</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//c为Int类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a! + b!</span></pre></td></tr></table></figure>

<p><code>Int?</code> 与 <code>Int</code> 是不同的数据类型，在运算前需要先获取变量的实际存储值，就需要通过 <code>变量名!</code> 这种形式进行强制解析。<code>!</code> 表示已知该可选变量有值，提取其中的值。使用 <code>!</code> 的前提就是保证要解析的可选变量或常量必须有值，才能解析成功，否则会导致运行时错误。可以先做判断在进行解析：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Int?</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a != <span class="literal">nil</span> &amp;&amp; b != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> <span class="built_in">c</span> = a! + b!</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Swift</code> 提供了更为方便的解析方法，可选绑定(optional binding)， 如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int?</span> = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b:<span class="type">Int?</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tmpa = a, <span class="keyword">let</span> tmpb = b &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(tmpa, tmpb)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>通过 <code>if let</code> 或 <code>if var</code> 结合使用，就是先判断可选类型变量是否为 <code>nil</code> ，如果不为 <code>nil</code> ，将会对可选变量进行强制解析，并将解析后的值赋给声明的变量或常量。</p>
<p>上面的代码，如果需要对<code>a</code>或<code>b</code>的值进行修改，则使用 <code>if var tmpa</code> , <code>if var tmpb</code> 定义即可。</p>
<p>上面的例子说的是变量或常量有可能没有值的情况下需要进行判断解析，但是如果在第一次赋值后能确保一个可选类型总是有值(不会重新被设置为 <code>nil</code> )，则每次解析比较低效，比如，定义一个常量可选值，并赋初值(非空, <code>nil</code>)，则常量不能被改变，可以使用隐式可选类型，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">Int!</span> = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = a + <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(b)</span></pre></td></tr></table></figure>

<p><code>Int?</code> 与 <code>Int!</code> 的区别在于：当需要获取 <code>Int?</code> 类型的值时，需要进行手动解析操作，如上面的例子。使用 <code>Int!</code> 时无需手动进行解析，<code>Swift</code> 会隐式执行自动解析。所以使用隐式解析可选类型要确保可选类型有值，否则也导致错误。当然隐式解析可选类型也可以进行判空和进行可选绑定操作。</p>
<h4 id="typealias-类型别名"><a href="#typealias-类型别名" class="headerlink" title="typealias 类型别名"></a><code>typealias</code> 类型别名</h4><p><code>Swift</code> 中使用 <code>typealias</code> (type aliases)来对现有类型定义别名，其他语言一般使用 <code>typedef</code> 来做此操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">MyInt</span> = <span class="type">Int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a:<span class="type">MyInt</span> = <span class="number">10</span></span></pre></td></tr></table></figure>

<p>定义好后，<code>MyInt</code> 与 <code>Int</code> 完全相同。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>IOS</tag>
        <tag>Swift</tag>
        <tag>Int</tag>
        <tag>Tuple</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]RunLoop详解</title>
    <url>/content/c598aae1.html</url>
    <content><![CDATA[<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p><code>RunLoop</code> 运行循环，是与线程相关的基础架构的一部分，它是一个对象，用来管理需要处理的事件和消息，并提供入口函数来执行事件循环时的逻辑。运行循环的目的是在有工作要做时让线程保持忙碌，没有工作时让线程休眠。</p>
<p>每个线程，包括应用程序的主线程，都有一个相关的运行循环对象。线程与 <code>RunLoop</code> 之间存在一对一的关系，该关系存储在一个全局的 <code>Dictionary</code> 中。主线程的运行循环作为应用程序启动过程的一部分，自动设置并在主线程上运行。非主线程的运行循环需要显示运行，在创建线程时，并没有 <code>Runloop</code> ，如果不主动获取，它永远不会存在。<code>Runloop</code> 在第一次获取时创建，除了主线程之外，只能在线程内部获取 <code>RunLoop</code>。</p>
<h4 id="二、RunLoop-存在的意义"><a href="#二、RunLoop-存在的意义" class="headerlink" title="二、RunLoop 存在的意义"></a>二、<code>RunLoop</code> 存在的意义</h4><p>通常一个线程一次只能执行一个任务，任务执行完毕时，退出线程。<code>RunLoop</code> 是一个运行循环，内部是一个 <code>do...while</code> 循环，它在线程中执行可以保持线程持续运行不退出，以”接收消息-&gt;等待-&gt;处理”的循环模式持续运行，直到循环结束。实现此模式的关键是管理事件/消息时，如果在不处理消息时，使线程休眠以免资源占用，在消息到达时唤醒线程。主要来说有以下几点：</p>
<ul>
<li>保持程序运行</li>
<li>接收用户输入</li>
<li>监听事件</li>
<li>节省CPU时间</li>
<li>调用解耦</li>
</ul>
<h4 id="三、消息处理"><a href="#三、消息处理" class="headerlink" title="三、消息处理"></a>三、消息处理</h4><p>在OS X和IOS系统中，提供了两种 <code>RunLoop</code> 对象 ：</p>
<p>CoreFoundation框架内的 <code>CFRunLoopRef</code> ，该框架为纯C函数提供的API，所有API都是线程安全的。<br>Foundation框架内的 <code>NSRunLoop</code> ，<code>NSRunLoop</code> 是基于 <code>CFRunLoopRef</code> 的封装，提供了面相对象的API，是非线程安全的。</p>
<p><code>NSRunLoop</code> 可以通过 <code>[[NSRunLoop currentRunLoop] getCFRunLoop]</code> 转换为  <code>CFRunLoopRef</code> 。</p>
<p><code>RunLoop</code> 从两种不同类型的源接收消息：</p>
<p>输入源(Input Sources )：传递异步事件，通常是来自另一个线程或其他应用程序的消息。</p>
<p>计时器源(Timer Sources)：传递同步事件，这些事件是在计划的时间或重复的时间间隔发生。</p>
<p><img src="/content/c598aae1/2020111233.jpg" alt="2020111233"></p>
<h5 id="1-输入源-Input-Sources"><a href="#1-输入源-Input-Sources" class="headerlink" title="1.输入源(Input Sources)"></a>1.输入源(Input Sources)</h5><p>端口输入源：</p>
<p>选择器源：</p>
<p>自定义源：</p>
<h5 id="2-计时器源"><a href="#2-计时器源" class="headerlink" title="2.计时器源"></a>2.计时器源</h5>]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>ObjC</tag>
        <tag>RunLoop</tag>
        <tag>NSTimer</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]线程锁</title>
    <url>/content/9ff26aaa.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制。主要是为了解决共享资源的安全问题。当不同的线程同时操作一块内存数据时，如果不加以限制，会发生数据错乱等异常问题。加锁，则每个线程在访问对应资源时，需要先获取锁信息，再根据信息决定是否可以访问。当一条线程访问特定资源时，使用锁会锁定该特定资源，此时其他线程无法访问该资源。当资源访问结束后，会恢复锁的状态，允许其他线程访问，这样就保证了在同一时间只有一个对象访问特定资源，实现数据安全。</p>
<a id="more"></a>

<h4 id="二、锁实现"><a href="#二、锁实现" class="headerlink" title="二、锁实现"></a>二、锁实现</h4><h5 id="1-atomic与nonatomic"><a href="#1-atomic与nonatomic" class="headerlink" title="1.atomic与nonatomic"></a>1.<code>atomic</code>与<code>nonatomic</code></h5><p>在说锁之前，先来看下原子与非原子：</p>
<p><code>atomic</code> 原子的，使用<code>atomic</code>属性标志表示的是无论多少个线程访问给定属性，其值的设置或获取都会获得一个完整的值，而不是部分值。并不是表示线程安全，只是表示值的完整性。当有多个线程对同一属性进行写入操作时，只能保证每次读的时候上一次写入操作已经完成。但是如果此时有读取操作，并不能保证读取到的值是哪次写入后的值，有可能是写入之前，也有可能是其中，某个写入后的值等。</p>
<p><code>nonatomic</code>非原子的，也就是与<code>atomic</code>相反，当多线程访问时，有可能会获取到一个不完整的结果，比如当一个线程在进行写入操作时，执行到<code>setter</code>方法中的某一部分，此时另外一个线程进行了写入操作，会造成数据错乱或崩溃等，具体看执行到什么位置。同样也非线程安全。</p>
<p>其部分源码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!atomic) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    oldValue = *slot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *slot = newValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    slotlock.lock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    oldValue = *slot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *slot = newValue;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    slotlock.unlock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>atomic</code>属性时，内部使用自旋锁进行锁定操作，而<code>nonatomic</code>并没有此操作。定义属性时，如不指定默认为<code>atomic</code>。</p>
<p>有如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">self</span>.countIndex--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr></table></figure>

<p>也证明了<code>atomic</code>是非线程安全的。既然非线程安全，就需要手动添加锁来保证线程安全。</p>
<h5 id="2-POSIX-Mutex-Lock"><a href="#2-POSIX-Mutex-Lock" class="headerlink" title="2.POSIX Mutex Lock"></a>2.POSIX Mutex Lock</h5><p> C语言实现，是一套跨平台的多线程API。pthread是一套非常强大的多线程锁，可以创建互斥锁（普通锁）、递归锁、信号量、条件锁、读写锁、once锁等，基本上所有涉及的锁，都可以用pthread来实现。需要添加头文件<code>#import &lt;pthread.h&gt;</code>，在使用之前要先初始化，基本使用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义互斥锁变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//静态初始化锁，定义的时候就要初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//动态初始化锁，使用默认属性，传NULL即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//销毁锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_destroy(&amp;mutex);</span></pre></td></tr></table></figure>

<p>互斥锁如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pthread_mutex_t mutex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//动态初始化锁，使用默认属性，传NULL即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pthread_mutex_lock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(_countIndex &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">self</span>.countIndex = <span class="keyword">self</span>.countIndex - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"执行结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//销毁锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            pthread_mutex_destroy(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pthread_mutex_unlock(&amp;mutex);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>递归锁，更改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutexattr_t</span> attr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutexattr_init(&amp;attr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">pthread_mutexattr_destroy(&amp;attr);</span></pre></td></tr></table></figure>



<h5 id="3-synchronized-指令"><a href="#3-synchronized-指令" class="headerlink" title="3.synchronized 指令"></a>3.<code>synchronized</code> 指令</h5><p><code>@synchronized</code> 隐式的创建一种其他锁能实现的功能，通过不同线程共用同一标识符的方式来达到互斥的目的。传递给<code>@synchronized</code>指令的对象是一个唯一的标识符，用于区分受保护的块。如果在不同线程使用不同的对象标识符，则每个线程都会获得自己的锁，而不被其它锁阻塞。<code>@synchronized</code>块隐式地向受保护的代码添加了一个异常处理程序，这个处理程序在抛出异常时会自动释放互斥，这意味着为了使用@synchronized指令，您还必须在代码中启用Objective-C异常处理。所以会带来一定的额外开销，如果大量使用<code>@synchronized</code>指令则效率较低。</p>
<p>使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(_countIndex &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">self</span>.countIndex = <span class="keyword">self</span>.countIndex - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"执行结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：<code>synchronized</code>标识token 为任意<code>id</code>类型，一般使用<code>self</code>。</p>
<h5 id="4-NSLock"><a href="#4-NSLock" class="headerlink" title="4.NSLock"></a>4.<code>NSLock</code></h5><p><code>NSLock</code> 互斥锁，互斥锁是一种信号量，每一次只授权一个线程访问权限。如果正在使用互斥锁并且另一个线程尝试获取它，该线程将阻塞，直到互斥锁被其原始持有者释放为止。如果多个线程竞争相同的互斥锁，一次只能访问一个。<code>NSLock</code>类使用POSIX线程来实现其锁定行为，向<code>NSLock</code>对象发送解锁消息时，必须确保该消息是从发送初始锁定消息的同一线程发送的。从其他线程解锁锁可能导致未定义的行为。不应使用此类来实现递归锁。在同一线程上两次调用<code>lock</code>方法将永久锁定您的线程。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSLock</span> * mlock;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.mlock = [[<span class="built_in">NSLock</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.mlock.name = <span class="string">@"my lock"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> currentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)currentIndex &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (_countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.mlock lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(_countIndex &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">self</span>.countIndex = <span class="keyword">self</span>.countIndex - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"执行结束"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.mlock unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>此外<code>NSLock</code>中还定义了<code>tryLock</code>、<code>lockBeforeDate</code>。<code>tryLock</code>会尝试获取锁，并立即返回是否成功，不会阻塞线程。<code>lockBeforeDate</code>在指定时间之前获取锁，此方法会阻塞当前线程，直到时间结束，如果在指定时间内未获取到锁则返回NO。</p>
<h5 id="5-NSRecursiveLock-递归锁"><a href="#5-NSRecursiveLock-递归锁" class="headerlink" title="5.NSRecursiveLock 递归锁"></a>5.<code>NSRecursiveLock</code> 递归锁</h5><p>“递归锁” ，顾名思义，常用在递归函数中以防止递归阻塞线程。当然也可以在非递归函数中使用。<code>NSRecursiveLock</code>定义的锁，可以被同一线程多次获取，而不会导致死锁问题。递归锁会记录成功获取的次数。每个成功锁的获取必须通过相应的调用来平衡解锁g该锁。只有当锁和解锁调用彼此平衡时，锁才会被释放，其他线程才能获取。使用属性与<code>NSLock</code>相同。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSRecursiveLock</span> * recursiveLock;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.recursiveLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> recursiveMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> recursiveMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)recursiveMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.recursiveLock lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.countIndex != <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        --<span class="keyword">self</span>.countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"countIndex:%ld"</span>, <span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> recursiveMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.recursiveLock unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：在递归函数中加锁，如不使用递归锁则会造成死锁，线程将会被锁死。</p>
<p>因为在获取锁与解锁平衡之前，递归锁不会被释放，所以会消耗一定的性能。长时间持有递归所会导致其他线程阻塞，直到递归完成。所以如果对性能需求较高，可以通过重写代码来消除递归，可获得更好的性能。</p>
<h5 id="6-OSSpinLock-与-os-unfair-lock-lock"><a href="#6-OSSpinLock-与-os-unfair-lock-lock" class="headerlink" title="6.OSSpinLock 与 os_unfair_lock_lock"></a>6.<code>OSSpinLock</code> 与 <code>os_unfair_lock_lock</code></h5><p><code>os_unfair_lock_lock</code>为<code>OSSpinLock</code>的替代品，<code>OSSpinLock</code>已废弃，如果需要使用自旋锁，要使用<code>os_unfair_lock_lock</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">os_unfair_lock_lock(&amp;lock);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//解锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">os_unfair_lock_unlock(&amp;lock);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//尝试加锁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  BOOL isLock = os_unfair_lock_trylock(&amp;lock);</span></span></pre></td></tr></table></figure>



<h5 id="7-NSCondition-条件"><a href="#7-NSCondition-条件" class="headerlink" title="7.NSCondition 条件"></a>7.<code>NSCondition</code> 条件</h5><p>条件对象既充当给定线程中的锁又充当检查点。锁在测试条件并执行条件触发的任务时保护您的代码。检查点行为要求条件在线程继续执行其任务之前为真。条件不成立时，线程将阻塞。它保持阻塞状态，直到另一个线程向条件对象发出信号为止。</p>
<p>每当您使用条件对象时，第一步就是锁定条件。锁定条件可确保您的谓词和任务代码免受使用相同条件的其他线程的干扰。完成任务后，您可以根据代码需求设置其他谓词或发出其他条件信号。按住条件对象的锁时，应始终设置谓词和信号条件。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSCondition</span> * condition = [[<span class="built_in">NSCondition</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!<span class="keyword">self</span>.countIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"等待执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            [condition wait];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --<span class="keyword">self</span>.countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行:%ld"</span>,<span class="keyword">self</span>.countIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">self</span>.countIndex += <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"发信号"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition signal];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [condition unlock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">等待执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">发信号</span></pre></td></tr><tr><td class="code"><pre><span class="line">执行:<span class="number">9</span></span></pre></td></tr></table></figure>

<p>示例代码只用了两个并发演示，可能有多条线程访问数据，需要添加锁保证数据安全。其他方法：</p>
<p><code>waitUntilDate</code> 等待直到发出条件信号或达到指定的时间限制为止，阻塞当前线程。必须在调用此方法之前锁定接收器。<br><code>broadcast</code> 发出状态信号，唤醒所有等待该状态的线程。为避免出现竞争情况，仅应在接收器锁定时调用此方法。</p>
<h5 id="8-NSConditionLock条件锁"><a href="#8-NSConditionLock条件锁" class="headerlink" title="8.NSConditionLock条件锁"></a>8.<code>NSConditionLock</code>条件锁</h5><p>条件锁根据特定的条件进行锁或者解锁，通常，当应用程序中的线程需要以特定顺序执行时（例如，当一个线程产生另一个线程消耗的数据时），您可以使用<code>NSConditionLock</code>对象。在生产者执行过程中，消费者休眠等待获取一个以生产者完成其操作为条件的锁。一个应用程序可以具有多个<code>NSConditionLock</code>对象，每个对象都保护代码的不同部分。但是，必须在应用程序成为多线程之前创建这些对象。</p>
<p><code>NSConditionLock</code>对象响应的锁定和解锁方法可以任意组合使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> countIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSConditionLock</span> * conditionLock;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> * mutableArray;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.countIndex = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.conditionLock = [[<span class="built_in">NSConditionLock</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.mutableArray = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"条件锁的条件:%ld"</span>, (<span class="keyword">long</span>)<span class="keyword">self</span>.conditionLock.condition);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> producersMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span> consumersMethod];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)producersMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock lock];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始生产数据"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            [<span class="keyword">self</span>.mutableArray addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)consumersMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock lockWhenCondition:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始消费数据"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.mutableArray[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            [<span class="keyword">self</span>.mutableArray removeObjectAtIndex:<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [<span class="keyword">self</span>.conditionLock unlockWithCondition:<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">条件锁的条件:<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">开始生产数据</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">开始消费数据</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr></table></figure>

<p><code>unlockWithCondition</code>方法为解锁并设置新的锁定条件。<code>lockWhenCondition</code>尝试获取锁，接收者的条件必须等于锁定操作成功之前的条件。此方法会阻塞线程的执行，直到可以获取锁为止。还有一些其他方法：</p>
<p><code>lockBeforeDate</code> 尝试在指定日期之前获取锁，此方法将阻塞线程的执行，直到接收者获得锁定或达到限制为止。<br><code>lockWhenCondition:beforeDate</code> 尝试在指定的时间之前获取指定锁。接收者的条件必须等于锁定操作成功之前的条件。此方法将阻止线程的执行，直到可以获取锁或达到限制为止。<br><code>tryLock</code>尝试获取锁而不考虑接收者的状况，不阻塞线程。<br><code>tryLockWhenCondition</code> 根据指定条件尝试获取锁。作为其实现的一部分，此方法将调用<code>lockWhenCondition：beforeDate</code>。此方法立即返回。</p>
<h5 id="9-dispatch-semaphore"><a href="#9-dispatch-semaphore" class="headerlink" title="9.dispatch_semaphore"></a>9.<code>dispatch_semaphore</code></h5><p>通过都信号计数的控制来控制并发数量，达到对资源的同步访问的目的，具体可以看 <a href="http://www.mwpush.com/content/d04bd655.html">[IOS.OC]GCD的使用精解(三)</a></p>
<h5 id="10-NSDistributedLock分布锁"><a href="#10-NSDistributedLock分布锁" class="headerlink" title="10.NSDistributedLock分布锁"></a>10.<code>NSDistributedLock</code>分布锁</h5><p>在多个主机上的多个应用程序中，可以使用<code>NSDistributedLock</code>类来限制对某些共享资源(文件)的访问。锁实际上是使用文件系统项(文件或目录)来实现锁的。所有使用<code>NSDistributedLock</code>对象的应用程序都必须可以写锁。这就意味着把它放在一个文件系统上，所有运行该应用程序的计算机都可以访问它。</p>
<p>上面也说过，<code>NSDistributedLock</code>是不遵循<code>NSLocking</code>协议的，所以没有锁方法。锁方法将阻塞线程的执行，并要求系统以预定的速度轮询锁定。当然这个决定权在开发者手中，可通过<code>tryLock</code>方法来决定是否轮询。<br>如果持有锁的进程在释放前挂掉，那么锁将一直得不到释放，可通过<code>breakLock</code>强行获取锁。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>线程锁</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]IOS中的多线程</title>
    <url>/content/436b03b3.html</url>
    <content><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>OS X或iOS中的每个进程(应用程序)都由一个或多个线程组成，每个线程代表应用程序代码的单一执行路径。每个应用程序都从一个线程开始，这个线程运行应用程序的主要功能，称之为主线程。应用程序可以产生额外的线程，每个线程执行特定函数的代码。</p>
<p>关于线程等概念的介绍，可以看 <a href="http://www.mwpush.com/content/edab7fec.html">关于串行、并发、并行等的说明</a></p>
<p>实现多线程的方法主要有三种：<code>pthread</code>、<code>GCD</code>、<code>NSThread</code>、<code>NSOperation</code></p>
<a id="more"></a>

<h4 id="二、线程实现"><a href="#二、线程实现" class="headerlink" title="二、线程实现"></a>二、线程实现</h4><h5 id="1-线程开销"><a href="#1-线程开销" class="headerlink" title="1.线程开销"></a>1.线程开销</h5><p>内核数据结构，每个线程大约消耗1KB的内核内存空间。这块内存用于存储与线程有关的数据结构和属性，这块内存是联动内存，无法被分页。</p>
<p>栈空间，主线程的栈空间为1M，无法修改。子线程默认分配512KB的栈空间，会随时使用而增长。</p>
<p>线程启动前，可以通过<code>setStackSize</code>设置栈空间的大小。栈空间最小为16KB，且必须必须是4KB的整数倍。</p>
<p>大量开启线程会降低程序的性能，线程越多，CPU调度线程上的开销就越大。</p>
<h5 id="2-pthread"><a href="#2-pthread" class="headerlink" title="2.pthread"></a>2.<code>pthread</code></h5><p><code>OSIX</code>线程(<code>POSIX threads</code>)，简称<code>Pthreads</code>，是线程的POSIX标准，是基于C语言实现的跨平台的线程API。头文件为 ： <code>pthread.h</code>。由于<code>pthread</code>创建的线程是C语言实现的，生命周期由程序员管理，在OC中使用频率很低(几乎不用)。</p>
<p>用<code>pthread_create</code>创建，有四个参数，第一个为<code>pthread_t</code>线程ID(线程编号的地址)，第二个为<code>pthread_attr_t</code>线程属性，传<code>NULL</code>表示采用默认属性，第三个为<code>void * (*)(void *)</code>线程实现函数，第四个<code>void *restrict</code>实现函数的参数。返回值为<code>int</code>类型，表示线程创建成功或失败，0表示成功，非0表示失败，非0时返回错误码。</p>
<p>实现方式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runPthread</span><span class="params">(<span class="keyword">int</span> *param)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">pthread_t</span> pthreadID;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> result = pthread_create(&amp;pthreadID, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)runPthread, &amp;a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!result)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        NSLog(@<span class="string">"线程创建成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> NSLog(@<span class="string">"线程创建失败:%d"</span>, result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">runPthread</span><span class="params">(<span class="keyword">int</span> *param)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog(@<span class="string">"%d"</span>, *param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>传OC对象参数，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * runPthread(<span class="keyword">void</span> *param);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    pthread_t pthreadID;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * param = <span class="string">@"我是参数"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> result = pthread_create(&amp;pthreadID, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)runPthread, (__bridge <span class="keyword">void</span> *)param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!result)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程创建成功！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"线程创建失败:%d"</span>, result);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * runPthread(<span class="keyword">void</span> *param) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, (__bridge <span class="built_in">NSString</span> *)param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h5 id="3-NSThread"><a href="#3-NSThread" class="headerlink" title="3.NSThread"></a>3.<code>NSThread</code></h5><p>一个<code>NSThread</code>对象代表一条线程，可以使用类方法或实例方法创建。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用类方法创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(newThreadMethod) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  	使用block方式创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [NSThread detachNewThreadWithBlock:^&#123; /* 线程需要执行的内容 */ &#125;];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)newThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">线程:&lt;NSThread: <span class="number">0</span>x60000297b340&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>使用类方法创建，类方法无返回值，所以不能对线程做做操。创建后会直接启动线程执行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例方法创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(newThreadMethod:) object:<span class="string">@"创建新线程"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//  	使用block方式创建    </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    NSThread * thread = [[NSThread alloc] initWithBlock:^&#123; /* 线程需要执行的内容 */&#125;];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)newThreadMethod:(<span class="built_in">NSString</span> *)str &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建新线程</span></pre></td></tr><tr><td class="code"><pre><span class="line">线程:&lt;NSThread: <span class="number">0</span>x6000038a3000&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>使用实例方法创建线程，返回线程的实例，可以设置一些属性。线程创建后，需手动开启执行。</p>
<p>属性设置</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(newThreadMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//设置线程名称，方便debug</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thread.name = <span class="string">@"new thread"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//服务质量(优先级)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    thread.qualityOfService = <span class="built_in">NSQualityOfServiceDefault</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//设置线程分配l空间，单位字节，不设置会使用默认值，为512*1024,512KB，这里我们设置为1024KB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread setStackSize:<span class="number">1024</span>*<span class="number">1024</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)newThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//返回当前线程对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * currentThread = [<span class="built_in">NSThread</span> currentThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//返回栈空间大小，单位为字节</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSUInteger</span> stackSize = [currentThread stackSize];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//判断currentThread是否是主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isMainThread = [currentThread isMainThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//线程是否处于执行状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isExecuting = [currentThread isExecuting];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//返回currentThread的优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> priority = [currentThread threadPriority];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//线程是否被取消</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isCancelled = [currentThread isCancelled];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//线程是否执行完毕</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">BOOL</span> isFinished = [currentThread isFinished];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//输出线程字典</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dic:%@"</span>, currentThread.threadDictionary);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"栈空间:%luKB"</span>, stackSize/<span class="number">1024</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"是否是主线程:%@"</span>, isMainThread ? <span class="string">@"是"</span> : <span class="string">@"不是"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"是否处于执行状态:%@"</span>, isExecuting ? <span class="string">@"是"</span> : <span class="string">@"不是"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"优先级:%f"</span>, priority);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程是否被取消:%@"</span>, isCancelled ? <span class="string">@"是"</span> : <span class="string">@"否"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程是否执行完毕:%@"</span>, isFinished ? <span class="string">@"是"</span> : <span class="string">@"否"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!isCancelled)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//取消线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        [currentThread cancel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//再次判断线程是否被取消</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>([currentThread isCancelled])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程被取消"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"线程没被取消"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//再次判断线程是否执行完毕</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>([currentThread isFinished])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"未执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">dic:&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">栈空间:<span class="number">1024</span>KB</span></pre></td></tr><tr><td class="code"><pre><span class="line">是否是主线程:不是</span></pre></td></tr><tr><td class="code"><pre><span class="line">是否处于执行状态:是</span></pre></td></tr><tr><td class="code"><pre><span class="line">优先级:<span class="number">0</span><span class="variable">.500000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">线程是否被取消:否</span></pre></td></tr><tr><td class="code"><pre><span class="line">线程是否执行完毕:否</span></pre></td></tr><tr><td class="code"><pre><span class="line">线程被取消</span></pre></td></tr><tr><td class="code"><pre><span class="line">未执行完毕</span></pre></td></tr></table></figure>

<p>可以看到，当调用<code>cancel</code>方法后线性被取消，但是线程中未执行完的代码会继续执行完毕。线程还有一个<code>exit</code>类方法为强制退出，强制退出则直接退出，未执行的代码不再执行。不要在主线程中调用<code>exit</code>方法，因为调用后线程将进入死亡状态，无法再次启动，界面不会崩溃，但无法操作。</p>
<p>一些类方法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断当前线程是否为主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> isMainThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回主线程对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> mainThread];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回应用是否为多线程环境</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> isMultiThreaded];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个包含调用堆栈返回地址的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> callStackReturnAddresses];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个包含调用堆栈符号的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> callStackSymbols];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//睡眠一秒(时间秒)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//睡眠，阻塞当前线程直到指定的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>]];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设置线程优先级(通常不用设置)，值范围0.0~1.0，默认值为0.5，值越大优先级越高，但并不保证优先级高的任务一定会先执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> setThreadPriority:<span class="number">1.0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回当前线程的优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> threadPriority];</span></pre></td></tr></table></figure>

<p><code>NSThread</code>中还有一个<code>main</code>方法，我们可以通过子类化<code>NSThread</code>，并重写<code>main</code>方法，以覆盖主方法来实现自己的线程入口点。如果复写了<code>main</code>方法就不要调用<code>super</code>来调用继承行为。 不要主动调用<code>main</code>方法，应通过<code>start</code>方法来启动。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span> : <span class="title">NSThread</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//分割线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyThread.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyThread</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程启动了：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyThread * mythread = [[MyThread alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [mythread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">线程启动了：&lt;MyThread: <span class="number">0</span>x60000019bd80&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>在<code>NSThread</code>的头文件中，可以看到一个<code>NSObject</code>的分类<code>NSObject (NSThreadPerformAdditions)</code>，里面提供了一些实例方法，都是跟线程相关的，这是<code>NSObject</code>提供的多线程方法，主要用来实现线程间的通信。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法1：使用指定模式调用在主线程中执行的指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为参数，第三个为在主线程中执行指定方法后，是否阻塞当前线程，YES 是 NO 否，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">如果当前线程为主线程，则不会阻塞，设置为YES时，消息(方法)将被立即执行，否则排队等待下次运行循环执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第四个为模式数组，不能为空，否则将不执行调用方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(callThreadMethod) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法2：在主线程中执行指定的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为参数，第三个为在主线程中执行指定方法后，是否阻塞当前线程，YES 是 NO 否</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">如果当前线程为主线程，则不会阻塞，设置为YES时，消息(方法)将被立即传送和处理。当方法1模式为</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">NSRunLoopCommonModes时，功能同此方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(callThreadMethod) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法3：使用指定模式调用在指定线程中执行的指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为要执行方法的线程，第三个为参数，第四个为在指定线程中执行指定方法后，是否阻</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">塞当前线程，YES 是 NO 否。如果当前线程和目标线程为同一线程，则不会阻塞，设置为YES时，消息(方法)将被立</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">即执行，否则将排队执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第五个参数为模式数组，不能为空，否则将不执行调用方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法4：在指定线程中执行指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为要执行方法的线程，第三个为从参数，第四个为在指定线程中执行指定方法后，是否阻塞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">当前线程，YES 是 NO 否。如果当前线程和目标线程为同一线程，则不会阻塞，设置为YES时，消息(方法)将被立即执</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">行，否则将排队执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">注意：此方法添加的方法是在目标线程的运行循环上排队执行，如果目标队列没有开启运行循环(RunLoop)则则不会执行。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callMainThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">方法5：在后台(子线程)执行指定方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">第一个为方法选择器，第二个为参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(callThreadMethod) withObject:<span class="literal">nil</span>];</span></pre></td></tr></table></figure>

<p>注意：以上方法添加的方法都是在目标线程的运行循环上排队执行，如果目标队列没有开启运行循环(RunLoop)则则不会执行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加的执行方法:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建的线程：&lt;NSThread: <span class="number">0</span>x600003e4f680&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>发现，通过<code>performSelector</code>添加到<code>thread</code>的方法<code>callThreadMethod</code>并没有执行。因为目标队列没有启动运行循环，至于方法1和方法2，因为是运行在主线程上，主线程默认是开启了运行循环的，可以执行，而我们创建的线程默认是没有创建运行循环的，它直到我们获取才会创建。所以做如下更改：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//此处代码永远不会执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加的执行方法:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建的线程：&lt;NSThread: <span class="number">0</span>x600000506880&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">添加的执行方法:&lt;NSThread: <span class="number">0</span>x600000506880&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>因为运行循环是一个死循环，所以上面代码注释的地方永远不会访问到，可以用下面的方式改善代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.isFinished = <span class="literal">NO</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建的线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runUntilDate:[<span class="built_in">NSDate</span> date]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"后面执行的任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(callThreadMethod) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"添加的执行方法:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">创建的线程：&lt;NSThread: <span class="number">0</span>x600001812900&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">添加的执行方法:&lt;NSThread: <span class="number">0</span>x600001812900&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">后面执行的任务</span></pre></td></tr></table></figure>

<p><code>runUntilDate</code>参数传入当前日期即可，它会给你足够的时间执行所需的任务。如果传入将来的时间，则会堵塞当前线程。当然还有别的方式，后续的<code>RunLoop</code>总结中会做说明。</p>
<h5 id="4-NSOperation与NSOperationQueue"><a href="#4-NSOperation与NSOperationQueue" class="headerlink" title="4.NSOperation与NSOperationQueue"></a>4.<code>NSOperation</code>与<code>NSOperationQueue</code></h5><p><code>NSOperation</code>是一个抽象类，不能直接使用，我们可以使用系统定义好的它的子类<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>，或自定义<code>NSOperation</code>的派生类。</p>
<p><code>NSInvocationOperation</code>可以创建一个非并发操作。它本身不会开辟线程，会在创建的线程中执行。创建后需要调用<code>start</code>方法启动。</p>
<p>创建方法1：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(callThreadMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationOperationMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [invocationOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invocationOperationMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"invocationOperation线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务执行线程：&lt;NSThread: <span class="number">0</span>x600001008100&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">invocationOperation线程：&lt;NSThread: <span class="number">0</span>x600001008100&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>创建方法2：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSThread</span> * thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(callThreadMethod) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [thread start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)callThreadMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务执行线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSMethodSignature</span> * signature = [[<span class="keyword">self</span> <span class="keyword">class</span>] instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(invocationOperationMethod)];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocation</span> * invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    invocation.target = <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    invocation.selector = <span class="keyword">@selector</span>(invocationOperationMethod);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithInvocation:invocation];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [invocationOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invocationOperationMethod &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"invocationOperation线程：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>PS：<code>NSInvocation</code>主要用于在对象及应用之间存储和转发消息，<code>NSInvocation</code>可以设置多个参数，不要直接调用<code>init</code>方法初始化。</p>
<p><code>NSBlockOperation</code>管理一个或多个块的并发操作。当执行多个块操作时，只有当所有块执行完毕后，操作本身才被视为完成。添加到块操作中的任务会被调度到适当的工作队列。块创建好后，可以执行添加块任务操作，也可以查看块。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> * blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务2：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[blockOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [blockOperation executionBlocks]);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blockOperation追加任务1：&lt;NSThread: 0x6000032bfa80&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务1：&lt;NSThread: 0x6000032f6500&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务2：&lt;NSThread: 0x6000032c3180&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&lt;__NSGlobalBlock__: 0x101c9c060&gt;&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&lt;__NSGlobalBlock__: 0x101c9c080&gt;&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&lt;__NSGlobalBlock__: 0x101c9c0a0&gt;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>



<p>自定义<code>NSOperation</code>子类，自定义子类需要根据需要设计并发与非并发，非并发只需要重写<code>main</code>方法即可，可以自定义初始化行为，<code>main</code>方法中实现具体的任务代码。使用时，通过<code>start</code>启动任务即可。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyOperation.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyOperation</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!<span class="keyword">self</span>.isCancelled)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"具体任务代码"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        @autoreleasepool &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//        &#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//分割线,下面为调用方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MyOperation * myOperation = [[MyOperation alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[myOperation start];</span></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">具体任务代码</span></pre></td></tr></table></figure>

<p>如果设计并发操作，则需要覆盖<code>start</code>、<code>asynchronous</code>、<code>executing</code>、<code>finished</code>，<code>start</code>负责以异步的方式启动操作，还应该负责更新执行状态，可通过<code>KVO</code>方式通知，而且还要保证线程安全。还有许多注意事项，可查看官方文档。</p>
<p>以上都是通过自定义<code>NSOperation</code>子类或使用系统提供的子类来实现操作的。在<code>NSOperation</code>抽象类中提供了很多关键行为，可以直接使用，我们以<code>NSBlockOperation</code>为例，进行说明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSBlockOperation</span> * blockOperation;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSBlockOperation</span> * operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"被依赖的操作任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operation1 addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"被依赖的操作任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//对于操作系统资源来说的相对优先级(重要性)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.blockOperation.qualityOfService = <span class="built_in">NSQualityOfServiceDefault</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//操作队列中操作的执行优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.blockOperation.queuePriority = <span class="built_in">NSOperationQueuePriorityNormal</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务2：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation setCompletionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"其他任务执行完毕，此任务最后执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation addDependency:operation1];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [self.blockOperation removeDependency:operation1];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self.blockOperation.dependencies:%@"</span>, <span class="keyword">self</span>.blockOperation.dependencies);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operation1 start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation start];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//相对当前线程是否为异步操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.blockOperation.asynchronous)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"异步执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"非异步执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.blockOperation.completionBlock);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"其他任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.blockOperation cancel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">self<span class="variable">.blockOperation</span><span class="variable">.dependencies</span>:(    <span class="string">"&lt;NSBlockOperation: 0x7faaf44069b0&gt;"</span>   )</span></pre></td></tr><tr><td class="code"><pre><span class="line">被依赖的操作任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">被依赖的操作任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">2</span>：&lt;NSThread: <span class="number">0</span>x6000000d0080&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务<span class="number">1</span>：&lt;NSThread: <span class="number">0</span>x6000000ba0c0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">1</span>：&lt;NSThread: <span class="number">0</span>x6000000cc000&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">其他任务执行完毕，此任务最后执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">非异步执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">(<span class="literal">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">其他任务</span></pre></td></tr></table></figure>

<p>首先对于所有操作来说，操作本身相对于当前线程都是串行的，即便操作内部可以执行的代码块之间可以并发。</p>
<p>所以这段例子代码中有很多的代码是看不出效果的。特此说明一下，只是说明用法。</p>
<p>可以通过<code>addDependency</code>添加依赖操作，可以通过<code>removeDependency</code>移除依赖，可以通过<code>dependencies</code>查看依赖状态。本段代码定义的两个操作本身对于执行流程来说就是串行的，先执行的任务会先输出，但是可以通过<code>dependencies</code>来查看依赖。添加依赖的目的在于添加依赖后，被依赖的操作要全部先执行完毕，才会执行依赖其它操作的任务本身。添加依赖要先启动依赖依然在启动本任务执行，否则会报错。</p>
<p>这里的调用<code>cancel</code> 方法是看不到效果的。<code>cancel</code>方法不会强制停止操作，会更新操作对象内部标志以反映状态变化。对于已完成的执行，<code>cancel</code>无效。可以取消在操作队列中，但尚未执行的操作，会比正常执行的操作更快的从队列中删除。</p>
<p><code>completionBlock</code>为该操作的主要任务完成后执行的代码，该任务块会在操作被标记为<code>finsihed</code>的情况下调用，也就是说在操作被取消的情况下，操作最后也会被标记为<code>finished</code>状态也会执行，所以在该任务块内不应该执行相当于操作任务块的任务内容，而可以添加一些与操作相关，但不属于该任务的其他任务。当<code>completionBlock</code>开始执行后，其会被设置为<code>nil</code>。</p>
<p>可以通过以下方法查看操作状态：<code>cancelled</code>操作是否已取消；<code>executing</code>操作是否正在执行；<code>finished</code>操作是否已经结束；<code>asynchronous</code>相对当前线程来说，操作是否为异步操作；<code>ready</code>是否可以立即执行该操作。</p>
<p>单一的操作不要调用<code>waitUntilFinished</code>方法，并且应避免在与其自身提交到同一操作队列的任何操作上调用它。容易造成死锁问题。此方法的典型用法是从最初创建操作的代码中调用它。将操作提交到队列后，您将调用此方法以等待该操作完成执行。</p>
<p><code>NSOperationQueue</code>操作队列，是根据操作的优先级和准备状态来进行排队的。将操作添加到操作队列后，队列就保留操作，直到操作完成。添加操作后，无法直接删除。操作多列将保留操作直到所有操作完成。挂起未完成的操作，可能导致内存泄露。如需按照特定的顺序执行，需要添加依赖来保证执行顺序。</p>
<p>取消操作，会将操作对象保留在队列中，会通知该对象尽快停止其任务。对于正在执行的操作，意味着操作对象的工作代码必须检查取消状态，停止正在执行的操作并将其标记为完成状态。对于已经排队但未执行的操作，队列仍然会调用其<code>start</code>方法，以便它可以处理取消事件并将自身标记为完成状态。</p>
<p>操作队列时线程安全的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSOperationQueue</span> * operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation1 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task1) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task2) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSBlockOperation</span> * blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1：%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperation:operation1];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperation:operation2];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperation:blockOperation];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [operationQueue addOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"operationQueue追加的操作:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task2 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务2:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">2</span>:&lt;NSThread: <span class="number">0</span>x600000bba200&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600000bbd180&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600000bcbf80&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationQueue追加的操作:&lt;NSThread: <span class="number">0</span>x600000bbd740&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600000b96fc0&gt;&#123;number = <span class="number">7</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>因并发执行，顺序是不定的，<code>NSOperationQueue</code>可以添加附加功能及属性设置来控制执行，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> * operationQueue;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.operationQueue.name = <span class="string">@"OQ"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//设置服务质量(类似优先级)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.operationQueue.qualityOfService = <span class="built_in">NSQualityOfServiceDefault</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"穿插的操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue setUnderlyingQueue:queue];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//操作队列的最大并发数，也就是一次能最多执行多少个任务，可以自定义，如果定义为1，则功能是串行，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//任务会一个执行完毕执行另一个，如不设置则系统会根据不同的环境有不同的默认值。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [operationQueue1 setMaxConcurrentOperationCount:2];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation1 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task1) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSInvocationOperation</span> * operation2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task2) object:<span class="literal">nil</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSBlockOperation</span> * blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [blockOperation addExecutionBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"blockOperation追加任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addOperation:blockOperation];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addBarrierBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"障碍(栅栏)执行"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addOperationWithBlock:^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"operationQueue追加的操作:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//通过组的方式添加上到操作队列，waitUntilFinished表示是否阻塞当前线程直到多列中所有操作完成 是则阻塞等待完成，否不阻塞，直接返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue addOperations:@[operation1, operation2] waitUntilFinished:<span class="literal">NO</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//阻塞当前线程，直到队列中所有任务都完成。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [operationQueue1 waitUntilAllOperationsAreFinished];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    NSLog(@"count:%lu", (unsigned long)self.operationQueue.operationCount);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"其他任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task1 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务1:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)task2 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"InvocationOperation任务2:%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">self</span>.operationQueue cancelAllOperations];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//    [self.operationQueue setSuspended:NO];</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">穿插的操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">mainQueue:&lt;NSOperationQueue: <span class="number">0</span>x7fab75404050&gt;&#123;name = 'NSOperationQueue Main Queue'&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">currentQueue:&lt;NSOperationQueue: <span class="number">0</span>x7fab75404050&gt;&#123;name = 'NSOperationQueue Main Queue'&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">其他任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x600003204480&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">blockOperation追加任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x60000324fc00&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">障碍(栅栏)执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">2</span>:&lt;NSThread: <span class="number">0</span>x600003204480&gt;&#123;number = <span class="number">6</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">operationQueue追加的操作:&lt;NSThread: <span class="number">0</span>x60000324fc00&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">InvocationOperation任务<span class="number">1</span>:&lt;NSThread: <span class="number">0</span>x60000322fd80&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>来对代码做下说明：</p>
<p>操作队列创建后可以设置名字，方便<code>debug</code>。<br>可以通过<code>qualityOfService</code>设置服务质量，如不设置，则会采用默认服务质量<code>NSOperationQualityOfServiceBackground</code>，主队列的服务质量为<code>NSOperationQualityOfServiceUserInteractive</code>且无法修改。服务质量会影响操作系统对CPU，网络资源，磁盘资源等的访问优先级，具有较高服务质量的操作比系统资源具有更高的优先级，会更快的执行其任务，但是并不建议使用，如非特殊，可以采用默认优先级即可，系统自身的调度会更合理高效的分配资源。<br>可以通过<code>setUnderlyingQueue</code>操作向队列中添加<code>dispatch_queue_t</code>类型的队列。<br><code>addBarrierBlock</code>方法可以添加障碍(栅栏)块任务，关于栅栏任务的执行方式，可以看<a href="http://www.mwpush.com/content/aeb8f67e.html">[IOS.OC]GCD的使用精解(二)</a>文章中对<code>dispatch_barrier_async</code>的说明，工作原理是一样的。<br>使用<code>waitUntilAllOperationsAreFinished</code>方法时，要将此方法的调用放在最后面，否则没效果。<br><code>cancelAllOperations</code>取消所有操作，就是让操作队列中的所有操作都调用各自的<code>cancel</code>方法。</p>
<p>可以通过<code>suspended</code>方法挂起或继续执行操作多列。</p>
<h5 id="5-GCD"><a href="#5-GCD" class="headerlink" title="5.GCD"></a>5.GCD</h5><p>关于<code>GCD</code>的介绍可以看下列文章：</p>
<p><a href="http://www.mwpush.com/content/d771b58d.html">[IOS.OC]GCD的使用精解(-)</a></p>
<p><a href="http://www.mwpush.com/content/aeb8f67e.html">[IOS.OC]GCD的使用精解(二)</a></p>
<p><a href="http://www.mwpush.com/content/d04bd655.html">[IOS.OC]GCD的使用精解(三)</a></p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>多线程</tag>
        <tag>multithreading</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]GCD的使用精解(三)</title>
    <url>/content/d04bd655.html</url>
    <content><![CDATA[<h4 id="一、Dispatch-Semaphore"><a href="#一、Dispatch-Semaphore" class="headerlink" title="一、Dispatch Semaphore"></a>一、<code>Dispatch Semaphore</code></h4><p>使用信号量可以达到控制并发数和线程锁的目的。它通过持有计数的信号的增减来控制访问。当计数为0时等待，计数大于等于1时，减1继续执行。</p>
<p><code>dispatch_semaphore_create</code>通过初始值创建一个信号量，有一个参数，为<code>long</code>类型，即初始值，应大于等于0，返回值为<code>dispatch_semaphore_t</code>类型信号量；</p>
<a id="more"></a>
<p><code>dispatch_semaphore_signal</code>发信号，即信号量值增加。有一个参数，为<code>dispatch_semaphore_t</code>类型信号量。</p>
<p><code>dispatch_semaphore_wait</code>等待信号量，即信号量减少。有两个参数，第一个为<code>dispatch_semaphore_t</code>类型信号量，第二个为<code>dispatch_time_t</code>类型超时时间。返回值为<code>long</code>类型，返回值为0则等待时间未超时，不为0则超时。</p>
<p><code>dispatch_semaphore_signal</code>与<code>dispatch_semaphore_wait</code>的调用要保持平衡。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第%d次执行"</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上述代码为异步并发队列，此时输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">第<span class="number">0</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">4</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">2</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">5</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">3</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">6</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">7</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">9</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">8</span>次执行</span></pre></td></tr></table></figure>

<p>为无序输出，我们可以通过串行队列达到依次输出的目的，也可以使用信号量来控制，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第%d次执行"</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dispatch_semaphore_signal(semaphore);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">第<span class="number">0</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">1</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">2</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">3</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">4</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">5</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">7</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">6</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">8</span>次执行</span></pre></td></tr><tr><td class="code"><pre><span class="line">第<span class="number">9</span>次执行</span></pre></td></tr></table></figure>

<p>我们创建的信号量初始值为1，当执行<code>dispatch_semaphore_wait</code>方法时信号计数减1为0，所以此时如果有其他线程要执行同样的方法，因为信号计数为0需等待，无法继续执行。当执行<code>dispatch_semaphore_signal</code>方法时，信号计数加1，则<code>dispatch_semaphore_wait</code>方法将信号计数减1并继续执行，依次往复。</p>
<p>可见，信号量可以在多个线程间通过信号计数来协调控制访问处理。我们可以通过信号计数的值的控制来控制最大并发数，只要信号计数大于0就可以不用等待并发执行。</p>
<h4 id="二、Dispatch-Source"><a href="#二、Dispatch-Source" class="headerlink" title="二、Dispatch Source"></a>二、<code>Dispatch Source</code></h4><p>调度源，是用来监视低级系统事件的对象，在事件发生时，自动在指定的<code>Dispatch Queue</code>中执行指定的处理事件。</p>
<h5 id="1-自定义调度源"><a href="#1-自定义调度源" class="headerlink" title="1.自定义调度源"></a>1.自定义调度源</h5><p><code>dispatch_source_create</code>创建一个调度源来监视低级系统事件。有4个参数，第一个为<code>dispatch_source_type_t</code>类型，是一个结构体常量指针，用来定义调度源的类型，也就是调度源监视的低级系统对象类型的标识符，需要根据这个参数来确定第二个和第三个参数的解释方式。第二个参数为<code>uintptr_t</code>即<code>unsigned long</code>类型的要监视的底层系统句柄，这个值的设定是根据第一个参数来确定的，通过一个参数来确定这个参数是作为文件描述符、mach端口、信号数，还是进程标识符等，第三个参数为<code>unsigned long</code>类型的事件所需的标志掩码，这个值的设定也是根据第一个参数来确定的，系统提供了这个值的固定参数，第四个参数为监听到指定事件时调用的处理事件所要提交到的队列。返回值为<code>dispatch_source_t</code>类型的调度源。调度源是在非活动状态下创建的。上一篇文章中我们介绍到<code>dispatch_resume</code>与<code>dispatch_suspend</code>应该匹配使用，成对出现，否则会引发崩溃，但是有一个例外，就是这里的调度源，在官方对<code>dispatch_resume</code>的介绍中，说到新创建的调度源挂起计数为1，必须要在事件传递前将其恢复。而在官方对<code>dispatch_source_create</code>的说明中说到，出于向后兼容的原因，<code>dispatch_resume</code>在一个非活动的、而不是挂起的源上，与<code>dispatch_activate</code>的作用相同。所以我们也姑且称之为“非活动状态”。官方建议在调度源中使用<code>dispatch_activate</code>来激活调度源。</p>
<p><img src="/content/d04bd655/20191224_01.png" alt></p>
<p>2.<code>dispatch_source_merge_data</code>将数据合并到<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>或<code>DISPATCH_SOURCE_TYPE_DATA_OR</code>类型的调度源中，并将其事件处理程序提交到目标队列。两个参数，第一个为调度源，第二个参数为<code>unsigned long</code>类型，是要提交的数据，不能为0，为0不会出发提交事件处理程序块，也不能为负数。</p>
<p><code>dispatch_source_set_event_handler</code>为给定的调度源设置事件处理程序块。有两个参数，第一个为目标调度源，第二个为要执行的程序块。此方法是设置要提交到目标调度源中指定的队列的程序块。同一时间只能有一个任务块被执行，如果当另一次提交事件发生时，当前程序块还没有执行完毕，则会以指定的方式(创建调度源时指定的<code>ADD</code>或<code>OR</code>)进行积累合并，有效解决了频繁提交带来的处理事件的压力。</p>
<p><code>dispatch_source_get_data</code>返回调度源的待处理数据，有一个参数为调度源。此方法应在事件处理程序块中调用(也就是<code>dispatch_source_set_event_handler</code>中)，在事件处理程序回调之外调用此函数结果是不确定的。通过此方法可以获取调度源中的当前值，并将数据清零。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_activate(source);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="number">5</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(size_t index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_source_merge_data(source, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span></pre></td></tr></table></figure>

<p>上面的代码，自定义一个并发队列<code>c_queue</code>，作为定义调度源的使用队列，通过<code>dispatch_source_set_event_handler</code>设置处理事件的程序块，然后激活调度源。然后通过5次迭代将数据<code>1</code>提交到调度源，因为事件提交是连续发生的，程序块还没有执行完毕，会以<code>ADD</code>的方式对数据进行合并，最后输出。如果当提交合并时，程序块已执行完毕，则不会以<code>ADD</code>方式进行合并。</p>
<p>以下验证代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t source;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span>.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>, c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(<span class="keyword">self</span>.source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_activate(<span class="keyword">self</span>.source);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_source_merge_data(<span class="keyword">self</span>.source, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>此时我们点击屏幕，可以输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr></table></figure>

<p>再次验证，未执行完毕，进行合并，修改代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">2</span>); <span class="comment">//添加睡眠，模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(<span class="keyword">self</span>.source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>此时我们连续点击屏幕5次，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr></table></figure>

<p>因为第一次点击要耗时2秒后执行完毕，而点击是在短时间内完成的，所以第一次事件没有执行完毕，后面点击会被系统优化合并。</p>
<h5 id="2-定时器源"><a href="#2-定时器源" class="headerlink" title="2.定时器源"></a>2.定时器源</h5><p><code>dispatch_source_set_timer</code>设置计时器源的开始时间，间隔和回程值。4个参数，第一个为调度源，第二个为<code>dispatch_time_t</code>类型的开始时间，第三个为时间间隔，单位为纳秒，第四个为设置计时精度，单位为纳秒，如果希望很精确(相对来说，没有绝对的精确)，则设置为0，即使设为0，计时器也会有一定的等待时间，如果对精确度要求不高，可以设置为能接受的延迟时间。精确度越低对系统的执行灵活性越高(即系统可以根据延迟时间来配合系统事件执行，延迟时间允许的情况会与其他需要执行的事件一起唤醒执行，而非单单为了计时器单独执行)。</p>
<p>定时器源是有一个掩码值的，为<code>DISPATCH_TIMER_STRICT</code>，但是不建议使用，一般时候使用0就可以，除非对时间的精确度非常高。这个掩码指定<code>dispatch_source_set_timer</code>的延迟参数(leeway)尽最大努力遵守设置的值，设置此标记好，系统会将会应用最小的延迟，也会带来负面影响，比如耗电量大，影响省电技术，应谨慎使用，只有在绝对必要时设置此值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_time_t time_t = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>ull*<span class="built_in">NSEC_PER_SEC</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">uint64_t interval = <span class="number">1</span>ull*<span class="built_in">NSEC_PER_SEC</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_set_timer(source, time_t, interval, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, dispatch_source_get_data(source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_activate(source); <span class="comment">//dispatch_resume(source);</span></span></pre></td></tr></table></figure>

<p>以上代码实现了一个延迟2秒执行，并每隔一秒调用一次程序块的功能，如不需要重复调用，将时间间隔设置为<code>DISPATCH_TIME_FOREVER</code>即可。对于所提交的队列大家可自行选择，这里只是演示的例子。我们可以使用<code>dispatch_suspend</code>来暂停定时器，要对应有启动/继续定时器的<code>dispatch_resume</code>，也可以使用下面的方法取消定时器。</p>
<p><code>dispatch_source_cancel</code>异步取消调度源，以防止进一步调用其事件处理程序块。一个参数为调度源。注意只能取消未被执行的程序块，已经执行的将继续执行完毕(提交的程序块也有可能未来得及执行)。</p>
<p><code>dispatch_source_set_cancel_handler</code>设置目标调度源的取消处理程序块，一个参数为目标调度源。此方法在执行<code>dispatch_source_cancel</code>，且系统释放对源基础句柄的所有引用且所有已处理程序块执行完毕后被调用。</p>
<h5 id="3、其他方法"><a href="#3、其他方法" class="headerlink" title="3、其他方法"></a>3、其他方法</h5><p><code>dispatch_source_get_mask</code> 返回调度源监视的事件掩码。</p>
<p><code>dispatch_source_testcancel</code>测试目标调度源是否已取消。</p>
<p><code>dispatch_source_get_handle</code>返回与指定调度源相关联的基础系统句柄。</p>
<p><code>dispatch_source_set_registration_handler</code>设置给定调度源的注册处理程序块。</p>
<p><code>Dispatch Source</code>官方地址：<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW13" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW13</a></p>
<h4 id="三、Dispatch-I-O与Dispatch-Data介绍"><a href="#三、Dispatch-I-O与Dispatch-Data介绍" class="headerlink" title="三、Dispatch I/O与Dispatch Data介绍"></a>三、<code>Dispatch I/O</code>与<code>Dispatch Data</code>介绍</h4><p>通过使用<code>Dispatch I/O</code>和<code>Dispatch Data</code>可以将大的文件分割成若干小部分进行读取合并。</p>
<p><code>dispatch_io_create</code>创建一个I/O通道，并将其与指定的文件描述相关联。</p>
<p><code>dispatch_io_create_with_path</code>创建具有关联路径的调度I/O通道。</p>
<p><code>dispatch_io_read</code>在指定的通道上调用异步读取操作。</p>
<p><code>dispatch_io_write</code>在指定的通道上调用异步写操作。</p>
<p><code>dispatch_io_close</code>关闭指定的通道以进行新的读写操作。</p>
<p><code>dispatch_io_set_high_water</code>设置在排队处理程序块之前要处理的最大字节数。</p>
<p><code>dispatch_io_set_low_water</code>设置入队处理程序块之前要处理的最小字节数。</p>
<p><code>dispatch_io_set_interval</code>设置间隔，单位为纳秒，在该间隔处调用通道的I/O处理程序。</p>
<p><code>dispatch_read</code>  使用指定的文件描述符调度异步读取操作。</p>
<p><code>dispatch_write</code> 使用指定的文件描述符调度异步写入操作。</p>
<p>调度数据对象提供了一个用于管理基于内存的数据缓冲区的接口。客户端访问数据缓冲区将其视为连续的内存块，但是在内部缓冲区可能由多个不连续的内存块组成。</p>
<p><code>dispatch_data_create</code>使用指定的内存缓冲区创建一个新的调度数据对象。</p>
<p><code>dispatch_data_get_size</code>返回由调度数据对象管理的内存逻辑大小。</p>
<p><code>dispatch_data_create_map</code>返回一个新的调度数据对象，其中包含指定对象内存的连续表示形式。</p>
<p><code>dispatch_data_create_concat</code>返回一个新的调度数据对象，该对象由来自其他两个数据对象的串联数据组成。</p>
<p><code>dispatch_data_create_subrange</code>返回一个新的调度数据对象，其内容由另一个对象的内存区域的一部分组成。</p>
<p><code>dispatch_data_apply</code>遍历调度数据对象的内存，并在每个区域上执行自定义代码。</p>
<p><code>dispatch_data_copy_region</code>返回一个数据对象，该数据对象包含另一个数据对象中的一部分数据。</p>
<p>关于剩下这些内容，来日再更新。。。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>gcd</tag>
        <tag>队列</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]GCD的使用精解(二)</title>
    <url>/content/aeb8f67e.html</url>
    <content><![CDATA[<h4 id="一、dispatch-after"><a href="#一、dispatch-after" class="headerlink" title="一、dispatch_after"></a>一、<code>dispatch_after</code></h4><p>这个方法是指定一个时间，然后一直等待，等到指定的时间后，将块(<code>block</code>)异步提交到指定队列中。注意字眼，是指定时间提交到队列，而非指定时间执行，具体执行情况与队列的调度等有关，如遇到阻塞等情况会延时。所以这个方法最理想，也就是最快的情况是提交后马上执行。所以如果要求精确时间执行，此方法并不适用，而是适用于大致时间执行的时候。</p>
<a id="more"></a>

<p>看下具体的使用代码，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建方式1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>ull*<span class="built_in">NSEC_PER_SEC</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_after(time, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建方式2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>两种创建方式，其实都是一样的。共有三个参数，第一个是<code>dispatch_time_t</code>类型的延迟时间，第二个参数是要提交到的队列，第三个是要执行的代码块。</p>
<p>比如上面的代码，就是从现在(当前时间)开始，延迟2秒执行，也就是2秒后执行(将块提交到队列)。</p>
<p><code>dispatch_time</code>方法返回的是一个<code>dispatch_time_t</code>类型的数据，是一个<code>unsigned long long</code>类的数据。<code>2ull</code>表示的就是<code>unsigned long long</code>类型的<code>2</code>，<code>uul</code>是c语言中的数值字面量，是显示表名类型时使用的字符串。 <code>NSEC_PER_SEC</code>是系统提供的常量值，表示一秒的纳秒(毫微)数，具体时间关系如下：</p>
<blockquote>
<p>1秒(s) =1000 毫秒(ms) = 1,000,000 微秒(μs) = 1,000,000,000 纳秒(ns) = 1,000,000,000,000 皮秒(ps)=1,000,000,000,000,000飞秒(fs)=1,000,000,000,000,000,000仄秒(zs) =1,000,000,000,000,,000,000,000幺秒(ys)1,000,000,000,000,000,000,000,000渺秒(as)</p>
</blockquote>
<p>系统提供了以下几个常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一秒中的毫微秒数</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define NSEC_PER_SEC 1000000000ull</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一秒中的毫秒数</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define NSEC_PER_MSEC 1000000ull</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一秒中的微秒数</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define USEC_PER_SEC 1000000ull</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一微秒中的纳秒数。</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define NSEC_PER_USEC 1000ull</span></pre></td></tr></table></figure>

<p>上面创建时间使用的是<code>dispatch_time</code>，它使用的是相对时间的创建方式，还有一个以绝对时间方式创建的方法<code>dispatch_walltime</code>，当<code>dispatch_time</code>的第一个参数为<code>DISPATCH_WALLTIME_NOW</code>时，等价于<code>dispatch_walltime</code>第一个参数为<code>NULL</code>时创建的时间。</p>
<p><code>dispatch_walltime</code>有两个参数，第一个为<code>struct timespec</code>的结构体，第二个为<code>int64_t</code>类型的延迟时间。<br><code>timespec</code>结构体中有两个变量，一个是<code>tv_sec</code>为整秒数，一个是<code>tv_nsec</code>为纳秒数。比如我们要在未来的某一时间执行，也可以通过下面的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> timespec s_time;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> second, decimals;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSDate</span> * date = [[<span class="built_in">NSDate</span> date] dateByAddingTimeInterval:<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimeInterval</span> timeInterval = [date timeIntervalSince1970];;</span></pre></td></tr><tr><td class="code"><pre><span class="line">decimals = modf(timeInterval, &amp;second);</span></pre></td></tr><tr><td class="code"><pre><span class="line">s_time.tv_sec = second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">s_time.tv_nsec = decimals * <span class="built_in">NSEC_PER_SEC</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_walltime(&amp;s_time, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_after(time, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>以上代码实现了从当前时间开始2秒后执行，<code>double modf(double, double*)</code>函数返回浮点数的小数部分，整数部分放在指针<code>double *</code>中。</p>
<p>两种方法的时间原理是不一样的，第一种是从现在开始多少秒后执行，第二种是定义了未来的一个时间点，到时间执行。</p>
<h4 id="二、dispatch-once"><a href="#二、dispatch-once" class="headerlink" title="二、dispatch_once"></a>二、<code>dispatch_once</code></h4><p>在应用程序的声明周期内，只执行一次块对象。此方法有两个参数，第一个参数为指向<code>dispatch_once_t</code>类型的指针，第二个为要执行一次的代码块对象。</p>
<p><code>dispatch_once_t</code>是专门为<code>dispatch_once</code>方法提供的参数类型，作为只执行一次的标记使用，所以必须定义在全局或静态作用域中。</p>
<p>使用方式如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行性一次的代码"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>dispatch_once</code>经常在创建单例的时候使用，我们经常使用以下方式创建单例，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> SomeClass * shareClass = <span class="literal">nil</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!shareClass)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shareClass = [[SomeClass alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> shareClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为了保证线程安全，我们还需要加锁，如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> SomeClass * shareClass = <span class="literal">nil</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!shareClass)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            shareClass = [[SomeClass alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> shareClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这样就增加了方法执行的开销，而使用<code>dispatch_once</code>方法是提供线程安全的，从多个线程同时调用时，此方法将同步等待，直到代码块执行完毕。</p>
<p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> SomeClass * shareClass = <span class="literal">nil</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shareClass = [[SomeClass alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> shareClass;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>两种创建单例的方式，使用<code>dispatch_once</code>将更高效，它使用“原子访问(atomic access)”来查询标记，来判断对应的代码块是否执行过。而<code>@synchronized</code>隐式添加额外的异常处理等，增加了开销。代码中应避免大量使用<code>@synchronized</code>。</p>
<h4 id="三、dispatch-set-target-queue"><a href="#三、dispatch-set-target-queue" class="headerlink" title="三、dispatch_set_target_queue"></a>三、<code>dispatch_set_target_queue</code></h4><p>设置给定对象的目标队列。为指定对象设置一个目标队列，有两种用途，改变给定对象的优先级和合并多个串行队列。<br>第一个参数为给定队列，第二个为目标队列。</p>
<h5 id="1-改变队列优先级"><a href="#1-改变队列优先级" class="headerlink" title="1.改变队列优先级"></a>1.改变队列优先级</h5><p><code>dispatch_get_global_queue</code>方法是直接能设置优先级的，而我们自定义的队列是不能设置优先级的，它默认的优先级就是<code>dispatch_get_global_queue</code>的默认优先级，即<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。既然要改变给定队列的优先级，就可以将<code>dispatch_get_global_queue</code>作为目标队列，通过<code>dispatch_get_global_queue</code>的优先级设置来改变自定义队列的优先级。看如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gh_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gl_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue, gh_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(gl_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"低优先级1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(gl_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"低优先级2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(gl_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"低优先级3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">高优先级<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">高优先级<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">高优先级<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">低优先级<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">低优先级<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">低优先级<span class="number">2</span></span></pre></td></tr></table></figure>

<p>我们定义的是并发队列，所以输出的顺序不定，但是高优先级的输出会先输出。</p>
<p>但是需要注意的是，这个优先级除非相差很多，比如一个高一个低或者后台，这样效果会很明显，如果相差不多，比如<code>DISPATCH_QUEUE_PRIORITY_HIGH</code>和<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>，输出结果就会不定，也许高先输出，也许低先输出，所以说，对于优先级的设置只是一个衡量值，只是一个大致的判断，并不是每次都按照优先级的设置执行。</p>
<p>通过上面的方法我们将自定义队列设置成高或默认优先级，当同样定义一个串行队列(<code>Serial Dispatch Queue</code>) 时与主队列做对比发现，当自定义队列优先级设置为<code>DISPATCH_QUEUE_PRIORITY_HIGH</code>或<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>时，几乎每次都是比主队列先输出，所以可以说主队列的优先级还是比较低的(测试判断、猜测)。</p>
<p>当我们试图改变主队列优先级时发现，无论主队列优先级设置成高低，对结果的输出都没有任何影响，结果依然遵循上一条的规律，所以似乎可以得出结论，主队列的优先级是无法更改的，这里的代码比较简单，这里不多做说明，大家可以自己试试。</p>
<h5 id="2-合并多个串行多列为一个队列"><a href="#2-合并多个串行多列为一个队列" class="headerlink" title="2.合并多个串行多列为一个队列"></a>2.合并多个串行多列为一个队列</h5><p>我们实现并发有多重途径，使用并发队列并异步执行，也可以创建多个串行队列达到并发的目的。但是创建多个串行队列会创建多个线程，增加了系统的开销，如果想将多个串行队列归并为一个串行队列就可以用到<code>dispatch_set_target_queue</code>方法，代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue1 = dispatch_queue_create(<span class="string">"com.mwpush1"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue2 = dispatch_queue_create(<span class="string">"com.mwpush2"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue3 = dispatch_queue_create(<span class="string">"com.mwpush3"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> t_queue  = dispatch_queue_create(<span class="string">"com.mwpusht"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue1, t_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue2, t_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_target_queue(s_queue3, t_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(t_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"目标队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue1, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue2, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue3, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"串行队列3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">目标队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">串行队列<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">串行队列<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">串行队列<span class="number">3</span></span></pre></td></tr></table></figure>

<p>因为是串行队列，输出顺序就是按照添加的顺序输出的，先进先出，这里要注意参数的顺序，第二个参数为目标队列，设置错误也会正常运行，但是达不到想要的目的。如果是并发队列则没有任何意义，添加后仍然是并发，并没有任何影响。</p>
<p>也要注意不要讲A设置为B的目标队列，而又把B设置为A的目标队列，这是错误的做法，不会有任何输出。</p>
<h4 id="四、dispatch-apply"><a href="#四、dispatch-apply" class="headerlink" title="四、dispatch_apply"></a>四、<code>dispatch_apply</code></h4><p>此方法主要用于将一个块提交到调度队列进行多次调用。为同步方法，会等任务块迭代执行完毕返回。如果目标队列为串行队列，则块任务顺序执行，如果为并发队列，则并发执行，顺序不定。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1-%zu"</span>, index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并发队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1-%zu"</span>, index);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span>-<span class="number">9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr></table></figure>

<p>当队列为并发队列时，会为任务创建多个线程并发执行，来提高执行效率。</p>
<p>由于<code>dispatch_apply</code>方法为同步方法，会阻塞线程，所以使用时，如非同步要求，应将其添加到异步方法<code>dispatch_async</code>中执行。</p>
<h4 id="五、dispatch-suspend与dispatch-resume"><a href="#五、dispatch-suspend与dispatch-resume" class="headerlink" title="五、dispatch_suspend与dispatch_resume"></a>五、<code>dispatch_suspend</code>与<code>dispatch_resume</code></h4><p><code>dispatch_suspend</code>挂起(暂停)调度对象上块的调用，参数为要挂起的调度队列或调度源，不能挂起其他类型的调度对象。</p>
<p><code>dispatch_resume</code>恢复调度对象上块的调用，参数为要恢复的对象。</p>
<p><code>dispatch_suspend</code>和<code>dispatch_resume</code>使用的是类似引用计数的方式，挂起一次意味着计数加一，恢复一次意味着计数减一，当计数大于零时，对象保持挂起状态，所以使用时，应匹配<code>dispatch_suspend</code>与<code>dispatch_resume</code>的调用来达到平衡。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"挂起队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_suspend(c_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"恢复队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_resume(c_queue);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">挂起队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//下面输出为2秒后队列恢复执行后输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">恢复队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr></table></figure>

<p>注意，挂起队列只能挂起还没有执行的任务，已经执行或正在执行的任务无法挂起。<code>dispatch_suspend</code>与<code>dispatch_resume</code>要成对出现，否则会引起崩溃。</p>
<p>全局并发队列<code>dispatch_get_global_queue</code>和主队列<code>dispatch_get_main_queue</code>中是无法使用<code>dispatch_suspend</code>、<code>dispatch_resume</code>的(使用后不起任何效果)。</p>
<h4 id="六、dispatch-queue-set-specific与dispatch-get-specific"><a href="#六、dispatch-queue-set-specific与dispatch-get-specific" class="headerlink" title="六、dispatch_queue_set_specific与dispatch_get_specific"></a>六、<code>dispatch_queue_set_specific</code>与<code>dispatch_get_specific</code></h4><p><code>dispatch_queue_set_specific</code>用来设置指定队列的键值数据。有4个参数，第一个是<code>dispatch_queue_t</code>类型定义的队列，也就是要添加键值的队列，第二个是<code>const void *</code>类型的键，通过键来查找值时是通过指针的值来做比较的，可以使用静态变量的指针或其他可以唯一标识该值的值。第三个是<code>void *</code>类型键对应的值，第四个是<code>dispatch_function_t</code>类型的析构函数，用来释放上下文数据，可为空(<code>NULL</code>)，当键对应的值使用ARC不能管理内存方式的参数时，在此释放。</p>
<p><code>dispatch_queue_get_specific</code>获取与指定队列关联的键的值。有两个参数，第一个是<code>dispatch_queue_t</code>类型，第二个是<code>const void *</code>类型的键。</p>
<p><code>dispatch_get_specific</code>返回与当前队列相关联的键的值。有一个参数，为<code>const void *</code>类型的键。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * kQueueAKey = <span class="string">"s_queueA"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * kQueueBKey = <span class="string">"s_queueB"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queueA = dispatch_queue_create(<span class="string">"com.mwpushA"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queueB = dispatch_queue_create(<span class="string">"com.mwpushB"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_queue_set_specific(s_queueA, kQueueAKey, kQueueAKey, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_queue_set_specific(s_queueB, kQueueBKey, kQueueBKey, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queueA, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    __block <span class="keyword">char</span> * specificAValue = dispatch_get_specific(kQueueAKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * specificGetAValue = dispatch_queue_get_specific(s_queueA, kQueueAKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * specificGetBValue = dispatch_queue_get_specific(s_queueB, kQueueBKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A队列键对应的值%s"</span>,specificGetAValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"B队列键对应的值%s"</span>,specificGetBValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(specificAValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"获取A队列，值非空，证明是A队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"获取A队列，值为空，则不是A的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(s_queueB, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        specificAValue = dispatch_get_specific(kQueueAKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(specificAValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"获取A队列，值非空，证明是A队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">char</span> * specificGetBValue = dispatch_queue_get_specific(s_queueB, kQue</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(specificGetBValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"获取B队列，值非空，证明是B队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"获取B队列，值为空，则不是B的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> * specificGetAValue = dispatch_queue_get_specific(s_queueA, kQueueAK</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> * specificGetBValue = dispatch_queue_get_specific(s_queueB, kQueueBK</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"A队列键对应的值%s"</span>,specificGetAValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"B队列键对应的值%s"</span>,specificGetBValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">A队列键对应的值s_queueA</span></pre></td></tr><tr><td class="code"><pre><span class="line">B队列键对应的值s_queueB</span></pre></td></tr><tr><td class="code"><pre><span class="line">获取A队列，值非空，证明是A队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">获取B队列，值非空，证明是B队列</span></pre></td></tr><tr><td class="code"><pre><span class="line">A队列键对应的值s_queueA</span></pre></td></tr><tr><td class="code"><pre><span class="line">B队列键对应的值s_queueB</span></pre></td></tr></table></figure>

<p>总结：<code>dispatch_queue_get_specific</code>是根据键查找指定队列的对应的值，只要定义过，在后续执行中在哪都能输出，无论是否在当前队列。而<code>dispatch_get_specific</code>只有所在的是当前队列时，才会输出队列的值，否则为空。</p>
<p>参数设置的其他方式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> kQueneKey;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">CFStringRef</span> value = <span class="built_in">CFSTR</span>(<span class="string">"s_queue"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_queue_set_specific(s_queue, &amp;kQueneKey, (<span class="keyword">void</span> *)value, (dispatch_function_t)<span class="built_in">CFRelease</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFStringRef</span> specificGetValue = dispatch_queue_get_specific(s_queue, &amp;kQueneKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"队列键对应的值%@"</span>,specificGetValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFStringRef</span> specificValue = dispatch_get_specific(&amp;kQueneKey);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(specificValue) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"值非空，证明是获取的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"值为空，则不是想获取的队列"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p><code>dispatch_get_current_queue</code>在 iOS 6.0以后已废弃，它会引发一系列问题，而且返回的值有时也不是很准，只能用在代码调试阶段，不能用于<code>Release</code>版本。在<code>Release</code>版本中可以使用上述方法。</p>
<h4 id="七、dispatch-queue-get-label"><a href="#七、dispatch-queue-get-label" class="headerlink" title="七、dispatch_queue_get_label"></a>七、<code>dispatch_queue_get_label</code></h4><p>返回目标队列的标签，参数为目标队列，返回值为<code>const char *</code>类型的标签名字符串。如未设置标签则返回<code>NULL</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * labelName = dispatch_queue_get_label(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, labelName);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">com<span class="variable">.mwpush</span></span></pre></td></tr></table></figure>



<h4 id="八、dispatch-set-context与dispatch-get-context"><a href="#八、dispatch-set-context与dispatch-get-context" class="headerlink" title="八、dispatch_set_context与dispatch_get_context"></a>八、<code>dispatch_set_context</code>与<code>dispatch_get_context</code></h4><p>将自定义的上下文与目标对象关联，需根据需要分配和取消数据分配。比如<code>malloc</code>出来的数据就要有对应的<code>free</code>，<code>new</code>出来的就得<code>delete</code>。</p>
<p><code>dispatch_set_context</code>有两个参数，第一个参数为<code>dispatch_object_t</code>类型的目标对象，第二个参数为<code>const void *</code>类型的上下文。</p>
<p><code>dispatch_get_context</code>获取上下文数据，一个参数，为<code>dispatch_object_t</code>类型对象。</p>
<p><code>dispatch_set_finalizer_f</code>终结器方法，用来调用在对应队列上下文中开辟的内存等的清理方法。两个参数，第一个为目标队列，第二个为<code>dispatch_function_t</code>类型函数指针。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_set_context(s_queue, <span class="string">"www.mwpush.com"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * mycontext = dispatch_get_context(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, mycontext);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">www<span class="variable">.mwpush</span><span class="variable">.com</span></span></pre></td></tr></table></figure>

<p>上面我们只是简单的设置了一个字符串常量，没有涉及到动态开辟内存的问题，如果涉及则需要手动处理，以下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Person &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> * name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; Student;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> cleanData(<span class="keyword">void</span> *context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="built_in">NSLog</span>(<span class="string">@"清理释放"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    free(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setContextData &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Student * student = (Student *)malloc(<span class="keyword">sizeof</span>(Student));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    student-&gt;name = <span class="string">"zhangsan"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    student-&gt;age = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_context(s_queue, student);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_finalizer_f(s_queue, &amp;cleanData);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Student * myStudent = dispatch_get_context(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, myStudent-&gt;name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">zhangsan</span></pre></td></tr><tr><td class="code"><pre><span class="line">清理释放</span></pre></td></tr></table></figure>

<p>如果上下文为<code>Foundation</code>对象，因为参数为<code>void *</code>类型，需要做桥接处理，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person类代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//实现代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了dealloc"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>调用处理代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> cleanData(<span class="keyword">void</span> *context) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"清理释放"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">CFRelease</span>(context);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setContextData &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person *person = [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.name = <span class="string">@"zhangsan"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    person.age = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_context(s_queue, (__bridge_retained <span class="keyword">void</span> *)person);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_set_finalizer_f(s_queue, &amp;cleanData);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_async</span>(s_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Person * myPerson = (__bridge Person *)dispatch_get_context(s_queue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, myPerson.name);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">zhangsan</span></pre></td></tr><tr><td class="code"><pre><span class="line">清理释放</span></pre></td></tr><tr><td class="code"><pre><span class="line">调用了dealloc</span></pre></td></tr></table></figure>



<h4 id="九、dispatch-barrier-async与dispatch-barrier-sync"><a href="#九、dispatch-barrier-async与dispatch-barrier-sync" class="headerlink" title="九、dispatch_barrier_async与dispatch_barrier_sync"></a>九、<code>dispatch_barrier_async</code>与<code>dispatch_barrier_sync</code></h4><p><code>dispatch_barrier_async</code>提交一个异步执行的障碍(也有叫栅栏)块到目标队列，并立即返回。有两个参数，第一个是目标队列，第二个是要提交到目标队列的障碍块。此方法需与自定义的并发队列一起使用才能发挥出其特有的效果。与自定义的并发队列(通过<code>dispatch_queue_create</code>创建出的<code>Concurrent Dispatch</code>)一起使用时，<code>barrier</code>提交的块不会与该队列上的其他块同时运行。它会等待它插入位置之前的块执行完成(当前执行的所有操作)，然后执行提交的障碍块并阻塞队列上的待执行内容，等障碍块执行完毕，继续执行后续操作。如果<code>barrier</code>提交的块不是与自定义的并发队列一起使用，则功能类似于<code>dispatch_async</code>。</p>
<p><code>dispatch_barrier_sync</code>提交一个同步执行的障碍块到目标队列，并等待该块执行完毕。有两个参数，第一个是目标队列，第二个是要提交到目标队列的障碍块。此方法也同样需要与自定义的并发队列一起使用，此时会等待其块任务插入之前的任务执行完毕然后执行，并阻塞队列上的执行内容，且阻塞<code>dispatch_barrier_sync</code>方法所在的线程。如果与<code>dispatch_get_global_queue</code>或串行队列(包括主队列与自定义串行队列)一起使用，则相当于<code>dispatch_sync</code>。注意，因为是同步方法，所以当其目标队列与当前所在队列为同一队列时，将造成死锁，关于这个可以看 <a href="http://www.mwpush.com/content/d771b58d.html">GCD的使用精解(-)</a> 中对死锁的说明。</p>
<p>关于<code>dispatch_barrier_sync</code>的代码这里就不在写了，需要说明的是，当与<code>dispatch_get_global_queue</code>一起使用时，<code>barrier</code>提交块任务不能保证当其执行时，其前序任务都已执行完毕，有可能先执行<code>barrier</code>提交的块任务。</p>
<p><code>dispatch_barrier_async</code> 示例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_barrier_async(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"循环任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(c_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"其他任务"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">其他任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">循环任务</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//以下为barrier循环执行完毕后，延迟2秒输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr></table></figure>

<p>通过输出可以看出，<code>dispatch_barrier_async</code>并不阻塞主线程任务的执行，只是阻塞目标队列的后续块任务，待其执行完毕，后续任务按原始执行操作继续执行。</p>
<p>当其与<code>dispatch_get_global_queue</code>或串行队列(包括主队列与自定义串行队列)一起使用时，功能与<code>dispatch_async</code>相同。全局并发队列属于共享资源，不允许单个组件对其进行阻塞(说的是队列阻塞，而非线程)。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>gcd</tag>
        <tag>队列</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]GCD的使用精解(-)</title>
    <url>/content/d771b58d.html</url>
    <content><![CDATA[<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p><code>GCD(Grand Central Dispatch)</code>，大中枢派发，是一套基于C语言的多线程开发框架，它提供了一个易用的抽象层，使开发者不需要处理底层的线程管理就可以充分利用系统的多核特性，可以自动平衡系统资源分配方式，提高系统资源的利用率，是异步执行任务的技术之一。                                                                          </p>
<p><code>GCD API</code>的核心概念是调度队列，对线程的操作实际上是由调度队列完成的，开发者只需将任务添加到调度队列即可，系统负责线程的创建、管理，提交给调度队列的任务会在完全受系统管理的线程池上执行。因为线程的管理由系统执行，系统会根据系统占用资源相对合理分配资源，比传统的线程提高了效率。</p>
<a id="more"></a>

<h4 id="二、Dispatch-Queue-派发队列"><a href="#二、Dispatch-Queue-派发队列" class="headerlink" title="二、Dispatch Queue 派发队列"></a>二、<code>Dispatch Queue</code> 派发队列</h4><h5 id="1-主队列"><a href="#1-主队列" class="headerlink" title="1.主队列"></a>1.主队列</h5><p>主队列任务在主线程中执行，会阻塞主线程，是一个串行队列，可以通过以下方式获取，代码(1-1)，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_queue_main_t m_queue = dispatch_get_main_queue();</span></pre></td></tr></table></figure>
<p>PS：主队列是在调用<code>main</code>函数之前由系统自动创建的，并将其与程序的主线程相关联。由于主队列运行在应用程序的主线程上，因此通常用作应用程序的关键同步点。</p>
<h5 id="2-全局并发队列"><a href="#2-全局并发队列" class="headerlink" title="2.全局并发队列"></a>2.全局并发队列</h5><p>共享当前进程资源，提交到此队列的任务是无序的并发执行。获取方式代码(1-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_queue_global_t g_queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr></table></figure>

<p>第一个参数为执行的优先级，定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最高优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//中等优先级，为默认优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//低优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//后台优先级，级别最低</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span></pre></td></tr></table></figure>

<p>现在优先级已被服务质量QOS(quality of service)所取代，服务质量可用于<code>GCD</code>和<code>NSOperation</code>，且苹果建议最好用Qos来代替全局并发优先级。服务质量对应优先级代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span></pre></td></tr></table></figure>

<p>PS：设置优先级并不能保证执行的实时性，只是大致的判断。</p>
<p>第二个为系统保留参数，可传入<code>NULL</code>或0。</p>
<h5 id="3-自定义队列"><a href="#3-自定义队列" class="headerlink" title="3.自定义队列"></a>3.自定义队列</h5><p>自定义派发队列有两种，<code>Serial Dispatch Queue</code>串行队列，<code>Concurrent Dispatch Queue</code>并发队列。串行队列需要一个执行结束，才能继续执行下一个任务。</p>
<p>并发队列则不需要等待，按FIFO入队后无需等待前一个任务执行完毕在执行，而是入队后便开始执行，并发队列中的任务可以同时运行。无论串行还有并发队列，都严格按照FIFO顺序进队出队。</p>
<p>自定义队列的创建方式代码(1-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_SERIAL);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//并发队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush.www"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr></table></figure>
<p>第一个参数为队列的名称，一般命名方式为域名倒叙，也可以不命名，传入<code>NULL</code>，但是命名对于调式查找非常有帮助。</p>
<p>第二个参数为队列属性，即串行或并发。当为串行时，可直接传入<code>NULL</code>，并发时则需传入<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<h4 id="三、派发任务到队列并执行"><a href="#三、派发任务到队列并执行" class="headerlink" title="三、派发任务到队列并执行"></a>三、派发任务到队列并执行</h4><p>任务分为两种，<code>dispatch_sync</code>同步派发与<code>dispatch_async</code>异步派发，这两种均是针对所在线程而言。</p>
<p>同步派发(<code>dispatch_sync</code>)，直到任务完成后才返回，会阻塞当前线程。当同步派发后并不意味着立即执行，执行时机由调度队列选择。使用同步派发时，需谨慎使用，在串行队列中派发同步任务容易造成死锁。</p>
<p>异步派发(<code>dispatch_async</code>)，函数会立即返回，函数任务将在后台执行并在未来某个时机完成。</p>
<h5 id="1-同步串行队列"><a href="#1-同步串行队列" class="headerlink" title="1.同步串行队列"></a>1.同步串行队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);      </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>  输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">1</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">2</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">3</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">4</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>串行队列同步执行，并且没有开辟新的线程，都在主线程执行，且顺序执行。</p>
<h5 id="2-同步并发队列"><a href="#2-同步并发队列" class="headerlink" title="2.同步并发队列"></a>2.同步并发队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">1</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">2</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">3</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">4</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>并发队列同步执行，没有开辟新的线程，在主线程执行，顺序输出。</p>
<h5 id="3-异步串行队列"><a href="#3-异步串行队列" class="headerlink" title="3.异步串行队列"></a>3.异步串行队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p> 输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">1</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">2</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">3</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">4</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>串行队列异步执行时，开辟了新线程(主线程除外)，但是注意：串行队列只保证同一时间只有一个任务在被调用执行，是一个任务执行完毕下一个任务出队执行，但是不一定都在同一条线程执行，只是同一时间对于当前串行队列只分配了一条线程，但是具体是哪条线程，由系统控制。所以这里的线程输出是有不确定性的，不一定每条都一样，比如第一次分配线程2，下次出队执行时，线程2被其他任务占用，此时就会分配线程3或线程4等等不定的线程！</p>
<h5 id="4-异步并发队列"><a href="#4-异步并发队列" class="headerlink" title="4.异步并发队列"></a>4.异步并发队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;       </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>   输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">3</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x100796f10&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">2</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102800410&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">1</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x100520ad0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">4</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1028001f0&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>并发队列异步执行，开辟了多条线程，且任务分别在不同的线程执行，顺序不定。</p>
<h5 id="5-外话"><a href="#5-外话" class="headerlink" title="5.外话"></a>5.外话</h5><p><code>dispatch_sync</code>官网文档有这样一段说明：</p>
<blockquote>
<p>As a performance optimization, this function executes blocks on the current thread whenever possible, with one obvious exception. Specifically, blocks submitted to the main dispatch queue always run on the main thread.</p>
<p><em>作为性能优化，此功能在可能的情况下尽可能在当前线程上执行块，一个明显的例外。具体来说，提交到主调度队列的块始终在主线程上运行。</em></p>
</blockquote>
<p>其不同效果代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交到非主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"提交到非主队列之前-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"提交到非主队列之后-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//提交到主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"提交到主队列之前-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"提交到主队列之后-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">提交到非主队列之前-&lt;NSThread: <span class="number">0</span>x600002942200&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到非主队列之后-&lt;NSThread: <span class="number">0</span>x600002942200&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到主队列之前-&lt;NSThread: <span class="number">0</span>x600002973380&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到主队列之后-&lt;NSThread: <span class="number">0</span>x600002925a80&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>为了便于做对比，我将输出后的顺序调整了粘贴出来，大家的输出顺序应该是不一样的。</p>
<p>可以很明显的区别：提交到非主队列之前和之后所在线程相同，而提交到主队列后执行的线程便是主线程。</p>
<p>此外还有主队列与全局队列，主队列属于串行，全局队列属于并发。主队列在主线程执行，所以通过<code>dispatch_async</code>异步添加到主队列的任务不会开启新的线程，在主队列(串行队列)顺序执行。通过<code>dispatch_sync</code>同步添加到主队列的任务容易造成死锁(不是一定)，下面会讲到。  </p>
<p>总结：<code>dispatch_sync</code>不会开辟新线程， <code>dispatch_async</code>会开辟新线程(添加主队列除外，主队列任务始终在主线程执行)。并发需要多线程的支持，能创建多线程的情况下才能发挥并发的效用。提交给队列的任务，除了主队列在主线程执行之外，系统无法保证其他队列在哪个线程执行。   </p>
<p>在设计并发任务时，也可以使用多个串行队列并行的方式处理，但是不建议这样做，因为这样做会开辟多条线程，每个串行队列都需要一个单独的线程，以此方式来实现并发的目的。总体建议就是无论并发还是串行都尽可能的少通过用户主动创建线程，如有需要可提交任务到全局并发队列实现目的。使用队列处理多任务，系统会根据线程的执行情况分配线程执行，并非一个线程处理一个任务，一个任务处理完成，可以继续处理其他任务，系统会在此做优化使用尽可能少的线程执行更多的任务。因为线程的开销相比队列大的多，所以尽量多使用多列处理任务，由系统分配线程处理。</p>
<p> 在使用时应注意死锁问题。</p>
<p>关于队列相关的说明在另一篇文章有介绍，通过下面链接查看：  </p>
<p><a href="http://www.mwpush.com/content/edab7fec.html">关于串行、并发、并行等的说明</a></p>
<h4 id="三、死锁-deadlock"><a href="#三、死锁-deadlock" class="headerlink" title="三、死锁 (deadlock)"></a>三、死锁 (deadlock)</h4><p>关于<code>GCD</code>中的死锁，网上有很多说明，也看了很多，但是都是看似讲的很有道理却难以让人明白，或者有些根本就是讲的不对，总会扯到一些无所谓的条件上。当然，本人也是貌似懂了，所以说一下这个问题，从一段最基本的代码开始，如下：</p>
   <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行结果如下：</p>
   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">deadlock[<span class="number">71971</span>:<span class="number">7964750</span>] 任务<span class="number">1</span></span></pre></td></tr></table></figure>

<p>附上几张张错误的截图，如下：</p>
<p><img src="/content/d771b58d/20191218_01.png" alt="20191218_01"></p>
<p>   <img src="/content/d771b58d/20191218_02.png" alt="11"></p>
<p>网上很大一部分文章在讲到这段代码的时候总会把这里的任务3，也就是<code>NSLog(@&quot;任务3&quot;);</code>，这部分也扯进去，但是这段代码的错误原因与<code>NSLog(@&quot;任务3&quot;);</code>有与没有根本没有任何关系，删除<code>NSLog(@&quot;任务3&quot;);</code>也是同样的错误。</p>
<p>这段代码只能执行到任务1，我们首先看一下图2中的第一段红色字体部分，内容如下：</p>
   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="string">"BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread"</span></span></pre></td></tr></table></figure>

<p>翻译过来就是：在当前线程已经拥有的队列上调用<code>dispatch_sync</code>。   </p>
<p>那么当前线程是哪个线程呢？我们从图2的调用栈可以看到是<code>Thread 1</code>，也就是主线程，队列就是主队列，而主队列还是个<code>Serial</code>串行队列。   </p>
<p>那么就来看一下<code>dispatch_sync</code>的官方说明，如下：</p>
<blockquote>
<p>Submits a block object for execution and returns after that block finishes executing</p>
<p>//提交block到队列，并等着block执行完毕返回。</p>
<p>Submits a block to the specified dispatch queue for synchronous execution. Unlike <code>dispatch_async</code>, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>
<p>这句主要的是最后一句：调用此方法提交块到当前队列将造成死锁！就是说，如果提交block的目标队列与当前所在的队列是同一队列，将造成死锁。</p>
</blockquote>
<p> 那么来分析下我们的代码造成死锁的原因：</p>
<p>首先主队列是在<code>main</code>方法执行之前就已经由系统创建好了，<code>main</code>函数本身就在主队列中，线程首先调用队列中的<code>main</code>方法开始执行，当执行<code>dispatch_sync</code>方法时，将要执行的任务2(<code>NSLog(@&quot;执行2&quot;);</code>所在的<code>block</code>块)，添加到获取的当前队列的末尾，也就是<code>main</code>的后面，并等待<code>block</code>执行完毕返回。但是串行队列的特性是先进先出(FIFO)，且前一个方法执行完毕之前，后面方法不能执行，需要等待执行，也就是在<code>block</code>之前的<code>main</code>方法还没有还行完毕，就不能执行<code>block</code>，而<code>block</code>又是通过同步方法添加执行的，添加后就需要等待执行，而且还得执行完毕才能返回。这样造成了<code>main</code>想执行，但是需要等待<code>block</code>执行完毕，而<code>block</code>要执行，但是<code>main</code>方法还没有执行完毕，所以不能执行，互相牵制，造成死锁。</p>
<p>用通俗点的话来说就是：<strong>串行队列</strong>中的任务1在执行，任务1要执行的代码就是将任务2添加到任务1所在的队列中<strong>同步执行</strong>，因为是同步添加，就需要等待任务2执行并执行完毕返回结果，任务1才能继续执行。但是此时队列中任务1排在任务2的前面，需要先执行完毕才能执行任务2，而任务2又要任务1等待，所以彼此牵制，都不能执行，造成死锁。</p>
<p>以上是添加到系统的主队列中造成的死锁，下面在来看一下我们手动创建的队列的死锁，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">deadlock[<span class="number">72943</span>:<span class="number">8153590</span>] 任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deadlock[<span class="number">72943</span>:<span class="number">8153590</span>] 任务<span class="number">2</span></span></pre></td></tr></table></figure>

<p>同样是串行队列，为何第一个<code>dispatch_sync</code>没有造成死锁，而第二个就造成了呢？其实就是文档中说的：<em>如果提交block的目标队列与当前所在的队列是同一队列，将造成死锁</em>。因为当执行第一个<code>dispatch_sync</code>时，将任务2添加到我们创建的<code>serial_queue</code>队列中，而此时所在的队列是系统的主队列，添加到的队列与当前所在的队列不是一个队列。而当第二个<code>dispatch_sync</code>执行时，所在的队列就是我们创建的<code>serial_queue</code>队列，目标队列与当前所在队列为同一队列，造成死锁的过程上面已经讲解了。各位可以尝试将第一个<code>dispatch_sync</code>换成<code>dispatch_async</code>等，自己试试结果，这里就不在多说。</p>
<h4 id="四、调度组-Dispatch-Group"><a href="#四、调度组-Dispatch-Group" class="headerlink" title="四、调度组(Dispatch Group)"></a>四、调度组(Dispatch Group)</h4><p>当队列中有多个任务需要处理，且需要根据这些任务的处理结果执行某些操作时，我们可以选择调度组(<code>Dispatch Group</code>)来操作，当然也有其他的实现方式，但是相对来说，使用调度组实现代码整洁且逻辑清晰。当然使用串行队列也能达到目的，但是如果大部分任务之间没有依赖关系，则最好选择并发处理。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"全部任务执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">全部任务执行完毕</span></pre></td></tr></table></figure>

<p>将任务提交到全局并发队列并异步执行，任务1，2，3，4的输出顺序不定，但是最后的“全部任务执行完毕”一定最后输出，也就是等到所有任务都完成后执行。我们可以追加数据分块下载、处理等到调度组，最后在<code>dispatch_group_notify</code>中将执行完毕的所有数据进行统一处理。也可以等数据处理完成到主线程更新UI操作，这个时候需要将<code>dispatch_group_notify</code>中的队列设置为<code>dispatch_get_main_queue()</code>即可。</p>
<p><code>dispatch_group_wait</code>等待方法，看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"其他操作"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">其他操作 <span class="comment">//此处为5秒后输出的</span></span></pre></td></tr></table></figure>

<p>与上面代码不同之处仅在于一个使用了<code>dispatch_group_notify</code>，一个使用了<code>dispatch_group_wait</code>。</p>
<p><code>dispatch_group_wait</code>是一个同步函数，同步意味着等待，阻塞，从名字中就可以看得出来。它的作用是等待，直到与之关联的组中的队列任务全部执行完毕或超过了指定的超时时间继续执行。所以我们在“任务4”中设置了睡眠5秒钟，最后的“其他操作”是过了5秒钟后才执行输出的。</p>
<p><code>dispatch_group_wait</code>第二个参数是设置超时时间，是<code>dispatch_time_t</code>类型，当设置为<code>DISPATCH_TIME_FOREVER</code>时，意味着永久等待，就是等所有任务都执行完毕才继续执行。此时，与<code>dispatch_group_notify</code>相同之处是都会等到任务全部执行完毕做其他操作，不同之处在于<code>dispatch_group_wait</code>会阻塞所在线程，<code>dispatch_group_notify</code>不阻塞线程。所以在主线程中慎用<code>dispatch_group_wait</code>方法。</p>
<p><code>dispatch_group_wait</code>是有返回值的，其返回值类型为<code>long</code>，当所有任务在设置的超时时间内全部完成，返回值为0，否则非零(超时)，也就是说队列中的任务至少还有一个未完成，也许有多个。等待时间设置为<code>DISPATCH_TIME_FOREVER</code>则返回值恒为0，因为永不超时，也就是任务总会前部执行完毕。还有一个为我们准备好的常量<code>DISPATCH_TIME_NOW</code>，将<code>dispatch_group_wait</code>时间参数设置为<code>DISPATCH_TIME_NOW</code>时，则意味着不等待，此时不阻塞线程。除了使用以上两种系统为我们准备好的时间常量，也可以自定义时间，时间类型为<code>dispatch_time_t</code>，关于<code>dispatch_time_t</code>类型的说明请关注下一篇<code>GCD</code>文章。</p>
<p>我们可以将<code>dispatch_group_wait</code>和<code>dispatch_group_notify</code>组合使用，使用<code>dispatch_group_wait</code>时，应放在非主线程，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPAT</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后执行整理任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>以上是通过<code>dispatch_group_async</code>方法提交任务到队列入组后自动执行并完成的，我们也可以通过手动入组执行，通过使用<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>方法，这两个方法只有一个参数，就是要加入的组。两个方法是一对儿的关系，缺一不可，有入就得有出，类似于引用计数，入组就是加一，出组就是减一。如果数量不对应，入比出多，则任务<code>dispatch_group_notify</code>和<code>dispatch_group_wait</code>永远不会执行。如果出比入多，则会报<code>Unbalanced call to dispatch_group_leave()</code>错误，具体看下面的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后执行整理任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>以上是正确的写法，一一对一个，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>通过<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>手动进组出组的任务，就是正常的函数方法，需要根据需要自己执行同步或异步方法，上面的代码为同步方法，所以输出结果为顺序输出。当我们执行异步方法时，<code>dispatch_group_leave</code>要放在异步函数内的方法执行完毕处！如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];  <span class="comment">//模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>这样才能保证任务全部任务执行完毕在执行<code>dispatch_group_notify</code>方法，输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">异步任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>如果放在外面，如下代码，则不能保证所有任务都处理完毕后执行<code>dispatch_group_notify</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];  <span class="comment">//模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步任务</span></pre></td></tr></table></figure>

<p>PS：<code>dispatch_group_enter</code>、<code>dispatch_group_leave</code>、<code>dispatch_group_notify</code>、<code>dispatch_group_wait</code>一起使用的方式跟上面的操作一样，不在赘述。</p>
<p>以上代码都是在同一并发多列中实现的，也可以将不同重要等级的任务提交到不同的队列后入组执行，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gd_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gh_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gd_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"默认优先级的任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gd_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"默认优先级的任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gh_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级的任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gh_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级的任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"到主线程执行所需的操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>当然队列也可以是串行队列，不过使用串行队列执行就没有意义了，任务依然需要一个一个的执行，同一队列任务不能实现并发的目的，可根据具体需要自行选择！</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>gcd</tag>
        <tag>队列</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>关于串行、并发、并行等的说明</title>
    <url>/content/edab7fec.html</url>
    <content><![CDATA[<h4 id="一、概念术语"><a href="#一、概念术语" class="headerlink" title="一、概念术语"></a>一、概念术语</h4><ol>
<li><p>进程 (<code>process</code>)</p>
<p>系统中正在运行的一个程序的实例(即一个正在运行的可执行文件)，具有一定的独立功能，是线程的容器</p>
</li>
</ol>
<ol start="2">
<li><p>线程 (<code>thread</code>)</p>
<p>线程是进程执行的最小单位，一个进程中至少包含一个线程(主线程)，进程中任务都在线程中执行(主线程或子线程)。是代码独立执行的路径。</p>
<a id="more"></a>
</li>
<li><p>任务 (<code>task</code>)</p>
<p>需要执行的工作的抽象概念。</p>
</li>
<li><p>并行 (<code>parallel</code>)</p>
<p>并行是一种使用多种运算硬件(如：多核处理器)，以便更快的执行计算。是两个或多个事件在同一时间发生。目的是将计算机不同的任务委派给同时执行的不同处理器来处理，以便尽早获得结果。比如银行业务，同时开通多个业务窗口来办理业务，每个窗口都可以执行特定的任务，多个窗口可以同时办理业务。</p>
</li>
</ol>
<ol start="5">
<li><p>并发 (<code>concurrent</code>)</p>
<p>是一种程序结构技术，有多个控制线程，是两个或多个事件在同一时间间隔发生。从概念上将，控制线程同时执行，实际上是多个线程之间不断切换以达到多线程执行任务的目的，当然也可以在多个物理处理器上执行。比如银行业务，只开通了一个业务窗口，但是可以排多个队伍到一个窗口办理业务。</p>
</li>
</ol>
<ol start="6">
<li><p>串行 (<code>serial</code>)</p>
<p>多个任务依次执行，当一个任务完成以后继续执行下一个任务。例如A，B，C三个任务，A执行完毕执行B，B执行完毕执行C。比如银行业务，只开通了一个业务窗口，并且只能排一条队伍进行业务办理。</p>
</li>
</ol>
<ol start="7">
<li><p>队列 (<code>queue</code>)</p>
<p>是一种先进先出(FIFO)的线性表。与现实世界中的规则一样，先进入的先办理业务。</p>
</li>
</ol>
<ol start="8">
<li><p>同步 (<code>synchronous</code>)</p>
<p>调用后，等任务完成之后返回的称为同步，同步执行会阻塞线程。</p>
</li>
</ol>
<ol start="9">
<li><p>异步 (<code>asynchronous</code>)</p>
<p>调用后，立即返回的称为异步，异步执行不会阻塞线程。</p>
</li>
</ol>
<ol start="10">
<li><p>串行队列 (<code>serial queue</code>)</p>
<p>按照FIFO原则，出队后将任务移交给线程执行实际工作，后面一个任务需要等待前面一个任务执行完毕在出队移交，依次类推</p>
</li>
</ol>
<ol start="11">
<li><p>并发队列 (<code>concurrent queue</code>)</p>
<p>遵循FIFO原则入队出队，任务出队意味着将任务移交给一个线程，并发不用等待，移交给线程后立刻返回，后一个任务继续出队，移交线程。会因为系统因素与任务复杂度出现不同的执行结果，但出队也是按照先进先出的顺序执行，只是移交给线程后的处理结果不同(开辟多线程才会出现不同的执行结果，单线程依然顺序输出，因为只有一条线程执行任务)。</p>
</li>
</ol>
<h4 id="二、图解说明"><a href="#二、图解说明" class="headerlink" title="二、图解说明"></a>二、图解说明</h4><p>可参照下图理解.</p>
<p>串行，并发，与并行的区别。(图片均摘自网络)</p>
<p><img src="/content/edab7fec/20191216_01.jpg" alt="20191216_01"></p>
<p>串行列队，并发队列的区别。(图片均摘自网络)</p>
<p><img src="/content/edab7fec/20191216_02.jpg" alt="20191216_01"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>串行</tag>
        <tag>并发</tag>
        <tag>并行</tag>
        <tag>serail</tag>
        <tag>coucurrent</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]self与super调用本质分析</title>
    <url>/content/3b516ae7.html</url>
    <content><![CDATA[<h4 id="一、self-基本说明"><a href="#一、self-基本说明" class="headerlink" title="一、self 基本说明"></a>一、self 基本说明</h4><p>在日常开发中，我们经常使用到<code>self</code>关键字，比如，访问属性，调用实例方法等。那么<code>self</code>到底指的是什么？我们来看一下官方文档的解释和定义：</p>
<blockquote>
<p>Returns the receiver.   //返回接收器</p>
</blockquote>
<p>在看一下<code>NSObject</code>中关于<code>self</code>的一些说法：</p>
<a id="more"></a>
<blockquote>
<p>Rather than using <code>[[XYZPerson alloc] init]</code> in the class factory method, instead try using <code>[[self alloc] init]</code>.</p>
<p>Using <code>self</code> in a class factory method means that you’re referring to the class itself.</p>
</blockquote>
<p>在工厂方法中使用<code>self</code>意味着引用类本身，意思就是说<code>self</code>就是当前类，那么再来看一下源码中对<code>self</code>的定义，代码(1-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)<span class="keyword">self</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)<span class="keyword">self</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到<code>self</code>只是返回本身，也就是当前调用者。<font color="red">(PS:调用者并不一定是当前类，继续看下文可明白)</font></p>
<p>因为<code>self</code>是消息机制中的第一个隐藏参数，在消息传递的过程中，本赋值为调用者，也就是消息接收者。第二个隐藏参数为<code>_cmd</code>，也就是<code>SEL</code>，调用的方法。</p>
<h4 id="二、super-基本说明"><a href="#二、super-基本说明" class="headerlink" title="二、super 基本说明"></a>二、super 基本说明</h4><p><code>super</code>关键字，<font color="red">（PS：不知为何大部分文章中都说super不是关键字，关键字的概念就是保留字，很明显super是保留字）</font>也是我们经常看到和使用的。代码(2-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>关于<code>super</code>的说明，本人并没有在官方文档中看到，如果大家有发现请关注本文末尾的公众号，告知本人，将不胜感激。只是在<code>NSObject</code>中有部分说明如下：</p>
<blockquote>
<p>There’s another important keyword available to you in Objective-C, called <code>super</code>. Sending a message to <code>super</code> is a way to call through to a method implementation defined by a superclass further up the inheritance chain. The most common use of <code>super</code> is when overriding a method.</p>
</blockquote>
<p>意思是说，<code>super</code>是一个重要的关键字<font color="red">(这里也有说super是关键字，所以网上很多说法是错误的，大家要自己甄别！)</font>，向<code>super</code>发送消息是调用继承链上的超类方法。<code>super</code>最常见的用法就是覆盖一个方法。</p>
<h4 id="三、探究self和super"><a href="#三、探究self和super" class="headerlink" title="三、探究self和super"></a>三、探究<code>self</code>和<code>super</code></h4><p>首先创建一个基于 Single View App的模板项目，添加<code>Person</code>和<code>Student</code>类，<code>Person</code>类继承于<code>NSObject</code>类，<code>Student</code>类继承于<code>Person</code>类，以备后面使用。下面我们在项目默认创建的<code>ViewController.m</code>类中添加代码(3-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self:%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super:%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>查看输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">demo1[<span class="number">2534</span>:<span class="number">11854005</span>] self:ViewController</span></pre></td></tr><tr><td class="code"><pre><span class="line">demo1[<span class="number">2534</span>:<span class="number">11854005</span>] <span class="keyword">super</span>:ViewController</span></pre></td></tr></table></figure>

<p>我们发现<code>self</code>与<code>super</code>的输出同样是<code>ViewController</code>，也就是当前类。然后我们继续试验，在<code>Person</code>和<code>Student</code>类中分别添加<code>eat</code>方法，代码(3-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)eat &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ eat!"</span>, <span class="keyword">self</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)eat &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> eat];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ eat!"</span>, <span class="keyword">self</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>然后在<code>ViewController.m</code>的<code>ViewDidLoad</code>方法中，创建<code>Student</code>类并调用<code>eat</code>方法，代码(3-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student * student = [[Student alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[student eat];</span></pre></td></tr></table></figure>

<p>运行，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">demo1[<span class="number">2962</span>:<span class="number">11906123</span>] &lt;Student: <span class="number">0</span>x600003fc8100&gt; eat!</span></pre></td></tr><tr><td class="code"><pre><span class="line">demo1[<span class="number">2962</span>:<span class="number">11906123</span>] &lt;Student: <span class="number">0</span>x600003fc8100&gt; eat!</span></pre></td></tr></table></figure>

<p>我们明明是在<code>Student</code>类中通过<code>super</code>调用的父类<code>Person</code>中的<code>eat</code>方法，为何<code>Person</code>中的<code>eat</code>方法输出的也是<code>Student eat</code>呢？关于这一部分的解释，网上有很多说明解释，总感觉不够详细彻底，下面我们来分析一下。</p>
<p>我们通过命令行将<code>Student.m</code>文件转成<code>.cpp</code>文件，，<code>cd</code>进入到<code>Student.m</code>文件所在的目录，使用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc Student.m</span></pre></td></tr></table></figure>

<p>会在当前文件夹中生成<code>Student.cpp</code>文件，打开找到以下代码(3-4)，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Student_eat(Student * self, SEL _cmd) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Student"</span>))&#125;, sel_registerName(<span class="string">"eat"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fm_9d3dmfcj49598v7_hghf3qjc0000gn_T_Student_370c84_mi_0, self);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>找到关于<code>super</code>调用的部分代码(3-5)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Student"</span>))&#125;, sel_registerName(<span class="string">"eat"</span>));</span></pre></td></tr></table></figure>

<p>我们发现，当<code>super</code>调用时，其实是调用的<code>objc_msgSendSuper</code>方法进行的消息发送，我们看下官方文档对于此方法的解释：</p>
<blockquote>
<p>Sends a message with a simple return value to the superclass of an instance of a class.</p>
</blockquote>
<p>向超类发送消息。</p>
<p>通过代码(3-5)，可以得知，我们这里有两个参数，一个是结构体指针类型<code>__rw_objc_super</code>，一个是返回<code>SEL</code>类型方法编号的<code>sel_registerName</code>。而<code>__rw_objc_super</code>在我们编译的<code>Student.cpp</code>文件中可以找到原型，代码(3-6)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>结合官方文档对<code>objc_msgSendSuper</code>方法参数的说明我们得知，<code>__rw_objc_super</code>，也就是<code>objc_super</code>。官方文档对此参数的说明如下：</p>
<blockquote>
<p>A pointer to an <a href="https://developer.apple.com/documentation/objectivec/objc_super?language=objc" target="_blank" rel="noopener"><code>objc_super</code></a> data structure. Pass values identifying the context the message was sent to, including the instance of the class that is to receive the message and the superclass at which to start searching for the method implementation.</p>
</blockquote>
<p>指向<code>objc_super</code>的结构体指针，传递标识了上下文的消息，包含了消息接收者和要在超类中搜索的方法实现。我们再来看一下<code>objc_super</code>结构体的源码(3-7)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull id receiver;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull Class <span class="class"><span class="keyword">class</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr></table></figure>

<p>结合我们编译的代码(3-5)，我们得知，消息的接收者在这里传递的就是当前对象<code>self</code>，即<code>Student</code>类的实例对象，方法即<code>eat</code> 。</p>
<p>通过上面的分析我们得知，在我们使用<code>super</code>方法调用父类方法时，其实传递了隐藏参数。我们上面说过，<code>self</code>调用返回方法本身，并不一定是你看到的当前调用者。这里可以说明，当我们在父类中使用<code>self</code>时，因为是在子类中通过<code>super</code>方法调用的父类方法，在这过程中，通过隐藏结构体参数，消息接收者传递的是当前的<code>self</code>，也就是<code>Student</code>的实例，所以我们在父类中使用<code>self</code>时，其实是使用子类的实例在调用父类的方法，所以也就有了代码(3-1)和(3-3)的输出。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>super</tag>
        <tag>self</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]关于类簇</title>
    <url>/content/b7bda735.html</url>
    <content><![CDATA[<h4 id="一、引语"><a href="#一、引语" class="headerlink" title="一、引语"></a>一、引语</h4><p>首先新建基于 Single View App的工程，在<code>ViewController.m</code>文件中添加如下代码(1-1)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [[<span class="built_in">NSString</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<a id="more"></a>
<p>这是一段普通的不能在普通的创建不可变字符串的过程，<code>length</code>为<code>NSString</code>的获取长度的属性，我们输出了字符串的长度，结果为0。然后我们创建一个<code>Person</code>类，添加属性变量<code>age</code>，代码(1-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>然后在<code>ViewControlelr.m</code>中添加代码(1-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [[<span class="built_in">NSString</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person = [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, person.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过运行我们发现代码完全没有问题，那么我们对上面的代码做如下修改，代码(1-4)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person = [Person alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, person.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行我们发现有如下结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.183451</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.183520</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] Did you forget to nest alloc <span class="keyword">and</span> init?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.185386</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -length only defined <span class="keyword">for</span> abstract <span class="keyword">class</span>.  Define -[NSPlaceholderString length]!'</span></pre></td></tr></table></figure>

<p>当输出<code>person.age</code>时没有任何问题，正确输出结果，而执行到<code>string1.length</code>时报错了。错误提示告诉我们<code>NSString</code>要嵌套使用<code>alloc</code>和<code>init</code>方法，并且<code>length</code>属性仅仅是定义在一个抽象类中。那么我们来一看什么是抽象类，摘自百度百科的概念如下：</p>
<blockquote>
<p>抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。</p>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p>
<p>抽象类不能实例化</p>
</blockquote>
<p>通过以上说明我们可以得出，其实<code>NSString</code>是一个抽象类，类中只是进行了简单的行为声明，并没有实现。而在<code>Objective-C</code>中并没有明确的抽象类的定义，所以这样的实现方式我们称谓”类簇“。</p>
<h4 id="二、类簇的概念"><a href="#二、类簇的概念" class="headerlink" title="二、类簇的概念"></a>二、类簇的概念</h4><p>类簇(class cluster)，是一种模式，可以隐藏”抽象基类(abstract  base class)“背后的实现细节，用户无需创建子类的实例，只需调用基类方法来创建即可。</p>
<p>下面我们来验证一下，代码(3-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string2 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string3 = <span class="string">@"string"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string4 = [[<span class="built_in">NSString</span> alloc] initWithString:string2];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string5 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"string"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string1:%s"</span>, object_getClassName(string1));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string2:%s"</span>, object_getClassName(string2));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string3:%s"</span>, object_getClassName(string3));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string4:%s"</span>, object_getClassName(string4));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string5:%s"</span>, object_getClassName(string5));</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423153</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string1:NSPlaceholderString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423323</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string2:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423428</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string3:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423523</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string4:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423616</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string5:NSTaggedPointerString</span></pre></td></tr></table></figure>

<p>PS:通过上面的结果可以看出，<code>string3</code>和<code>string4</code>本质上是一样的，所以在创建字符串时，如果不是通过一个字符串来创建另一个字符串的情况用<code>string3</code>的方式创建即可。</p>
<p>通过结果可以看出我们创建的字符串对象本质上并不是一个<code>NSString</code>类型，而是其子类类型，我们通过以下方法可以验证，代码(3-2)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"superclass:%@"</span>, [<span class="built_in">NSClassFromString</span>(<span class="string">@"NSTaggedPointerString"</span>) superclass]);</span></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">02</span><span class="variable">.662405</span>+<span class="number">0800</span> allocmessage[<span class="number">81090</span>:<span class="number">9732886</span>] superclass:NSString</span></pre></td></tr></table></figure>

<p>所以当我们使用<code>isMemberOfClass</code>来判断字符串是否是当前类时，得到的结果是否定的，代码(3-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([string3 isMemberOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"是NSString当前类"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"否"</span>);</span></pre></td></tr></table></figure>

<p>结构为：否。</p>
<p>当然我们可以通过<code>isKindOfClass</code>来判断，结果是正确是正确的。</p>
<h4 id="三、地址验证"><a href="#三、地址验证" class="headerlink" title="三、地址验证"></a>三、地址验证</h4><p>首先重写<code>Person</code>类的<code>init</code>初始化方法，代码(4-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">self</span>.age = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后在<code>ViewController</code>的<code>viewDidLoad</code>方法中添加代码(4-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person1 = [Person alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person2 = [person1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person1 address:%p"</span>, person1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person2 address:%p"</span>, person2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string2 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string3 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string4 = [string2 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string5 = [string1 initWithFormat:<span class="string">@"string1"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string6 = [string1 initWithString:<span class="string">@"string2"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 address:%p"</span>, string1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string2 address:%p"</span>, string2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string3 address:%p"</span>, string3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string4 address:%p"</span>, string4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string5 address:%p"</span>, string5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string6 address:%p"</span>, string6);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355410</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] person1 address:<span class="number">0</span>x600001fe8340</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355542</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] person2 address:<span class="number">0</span>x600001fe8340</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355643</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string1 address:<span class="number">0</span>x1103f16f8</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355714</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string2 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355779</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string3 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355851</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string4 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355940</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string5 address:<span class="number">0</span>xb716bea187e38d28</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.356021</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string6 address:<span class="number">0</span>x10fdce0e8</span></pre></td></tr></table></figure>

<p>通过以上代码可以看出，<code>Person</code>类创建的对象，在<code>alloc</code>分配内存空间与初始化后的地址是一致的，也就是说<code>init</code>初始化方法只是完成了我们覆盖方法的赋值初始化操作。而<code>NSString</code>创建的对象在<code>alloc</code>分配内存空间后，初始化<code>init</code>方法又一次完成了分配空间的操作，重新分配了内存地址。</p>
<p>而通过基本的<code>init</code>初始化方法分配的内存地址是一致的，无论多次调用也不会改变，即指向了同一块内存区域。而<code>initWithFormat</code>，<code>initWithString</code>等带参数的初始化方法则重新分配了不同的内存空间。</p>
<p>PS：通过以上代码可以发现，类簇<code>alloc</code>分配内存空间后，<code>init</code>方法又一次重新分配了内存空间，又一次完成了开辟地址的操作。而非类簇的<code>Person</code>类则无此操作。</p>
<p>在关于<code>Initializers</code>的官方文档中有这样的叙述：</p>
<blockquote>
<p>Although <code>init...</code> methods are required by their method signature to return an object, that object is not necessarily the one that was most recently allocated—the receiver of the <code>init...</code> message. In other words, the object you get back from an initializer might not be the one you thought was being initialized.</p>
</blockquote>
<p>PS:大概意思是说：虽然<code>init</code>通过方法返回了一个对象，但这个这个对象并不一定是您最近分配的对象。换句话说，返回的对象并不一定是你认为的初始化方法返回的对象。</p>
<p>这些我们在类簇的模式中也得到了验证。</p>
<h4 id="四、类簇的实现"><a href="#四、类簇的实现" class="headerlink" title="四、类簇的实现"></a>四、类簇的实现</h4><p>改造<code>Person</code>类，<code>.h</code>文文件代码(5-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MWPersonType) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeProgrammer,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeDesigner,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeTester,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPersonType:(MWPersonType)type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)work;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span></pre></td></tr></table></figure>

<p><code>.m</code>文件代码(5-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonProgrammer.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonDesigner.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonTester.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPersonType:(MWPersonType)type &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span> (type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeProgrammer:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonProgrammer alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeDesigner:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonDesigner alloc] init] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeTester:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonTester alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)work &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//do something</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>分别实现<code>MWPersonProgrammer</code>，<code>MWPersonDesigner</code>，<code>MWPersonTester</code>，并全部继承于<code>Person</code>类，并在<code>.m</code>文件中实现自己的<code>work</code>方法。</p>
<h4 id="五、引申"><a href="#五、引申" class="headerlink" title="五、引申"></a>五、引申</h4><p>我们熟悉的<code>self = [super init]</code>这种写法，其中有一个原因就是类簇的模式。因为返回类型并不一定是当前类型。上面的例子，当我们初始化<code>Person</code>的对象时，其返回的对象并不是<code>Person</code>对象。<code>self = [super init]</code>写法并不会对<code>self</code>的指向造成任何影响，<code>self</code>总是指向当前类，父类的指针可以指向子类。主要的目的就是确保父类初始化成功，不会返回<code>nil</code>。</p>
<h4 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h4><p>OC中类簇的模式被大量使用，如<code>NSNumber</code>，<code>NSArray</code>，<code>UIButton</code>，<code>NSDictionary</code>等。类簇并非无法继承，而是需要实现特定的方法等。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>IOS</tag>
        <tag>类簇</tag>
      </tags>
  </entry>
</search>
