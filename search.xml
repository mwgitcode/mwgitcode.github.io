<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[IOS.OC]GCD的使用精解(-)</title>
    <url>/content/d771b58d.html</url>
    <content><![CDATA[<h4 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h4><p><code>GCD(Grand Central Dispatch)</code>，大中枢派发，是一套基于C语言的多线程开发框架，它提供了一个易用的抽象层，使开发者不需要处理底层的线程管理就可以充分利用系统的多核特性，可以自动平衡系统资源分配方式，提高系统资源的利用率，是异步执行任务的技术之一。                                                                          </p>
<p><code>GCD API</code>的核心概念是调度队列，对线程的操作实际上是由调度队列完成的，开发者只需将任务添加到调度队列即可，系统负责线程的创建、管理，提交给调度队列的任务会在完全受系统管理的线程池上执行。因为线程的管理由系统执行，系统会根据系统占用资源相对合理分配资源，比传统的线程提高了效率。</p>
<a id="more"></a>

<h4 id="二、Dispatch-Queue-派发队列"><a href="#二、Dispatch-Queue-派发队列" class="headerlink" title="二、Dispatch Queue 派发队列"></a>二、<code>Dispatch Queue</code> 派发队列</h4><h5 id="1-主队列"><a href="#1-主队列" class="headerlink" title="1.主队列"></a>1.主队列</h5><p>主队列任务在主线程中执行，会阻塞主线程，是一个串行队列，可以通过以下方式获取，代码(1-1)，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_queue_main_t m_queue = dispatch_get_main_queue();</span></pre></td></tr></table></figure>
<p>PS：主队列是在调用<code>main</code>函数之前由系统自动创建的，并将其与程序的主线程相关联。由于主队列运行在应用程序的主线程上，因此通常用作应用程序的关键同步点。</p>
<h5 id="2-全局并发队列"><a href="#2-全局并发队列" class="headerlink" title="2.全局并发队列"></a>2.全局并发队列</h5><p>共享当前进程资源，提交到此队列的任务是无序的并发执行。获取方式代码(1-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_queue_global_t g_queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr></table></figure>

<p>第一个参数为执行的优先级，定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最高优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//中等优先级，为默认优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//低优先级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//后台优先级，级别最低</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span></pre></td></tr></table></figure>

<p>现在优先级已被服务质量QOS(quality of service)所取代，服务质量可用于<code>GCD</code>和<code>NSOperation</code>，且苹果建议最好用Qos来代替全局并发优先级。服务质量对应优先级代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span></pre></td></tr><tr><td class="code"><pre><span class="line">*  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span></pre></td></tr></table></figure>

<p>PS：设置优先级并不能保证执行的实时性，只是大致的判断。</p>
<p>第二个为系统保留参数，可传入<code>NULL</code>或0。</p>
<h5 id="3-自定义队列"><a href="#3-自定义队列" class="headerlink" title="3.自定义队列"></a>3.自定义队列</h5><p>自定义派发队列有两种，<code>Serial Dispatch Queue</code>串行队列，<code>Concurrent Dispatch Queue</code>并发队列。串行队列需要一个执行结束，才能继续执行下一个任务。</p>
<p>并发队列则不需要等待，按FIFO入队后无需等待前一个任务执行完毕在执行，而是入队后便开始执行，并发队列中的任务可以同时运行。无论串行还有并发队列，都严格按照FIFO顺序进队出队。</p>
<p>自定义队列的创建方式代码(1-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串行队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> s_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, DISPATCH_QUEUE_SERIAL);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//并发队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> c_queue = dispatch_queue_create(<span class="string">"com.mwpush.www"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr></table></figure>
<p>第一个参数为队列的名称，一般命名方式为域名倒叙，也可以不命名，传入<code>NULL</code>，但是命名对于调式查找非常有帮助。</p>
<p>第二个参数为队列属性，即串行或并发。当为串行时，可直接传入<code>NULL</code>，并发时则需传入<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<h4 id="三、派发任务到队列并执行"><a href="#三、派发任务到队列并执行" class="headerlink" title="三、派发任务到队列并执行"></a>三、派发任务到队列并执行</h4><p>任务分为两种，<code>dispatch_sync</code>同步派发与<code>dispatch_async</code>异步派发，这两种均是针对所在线程而言。</p>
<p>同步派发(<code>dispatch_sync</code>)，直到任务完成后才返回，会阻塞当前线程。当同步派发后并不意味着立即执行，执行时机由调度队列选择。使用同步派发时，需谨慎使用，在串行队列中派发同步任务容易造成死锁。</p>
<p>异步派发(<code>dispatch_async</code>)，函数会立即返回，函数任务将在后台执行并在未来某个时机完成。</p>
<h5 id="1-同步串行队列"><a href="#1-同步串行队列" class="headerlink" title="1.同步串行队列"></a>1.同步串行队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);      </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步串行队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>  输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">1</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">2</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">3</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步串行队列<span class="number">4</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102a06ca0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>串行队列同步执行，并且没有开辟新的线程，都在主线程执行，且顺序执行。</p>
<h5 id="2-同步并发队列"><a href="#2-同步并发队列" class="headerlink" title="2.同步并发队列"></a>2.同步并发队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"同步并发队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">1</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">2</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">3</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">同步并发队列<span class="number">4</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1005036d0&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>并发队列同步执行，没有开辟新的线程，在主线程执行，顺序输出。</p>
<h5 id="3-异步串行队列"><a href="#3-异步串行队列" class="headerlink" title="3.异步串行队列"></a>3.异步串行队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步串行队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p> 输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">1</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">2</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">3</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步串行队列<span class="number">4</span>:&lt;OS_dispatch_queue_serial: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x10292cff0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>串行队列异步执行时，开辟了新线程(主线程除外)，但是注意：串行队列只保证同一时间只有一个任务在被调用执行，是一个任务执行完毕下一个任务出队执行，但是不一定都在同一条线程执行，只是同一时间对于当前串行队列只分配了一条线程，但是具体是哪条线程，由系统控制。所以这里的线程输出是有不确定性的，不一定每条都一样，比如第一次分配线程2，下次出队执行时，线程2被其他任务占用，此时就会分配线程3或线程4等等不定的线程！</p>
<h5 id="4-异步并发队列"><a href="#4-异步并发队列" class="headerlink" title="4.异步并发队列"></a>4.异步并发队列</h5><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue_t = dispatch_queue_create(<span class="string">"com.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;       </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列1:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列2:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列3:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue_t, ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"异步并发队列4:%@ 所在线程:%@"</span>,queue_t, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>   输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">3</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x100796f10&gt;&#123;number = <span class="number">4</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">2</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x102800410&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">1</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x100520ad0&gt;&#123;number = <span class="number">2</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步并发队列<span class="number">4</span>:&lt;OS_dispatch_queue_concurrent: com<span class="variable">.queue</span>&gt; 所在线程:&lt;NSThread: <span class="number">0</span>x1028001f0&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr></table></figure>

<p>并发队列异步执行，开辟了多条线程，且任务分别在不同的线程执行，顺序不定。</p>
<h5 id="5-外话"><a href="#5-外话" class="headerlink" title="5.外话"></a>5.外话</h5><p><code>dispatch_sync</code>官网文档有这样一段说明：</p>
<blockquote>
<p>As a performance optimization, this function executes blocks on the current thread whenever possible, with one obvious exception. Specifically, blocks submitted to the main dispatch queue always run on the main thread.</p>
<p><em>作为性能优化，此功能在可能的情况下尽可能在当前线程上执行块，一个明显的例外。具体来说，提交到主调度队列的块始终在主线程上运行。</em></p>
</blockquote>
<p>其不同效果代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交到非主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"提交到非主队列之前-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"提交到非主队列之后-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//提交到主线程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"提交到主队列之前-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"提交到主队列之后-%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">提交到非主队列之前-&lt;NSThread: <span class="number">0</span>x600002942200&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到非主队列之后-&lt;NSThread: <span class="number">0</span>x600002942200&gt;&#123;number = <span class="number">3</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到主队列之前-&lt;NSThread: <span class="number">0</span>x600002973380&gt;&#123;number = <span class="number">5</span>, name = (<span class="literal">null</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">提交到主队列之后-&lt;NSThread: <span class="number">0</span>x600002925a80&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span></pre></td></tr></table></figure>

<p>为了便于做对比，我将输出后的顺序调整了粘贴出来，大家的输出顺序应该是不一样的。</p>
<p>可以很明显的区别：提交到非主队列之前和之后所在线程相同，而提交到主队列后执行的线程便是主线程。</p>
<p>此外还有主队列与全局队列，主队列属于串行，全局队列属于并发。主队列在主线程执行，所以通过<code>dispatch_async</code>异步添加到主队列的任务不会开启新的线程，在主队列(串行队列)顺序执行。通过<code>dispatch_sync</code>同步添加到主队列的任务容易造成死锁(不是一定)，下面会讲到。  </p>
<p>总结：<code>dispatch_sync</code>不会开辟新线程， <code>dispatch_async</code>会开辟新线程(添加主队列除外，主队列任务始终在主线程执行)。并发需要多线程的支持，能创建多线程的情况下才能发挥并发的效用。提交给队列的任务，除了主队列在主线程执行之外，系统无法保证其他队列在哪个线程执行。   </p>
<p>在设计并发任务时，也可以使用多个串行队列并行的方式处理，但是不建议这样做，因为这样做会开辟多条线程，每个串行队列都需要一个单独的线程，以此方式来实现并发的目的。总体建议就是无论并发还是串行都尽可能的少通过用户主动创建线程，如有需要可提交任务到全局并发队列实现目的。使用队列处理多任务，系统会根据线程的执行情况分配线程执行，并非一个线程处理一个任务，一个任务处理完成，可以继续处理其他任务，系统会在此做优化使用尽可能少的线程执行更多的任务。因为线程的开销相比队列大的多，所以尽量多使用多列处理任务，由系统分配线程处理。</p>
<p> 在使用时应注意死锁问题。</p>
<p>关于队列相关的说明在另一篇文章有介绍，通过下面链接查看：  </p>
<p><a href="http://www.mwpush.com/content/edab7fec.html">关于串行、并发、并行等的说明</a></p>
<h4 id="三、死锁-deadlock"><a href="#三、死锁-deadlock" class="headerlink" title="三、死锁 (deadlock)"></a>三、死锁 (deadlock)</h4><p>关于<code>GCD</code>中的死锁，网上有很多说明，也看了很多，但是都是看似讲的很有道理却难以让人明白，或者有些根本就是讲的不对，总会扯到一些无所谓的条件上。当然，本人也是貌似懂了，所以说一下这个问题，从一段最基本的代码开始，如下：</p>
   <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>执行结果如下：</p>
   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">deadlock[<span class="number">71971</span>:<span class="number">7964750</span>] 任务<span class="number">1</span></span></pre></td></tr></table></figure>

<p>附上几张张错误的截图，如下：</p>
<p><img src="/content/d771b58d/20191218_01.png" alt="20191218_01"></p>
<p>   <img src="/content/d771b58d/20191218_02.png" alt="11"></p>
<p>网上很大一部分文章在讲到这段代码的时候总会把这里的任务3，也就是<code>NSLog(@&quot;任务3&quot;);</code>，这部分也扯进去，但是这段代码的错误原因与<code>NSLog(@&quot;任务3&quot;);</code>有与没有根本没有任何关系，删除<code>NSLog(@&quot;任务3&quot;);</code>也是同样的错误。</p>
<p>这段代码只能执行到任务1，我们首先看一下图2中的第一段红色字体部分，内容如下：</p>
   <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="string">"BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread"</span></span></pre></td></tr></table></figure>

<p>翻译过来就是：在当前线程已经拥有的队列上调用<code>dispatch_sync</code>。   </p>
<p>那么当前线程是哪个线程呢？我们从图2的调用栈可以看到是<code>Thread 1</code>，也就是主线程，队列就是主队列，而主队列还是个<code>Serial</code>串行队列。   </p>
<p>那么就来看一下<code>dispatch_sync</code>的官方说明，如下：</p>
<blockquote>
<p>Submits a block object for execution and returns after that block finishes executing</p>
<p>//提交block到队列，并等着block执行完毕返回。</p>
<p>Submits a block to the specified dispatch queue for synchronous execution. Unlike <code>dispatch_async</code>, this function does not return until the block has finished. Calling this function and targeting the current queue results in deadlock.</p>
<p>这句主要的是最后一句：调用此方法提交块到当前队列将造成死锁！就是说，如果提交block的目标队列与当前所在的队列是同一队列，将造成死锁。</p>
</blockquote>
<p> 那么来分析下我们的代码造成死锁的原因：</p>
<p>首先主队列是在<code>main</code>方法执行之前就已经由系统创建好了，<code>main</code>函数本身就在主队列中，线程首先调用队列中的<code>main</code>方法开始执行，当执行<code>dispatch_sync</code>方法时，将要执行的任务2(<code>NSLog(@&quot;执行2&quot;);</code>所在的<code>block</code>块)，添加到获取的当前队列的末尾，也就是<code>main</code>的后面，并等待<code>block</code>执行完毕返回。但是串行队列的特性是先进先出(FIFO)，且前一个方法执行完毕之前，后面方法不能执行，需要等待执行，也就是在<code>block</code>之前的<code>main</code>方法还没有还行完毕，就不能执行<code>block</code>，而<code>block</code>又是通过同步方法添加执行的，添加后就需要等待执行，而且还得执行完毕才能返回。这样造成了<code>main</code>想执行，但是需要等待<code>block</code>执行完毕，而<code>block</code>要执行，但是<code>main</code>方法还没有执行完毕，所以不能执行，互相牵制，造成死锁。</p>
<p>用通俗点的话来说就是：<strong>串行队列</strong>中的任务1在执行，任务1要执行的代码就是将任务2添加到任务1所在的队列中<strong>同步执行</strong>，因为是同步添加，就需要等待任务2执行并执行完毕返回结果，任务1才能继续执行。但是此时队列中任务1排在任务2的前面，需要先执行完毕才能执行任务2，而任务2又要任务1等待，所以彼此牵制，都不能执行，造成死锁。</p>
<p>以上是添加到系统的主队列中造成的死锁，下面在来看一下我们手动创建的队列的死锁，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"com.mwpush"</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">dispatch_sync</span>(serial_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">deadlock[<span class="number">72943</span>:<span class="number">8153590</span>] 任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deadlock[<span class="number">72943</span>:<span class="number">8153590</span>] 任务<span class="number">2</span></span></pre></td></tr></table></figure>

<p>同样是串行队列，为何第一个<code>dispatch_sync</code>没有造成死锁，而第二个就造成了呢？其实就是文档中说的：<em>如果提交block的目标队列与当前所在的队列是同一队列，将造成死锁</em>。因为当执行第一个<code>dispatch_sync</code>时，将任务2添加到我们创建的<code>serial_queue</code>队列中，而此时所在的队列是系统的主队列，添加到的队列与当前所在的队列不是一个队列。而当第二个<code>dispatch_sync</code>执行时，所在的队列就是我们创建的<code>serial_queue</code>队列，目标队列与当前所在队列为同一队列，造成死锁的过程上面已经讲解了。各位可以尝试将第一个<code>dispatch_sync</code>换成<code>dispatch_async</code>等，自己试试结果，这里就不在多说。</p>
<h4 id="四、调度组-Dispatch-Group"><a href="#四、调度组-Dispatch-Group" class="headerlink" title="四、调度组(Dispatch Group)"></a>四、调度组(Dispatch Group)</h4><p>当队列中有多个任务需要处理，且需要根据这些任务的处理结果执行某些操作时，我们可以选择调度组(<code>Dispatch Group</code>)来操作，当然也有其他的实现方式，但是相对来说，使用调度组实现代码整洁且逻辑清晰。当然使用串行队列也能达到目的，但是如果大部分任务之间没有依赖关系，则最好选择并发处理。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"全部任务执行完毕"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">全部任务执行完毕</span></pre></td></tr></table></figure>

<p>将任务提交到全局并发队列并异步执行，任务1，2，3，4的输出顺序不定，但是最后的“全部任务执行完毕”一定最后输出，也就是等到所有任务都完成后执行。我们可以追加数据分块下载、处理等到调度组，最后在<code>dispatch_group_notify</code>中将执行完毕的所有数据进行统一处理。也可以等数据处理完成到主线程更新UI操作，这个时候需要将<code>dispatch_group_notify</code>中的队列设置为<code>dispatch_get_main_queue()</code>即可。</p>
<p><code>dispatch_group_wait</code>等待方法，看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"其他操作"</span>);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">其他操作 <span class="comment">//此处为5秒后输出的</span></span></pre></td></tr></table></figure>

<p>与上面代码不同之处仅在于一个使用了<code>dispatch_group_notify</code>，一个使用了<code>dispatch_group_wait</code>。</p>
<p><code>dispatch_group_wait</code>是一个同步函数，同步意味着等待，阻塞，从名字中就可以看得出来。它的作用是等待，直到与之关联的组中的队列任务全部执行完毕或超过了指定的超时时间继续执行。所以我们在“任务4”中设置了睡眠5秒钟，最后的“其他操作”是过了5秒钟后才执行输出的。</p>
<p><code>dispatch_group_wait</code>第二个参数是设置超时时间，是<code>dispatch_time_t</code>类型，当设置为<code>DISPATCH_TIME_FOREVER</code>时，意味着永久等待，就是等所有任务都执行完毕才继续执行。此时，与<code>dispatch_group_notify</code>相同之处是都会等到任务全部执行完毕做其他操作，不同之处在于<code>dispatch_group_wait</code>会阻塞所在线程，<code>dispatch_group_notify</code>不阻塞线程。所以在主线程中慎用<code>dispatch_group_wait</code>方法。</p>
<p><code>dispatch_group_wait</code>是有返回值的，其返回值类型为<code>long</code>，当所有任务在设置的超时时间内全部完成，返回值为0，否则非零(超时)，也就是说队列中的任务至少还有一个未完成，也许有多个。等待时间设置为<code>DISPATCH_TIME_FOREVER</code>则返回值恒为0，因为永不超时，也就是任务总会前部执行完毕。还有一个为我们准备好的常量<code>DISPATCH_TIME_NOW</code>，将<code>dispatch_group_wait</code>时间参数设置为<code>DISPATCH_TIME_NOW</code>时，则意味着不等待，此时不阻塞线程。除了使用以上两种系统为我们准备好的时间常量，也可以自定义时间，时间类型为<code>dispatch_time_t</code>，关于<code>dispatch_time_t</code>类型的说明请关注下一篇<code>GCD</code>文章。</p>
<p>我们可以将<code>dispatch_group_wait</code>和<code>dispatch_group_notify</code>组合使用，使用<code>dispatch_group_wait</code>时，应放在非主线程，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPAT</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务5"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后执行整理任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>以上是通过<code>dispatch_group_async</code>方法提交任务到队列入组后自动执行并完成的，我们也可以通过手动入组执行，通过使用<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>方法，这两个方法只有一个参数，就是要加入的组。两个方法是一对儿的关系，缺一不可，有入就得有出，类似于引用计数，入组就是加一，出组就是减一。如果数量不对应，入比出多，则任务<code>dispatch_group_notify</code>和<code>dispatch_group_wait</code>永远不会执行。如果出比入多，则会报<code>Unbalanced call to dispatch_group_leave()</code>错误，具体看下面的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> g_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"任务4"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后执行整理任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>以上是正确的写法，一一对一个，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>通过<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>手动进组出组的任务，就是正常的函数方法，需要根据需要自己执行同步或异步方法，上面的代码为同步方法，所以输出结果为顺序输出。当我们执行异步方法时，<code>dispatch_group_leave</code>要放在异步函数内的方法执行完毕处！如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];  <span class="comment">//模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dispatch_group_leave(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>这样才能保证任务全部任务执行完毕在执行<code>dispatch_group_notify</code>方法，输出如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">异步任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr></table></figure>

<p>如果放在外面，如下代码，则不能保证所有任务都处理完毕后执行<code>dispatch_group_notify</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误演示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_enter(group);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(g_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3</span>];  <span class="comment">//模拟耗时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步任务"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_leave(group);</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">任务<span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">任务<span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">最后执行整理任务</span></pre></td></tr><tr><td class="code"><pre><span class="line">异步任务</span></pre></td></tr></table></figure>

<p>PS：<code>dispatch_group_enter</code>、<code>dispatch_group_leave</code>、<code>dispatch_group_notify</code>、<code>dispatch_group_wait</code>一起使用的方式跟上面的操作一样，不在赘述。</p>
<p>以上代码都是在同一并发多列中实现的，也可以将不同重要等级的任务提交到不同的队列后入组执行，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gd_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> gh_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gd_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"默认优先级的任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gd_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"默认优先级的任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gh_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级的任务1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_async(group, gh_queue, ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"高优先级的任务2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"到主线程执行所需的操作"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>当然队列也可以是串行队列，不过使用串行队列执行就没有意义了，任务依然需要一个一个的执行，同一队列任务不能实现并发的目的，可根据具体需要自行选择！</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>Objective-C</tag>
        <tag>ios</tag>
        <tag>gcd</tag>
        <tag>队列</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>关于串行、并发、并行等的说明</title>
    <url>/content/edab7fec.html</url>
    <content><![CDATA[<h4 id="一、概念术语"><a href="#一、概念术语" class="headerlink" title="一、概念术语"></a>一、概念术语</h4><ol>
<li><p>进程 (<code>process</code>)</p>
<p>系统中正在运行的一个程序的实例(即一个正在运行的可执行文件)，具有一定的独立功能，是线程的容器</p>
</li>
</ol>
<ol start="2">
<li><p>线程 (<code>thread</code>)</p>
<p>线程是进程执行的最小单位，一个进程中至少包含一个线程(主线程)，进程中任务都在线程中执行(主线程或子线程)。是代码独立执行的路径。</p>
<a id="more"></a>
</li>
<li><p>任务 (<code>task</code>)</p>
<p>需要执行的工作的抽象概念。</p>
</li>
<li><p>并行 (<code>parallel</code>)</p>
<p>并行是一种使用多种运算硬件(如：多核处理器)，以便更快的执行计算。是两个或多个事件在同一时间发生。目的是将计算机不同的任务委派给同时执行的不同处理器来处理，以便尽早获得结果。比如银行业务，同时开通多个业务窗口来办理业务，每个窗口都可以执行特定的任务，多个窗口可以同时办理业务。</p>
</li>
</ol>
<ol start="5">
<li><p>并发 (<code>concurrent</code>)</p>
<p>是一种程序结构技术，有多个控制线程，是两个或多个事件在同一时间间隔发生。从概念上将，控制线程同时执行，实际上是多个线程之间不断切换以达到多线程执行任务的目的，当然也可以在多个物理处理器上执行。比如银行业务，只开通了一个业务窗口，但是可以排多个队伍到一个窗口办理业务。</p>
</li>
</ol>
<ol start="6">
<li><p>串行 (<code>serial</code>)</p>
<p>多个任务依次执行，当一个任务完成以后继续执行下一个任务。例如A，B，C三个任务，A执行完毕执行B，B执行完毕执行C。比如银行业务，只开通了一个业务窗口，并且只能排一条队伍进行业务办理。</p>
</li>
</ol>
<ol start="7">
<li><p>队列 (<code>queue</code>)</p>
<p>是一种先进先出(FIFO)的线性表。与现实世界中的规则一样，先进入的先办理业务。</p>
</li>
</ol>
<ol start="8">
<li><p>同步 (<code>synchronous</code>)</p>
<p>调用后，等任务完成之后返回的称为同步，同步执行会阻塞线程。</p>
</li>
</ol>
<ol start="9">
<li><p>异步 (<code>asynchronous</code>)</p>
<p>调用后，立即返回的称为异步，异步执行不会阻塞线程。</p>
</li>
</ol>
<ol start="10">
<li><p>串行队列 (<code>serial queue</code>)</p>
<p>按照FIFO原则，出队后将任务移交给线程执行实际工作，后面一个任务需要等待前面一个任务执行完毕在出队移交，依次类推</p>
</li>
</ol>
<ol start="11">
<li><p>并发队列 (<code>concurrent queue</code>)</p>
<p>遵循FIFO原则入队出队，任务出队意味着将任务移交给一个线程，并发不用等待，移交给线程后立刻返回，后一个任务继续出队，移交线程。会因为系统因素与任务复杂度出现不同的执行结果，但出队也是按照先进先出的顺序执行，只是移交给线程后的处理结果不同(开辟多线程才会出现不同的执行结果，单线程依然顺序输出，因为只有一条线程执行任务)。</p>
</li>
</ol>
<h4 id="二、图解说明"><a href="#二、图解说明" class="headerlink" title="二、图解说明"></a>二、图解说明</h4><p>可参照下图理解.</p>
<p>串行，并发，与并行的区别。(图片均摘自网络)</p>
<p><img src="/content/edab7fec/20191216_01.jpg" alt="20191216_01"></p>
<p>串行列队，并发队列的区别。(图片均摘自网络)</p>
<p><img src="/content/edab7fec/20191216_02.jpg" alt="20191216_01"></p>
]]></content>
      <categories>
        <category>程序设计</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>串行</tag>
        <tag>并发</tag>
        <tag>并行</tag>
        <tag>serail</tag>
        <tag>coucurrent</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]self与super调用本质分析</title>
    <url>/content/3b516ae7.html</url>
    <content><![CDATA[<h4 id="一、self-基本说明"><a href="#一、self-基本说明" class="headerlink" title="一、self 基本说明"></a>一、self 基本说明</h4><p>在日常开发中，我们经常使用到<code>self</code>关键字，比如，访问属性，调用实例方法等。那么<code>self</code>到底指的是什么？我们来看一下官方文档的解释和定义：</p>
<blockquote>
<p>Returns the receiver.   //返回接收器</p>
</blockquote>
<p>在看一下<code>NSObject</code>中关于<code>self</code>的一些说法：</p>
<a id="more"></a>
<blockquote>
<p>Rather than using <code>[[XYZPerson alloc] init]</code> in the class factory method, instead try using <code>[[self alloc] init]</code>.</p>
<p>Using <code>self</code> in a class factory method means that you’re referring to the class itself.</p>
</blockquote>
<p>在工厂方法中使用<code>self</code>意味着引用类本身，意思就是说<code>self</code>就是当前类，那么再来看一下源码中对<code>self</code>的定义，代码(1-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)<span class="keyword">self</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)<span class="keyword">self</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>可以看到<code>self</code>只是返回本身，也就是当前调用者。<font color="red">(PS:调用者并不一定是当前类，继续看下文可明白)</font></p>
<p>因为<code>self</code>是消息机制中的第一个隐藏参数，在消息传递的过程中，本赋值为调用者，也就是消息接收者。第二个隐藏参数为<code>_cmd</code>，也就是<code>SEL</code>，调用的方法。</p>
<h4 id="二、super-基本说明"><a href="#二、super-基本说明" class="headerlink" title="二、super 基本说明"></a>二、super 基本说明</h4><p><code>super</code>关键字，<font color="red">（PS：不知为何大部分文章中都说super不是关键字，关键字的概念就是保留字，很明显super是保留字）</font>也是我们经常看到和使用的。代码(2-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>关于<code>super</code>的说明，本人并没有在官方文档中看到，如果大家有发现请关注本文末尾的公众号，告知本人，将不胜感激。只是在<code>NSObject</code>中有部分说明如下：</p>
<blockquote>
<p>There’s another important keyword available to you in Objective-C, called <code>super</code>. Sending a message to <code>super</code> is a way to call through to a method implementation defined by a superclass further up the inheritance chain. The most common use of <code>super</code> is when overriding a method.</p>
</blockquote>
<p>意思是说，<code>super</code>是一个重要的关键字<font color="red">(这里也有说super是关键字，所以网上很多说法是错误的，大家要自己甄别！)</font>，向<code>super</code>发送消息是调用继承链上的超类方法。<code>super</code>最常见的用法就是覆盖一个方法。</p>
<h4 id="三、探究self和super"><a href="#三、探究self和super" class="headerlink" title="三、探究self和super"></a>三、探究<code>self</code>和<code>super</code></h4><p>首先创建一个基于 Single View App的模板项目，添加<code>Person</code>和<code>Student</code>类，<code>Person</code>类继承于<code>NSObject</code>类，<code>Student</code>类继承于<code>Person</code>类，以备后面使用。下面我们在项目默认创建的<code>ViewController.m</code>类中添加代码(3-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self:%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super:%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>查看输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">demo1[<span class="number">2534</span>:<span class="number">11854005</span>] self:ViewController</span></pre></td></tr><tr><td class="code"><pre><span class="line">demo1[<span class="number">2534</span>:<span class="number">11854005</span>] <span class="keyword">super</span>:ViewController</span></pre></td></tr></table></figure>

<p>我们发现<code>self</code>与<code>super</code>的输出同样是<code>ViewController</code>，也就是当前类。然后我们继续试验，在<code>Person</code>和<code>Student</code>类中分别添加<code>eat</code>方法，代码(3-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)eat &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ eat!"</span>, <span class="keyword">self</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//-----------------------------分割线--------------------------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)eat &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> eat];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ eat!"</span>, <span class="keyword">self</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>然后在<code>ViewController.m</code>的<code>ViewDidLoad</code>方法中，创建<code>Student</code>类并调用<code>eat</code>方法，代码(3-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student * student = [[Student alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">[student eat];</span></pre></td></tr></table></figure>

<p>运行，输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">demo1[<span class="number">2962</span>:<span class="number">11906123</span>] &lt;Student: <span class="number">0</span>x600003fc8100&gt; eat!</span></pre></td></tr><tr><td class="code"><pre><span class="line">demo1[<span class="number">2962</span>:<span class="number">11906123</span>] &lt;Student: <span class="number">0</span>x600003fc8100&gt; eat!</span></pre></td></tr></table></figure>

<p>我们明明是在<code>Student</code>类中通过<code>super</code>调用的父类<code>Person</code>中的<code>eat</code>方法，为何<code>Person</code>中的<code>eat</code>方法输出的也是<code>Student eat</code>呢？关于这一部分的解释，网上有很多说明解释，总感觉不够详细彻底，下面我们来分析一下。</p>
<p>我们通过命令行将<code>Student.m</code>文件转成<code>.cpp</code>文件，，<code>cd</code>进入到<code>Student.m</code>文件所在的目录，使用命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -rewrite-objc Student.m</span></pre></td></tr></table></figure>

<p>会在当前文件夹中生成<code>Student.cpp</code>文件，打开找到以下代码(3-4)，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Student_eat(Student * self, SEL _cmd) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Student"</span>))&#125;, sel_registerName(<span class="string">"eat"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_fm_9d3dmfcj49598v7_hghf3qjc0000gn_T_Student_370c84_mi_0, self);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>找到关于<code>super</code>调用的部分代码(3-5)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Student"</span>))&#125;, sel_registerName(<span class="string">"eat"</span>));</span></pre></td></tr></table></figure>

<p>我们发现，当<code>super</code>调用时，其实是调用的<code>objc_msgSendSuper</code>方法进行的消息发送，我们看下官方文档对于此方法的解释：</p>
<blockquote>
<p>Sends a message with a simple return value to the superclass of an instance of a class.</p>
</blockquote>
<p>向超类发送消息。</p>
<p>通过代码(3-5)，可以得知，我们这里有两个参数，一个是结构体指针类型<code>__rw_objc_super</code>，一个是返回<code>SEL</code>类型方法编号的<code>sel_registerName</code>。而<code>__rw_objc_super</code>在我们编译的<code>Student.cpp</code>文件中可以找到原型，代码(3-6)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>结合官方文档对<code>objc_msgSendSuper</code>方法参数的说明我们得知，<code>__rw_objc_super</code>，也就是<code>objc_super</code>。官方文档对此参数的说明如下：</p>
<blockquote>
<p>A pointer to an <a href="https://developer.apple.com/documentation/objectivec/objc_super?language=objc" target="_blank" rel="noopener"><code>objc_super</code></a> data structure. Pass values identifying the context the message was sent to, including the instance of the class that is to receive the message and the superclass at which to start searching for the method implementation.</p>
</blockquote>
<p>指向<code>objc_super</code>的结构体指针，传递标识了上下文的消息，包含了消息接收者和要在超类中搜索的方法实现。我们再来看一下<code>objc_super</code>结构体的源码(3-7)，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull id receiver;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull Class <span class="class"><span class="keyword">class</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr></table></figure>

<p>结合我们编译的代码(3-5)，我们得知，消息的接收者在这里传递的就是当前对象<code>self</code>，即<code>Student</code>类的实例对象，方法即<code>eat</code> 。</p>
<p>通过上面的分析我们得知，在我们使用<code>super</code>方法调用父类方法时，其实传递了隐藏参数。我们上面说过，<code>self</code>调用返回方法本身，并不一定是你看到的当前调用者。这里可以说明，当我们在父类中使用<code>self</code>时，因为是在子类中通过<code>super</code>方法调用的父类方法，在这过程中，通过隐藏结构体参数，消息接收者传递的是当前的<code>self</code>，也就是<code>Student</code>的实例，所以我们在父类中使用<code>self</code>时，其实是使用子类的实例在调用父类的方法，所以也就有了代码(3-1)和(3-3)的输出。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>super</tag>
        <tag>self</tag>
        <tag>IOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOS.OC]关于类簇</title>
    <url>/content/b7bda735.html</url>
    <content><![CDATA[<h4 id="一、引语"><a href="#一、引语" class="headerlink" title="一、引语"></a>一、引语</h4><p>首先新建基于 Single View App的工程，在<code>ViewController.m</code>文件中添加如下代码(1-1)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [[<span class="built_in">NSString</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<a id="more"></a>
<p>这是一段普通的不能在普通的创建不可变字符串的过程，<code>length</code>为<code>NSString</code>的获取长度的属性，我们输出了字符串的长度，结果为0。然后我们创建一个<code>Person</code>类，添加属性变量<code>age</code>，代码(1-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>然后在<code>ViewControlelr.m</code>中添加代码(1-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [[<span class="built_in">NSString</span> alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person = [[Person alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, person.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过运行我们发现代码完全没有问题，那么我们对上面的代码做如下修改，代码(1-4)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person = [Person alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, person.age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 length:%lu"</span>, string1.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行我们发现有如下结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.183451</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.183520</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] Did you forget to nest alloc <span class="keyword">and</span> init?</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">21</span>:<span class="number">12</span>:<span class="number">01</span><span class="variable">.185386</span>+<span class="number">0800</span> allocmessage[<span class="number">5302</span>:<span class="number">2528864</span>] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -length only defined <span class="keyword">for</span> abstract <span class="keyword">class</span>.  Define -[NSPlaceholderString length]!'</span></pre></td></tr></table></figure>

<p>当输出<code>person.age</code>时没有任何问题，正确输出结果，而执行到<code>string1.length</code>时报错了。错误提示告诉我们<code>NSString</code>要嵌套使用<code>alloc</code>和<code>init</code>方法，并且<code>length</code>属性仅仅是定义在一个抽象类中。那么我们来一看什么是抽象类，摘自百度百科的概念如下：</p>
<blockquote>
<p>抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。</p>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类</p>
<p>抽象类不能实例化</p>
</blockquote>
<p>通过以上说明我们可以得出，其实<code>NSString</code>是一个抽象类，类中只是进行了简单的行为声明，并没有实现。而在<code>Objective-C</code>中并没有明确的抽象类的定义，所以这样的实现方式我们称谓”类簇“。</p>
<h4 id="二、类簇的概念"><a href="#二、类簇的概念" class="headerlink" title="二、类簇的概念"></a>二、类簇的概念</h4><p>类簇(class cluster)，是一种模式，可以隐藏”抽象基类(abstract  base class)“背后的实现细节，用户无需创建子类的实例，只需调用基类方法来创建即可。</p>
<p>下面我们来验证一下，代码(3-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string2 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string3 = <span class="string">@"string"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string4 = [[<span class="built_in">NSString</span> alloc] initWithString:string2];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * string5 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="string">@"string"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string1:%s"</span>, object_getClassName(string1));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string2:%s"</span>, object_getClassName(string2));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string3:%s"</span>, object_getClassName(string3));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string4:%s"</span>, object_getClassName(string4));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string5:%s"</span>, object_getClassName(string5));</span></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423153</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string1:NSPlaceholderString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423323</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string2:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423428</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string3:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423523</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string4:<span class="number">__</span>NSCFConstantString</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">54</span>:<span class="number">42</span><span class="variable">.423616</span>+<span class="number">0800</span> allocmessage[<span class="number">81291</span>:<span class="number">9763415</span>] string5:NSTaggedPointerString</span></pre></td></tr></table></figure>

<p>PS:通过上面的结果可以看出，<code>string3</code>和<code>string4</code>本质上是一样的，所以在创建字符串时，如果不是通过一个字符串来创建另一个字符串的情况用<code>string3</code>的方式创建即可。</p>
<p>通过结果可以看出我们创建的字符串对象本质上并不是一个<code>NSString</code>类型，而是其子类类型，我们通过以下方法可以验证，代码(3-2)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"superclass:%@"</span>, [<span class="built_in">NSClassFromString</span>(<span class="string">@"NSTaggedPointerString"</span>) superclass]);</span></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">02</span><span class="variable">.662405</span>+<span class="number">0800</span> allocmessage[<span class="number">81090</span>:<span class="number">9732886</span>] superclass:NSString</span></pre></td></tr></table></figure>

<p>所以当我们使用<code>isMemberOfClass</code>来判断字符串是否是当前类时，得到的结果是否定的，代码(3-3)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>([string3 isMemberOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"是NSString当前类"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span> <span class="built_in">NSLog</span>(<span class="string">@"否"</span>);</span></pre></td></tr></table></figure>

<p>结构为：否。</p>
<p>当然我们可以通过<code>isKindOfClass</code>来判断，结果是正确是正确的。</p>
<h4 id="三、地址验证"><a href="#三、地址验证" class="headerlink" title="三、地址验证"></a>三、地址验证</h4><p>首先重写<code>Person</code>类的<code>init</code>初始化方法，代码(4-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">self</span>.age = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后在<code>ViewController</code>的<code>viewDidLoad</code>方法中添加代码(4-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person1 = [Person alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Person * person2 = [person1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person1 address:%p"</span>, person1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person2 address:%p"</span>, person2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string1 = [<span class="built_in">NSString</span> alloc];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string2 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string3 = [string1 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string4 = [string2 init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string5 = [string1 initWithFormat:<span class="string">@"string1"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSString</span> * string6 = [string1 initWithString:<span class="string">@"string2"</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string1 address:%p"</span>, string1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string2 address:%p"</span>, string2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string3 address:%p"</span>, string3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string4 address:%p"</span>, string4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string5 address:%p"</span>, string5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"string6 address:%p"</span>, string6);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355410</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] person1 address:<span class="number">0</span>x600001fe8340</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355542</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] person2 address:<span class="number">0</span>x600001fe8340</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355643</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string1 address:<span class="number">0</span>x1103f16f8</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355714</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string2 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355779</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string3 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355851</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string4 address:<span class="number">0</span>x1103fb878</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.355940</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string5 address:<span class="number">0</span>xb716bea187e38d28</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">34</span><span class="variable">.356021</span>+<span class="number">0800</span> allocmessage[<span class="number">81487</span>:<span class="number">9784814</span>] string6 address:<span class="number">0</span>x10fdce0e8</span></pre></td></tr></table></figure>

<p>通过以上代码可以看出，<code>Person</code>类创建的对象，在<code>alloc</code>分配内存空间与初始化后的地址是一致的，也就是说<code>init</code>初始化方法只是完成了我们覆盖方法的赋值初始化操作。而<code>NSString</code>创建的对象在<code>alloc</code>分配内存空间后，初始化<code>init</code>方法又一次完成了分配空间的操作，重新分配了内存地址。</p>
<p>而通过基本的<code>init</code>初始化方法分配的内存地址是一致的，无论多次调用也不会改变，即指向了同一块内存区域。而<code>initWithFormat</code>，<code>initWithString</code>等带参数的初始化方法则重新分配了不同的内存空间。</p>
<p>PS：通过以上代码可以发现，类簇<code>alloc</code>分配内存空间后，<code>init</code>方法又一次重新分配了内存空间，又一次完成了开辟地址的操作。而非类簇的<code>Person</code>类则无此操作。</p>
<p>在关于<code>Initializers</code>的官方文档中有这样的叙述：</p>
<blockquote>
<p>Although <code>init...</code> methods are required by their method signature to return an object, that object is not necessarily the one that was most recently allocated—the receiver of the <code>init...</code> message. In other words, the object you get back from an initializer might not be the one you thought was being initialized.</p>
</blockquote>
<p>PS:大概意思是说：虽然<code>init</code>通过方法返回了一个对象，但这个这个对象并不一定是您最近分配的对象。换句话说，返回的对象并不一定是你认为的初始化方法返回的对象。</p>
<p>这些我们在类簇的模式中也得到了验证。</p>
<h4 id="四、类簇的实现"><a href="#四、类簇的实现" class="headerlink" title="四、类簇的实现"></a>四、类簇的实现</h4><p>改造<code>Person</code>类，<code>.h</code>文文件代码(5-1)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MWPersonType) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeProgrammer,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeDesigner,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MWPTypeTester,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPersonType:(MWPersonType)type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)work;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span></pre></td></tr></table></figure>

<p><code>.m</code>文件代码(5-2)，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonProgrammer.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonDesigner.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MWPersonTester.h"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPersonType:(MWPersonType)type &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span> (type) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeProgrammer:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonProgrammer alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeDesigner:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonDesigner alloc] init] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">case</span> MWPTypeTester:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span> = [[MWPersonTester alloc] init];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)work &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//do something</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">@end</span></span></pre></td></tr></table></figure>

<p>分别实现<code>MWPersonProgrammer</code>，<code>MWPersonDesigner</code>，<code>MWPersonTester</code>，并全部继承于<code>Person</code>类，并在<code>.m</code>文件中实现自己的<code>work</code>方法。</p>
<h4 id="五、引申"><a href="#五、引申" class="headerlink" title="五、引申"></a>五、引申</h4><p>我们熟悉的<code>self = [super init]</code>这种写法，其中有一个原因就是类簇的模式。因为返回类型并不一定是当前类型。上面的例子，当我们初始化<code>Person</code>的对象时，其返回的对象并不是<code>Person</code>对象。<code>self = [super init]</code>写法并不会对<code>self</code>的指向造成任何影响，<code>self</code>总是指向当前类，父类的指针可以指向子类。主要的目的就是确保父类初始化成功，不会返回<code>nil</code>。</p>
<h4 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h4><p>OC中类簇的模式被大量使用，如<code>NSNumber</code>，<code>NSArray</code>，<code>UIButton</code>，<code>NSDictionary</code>等。类簇并非无法继承，而是需要实现特定的方法等。</p>
]]></content>
      <categories>
        <category>移动开发</category>
        <category>IOS开发</category>
      </categories>
      <tags>
        <tag>ObjC</tag>
        <tag>IOS</tag>
        <tag>Objective-C</tag>
        <tag>类簇</tag>
      </tags>
  </entry>
</search>
